<!DOCTYPE html>
<!-- saved from url=(0044)file:///C:/Users/Amr1/Desktop/CSCourses.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } 
</style>
    <style>
      /* ============================================================
         MODERN 2025 UI DESIGN SYSTEM
         - Inter typography
         - Glassmorphism panels
         - Soft color palette
         - Micro-animations
         - Card-based layout
      ============================================================ */

      :root {
        --bg-primary: #f0f4ff;
        --bg-secondary: #ffffff;
        --accent: #2563eb;
        --accent-dark: #1d4ed8;
        --accent-light: #eff6ff;
        --success: #22c55e;
        --success-bg: #f0fdf4;
        --warning: #f97316;
        --warning-bg: #fff7ed;
        --danger: #ef4444;
        --danger-bg: #fef2f2;
        --text-primary: #0f172a;
        --text-secondary: #475569;
        --text-muted: #94a3b8;
        --border: #e2e8f0;
        --shadow-sm: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
        --shadow-md: 0 4px 16px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04);
        --shadow-lg: 0 20px 40px rgba(0,0,0,0.10), 0 8px 16px rgba(0,0,0,0.06);
        --radius-sm: 8px;
        --radius-md: 16px;
        --radius-lg: 24px;
        --glass-bg: rgba(255,255,255,0.72);
        --glass-border: rgba(255,255,255,0.5);
        --glass-blur: blur(16px);
      }

      * { box-sizing: border-box; }

      body {
        font-family: 'Inter', 'Segoe UI', sans-serif;
        background: linear-gradient(135deg, #1e3a8a 0%, #1e293b 100%);
        background-attachment: fixed;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        padding-top: 80px;
        padding-bottom: 80px;
        scroll-behavior: smooth;
        color: var(--text-primary);
      }

      /* ---- Navbar ---- */
      h2 {
        text-align: center;
        font-family: 'Poppins', 'Inter', sans-serif;
        font-size: 18px;
        font-weight: 600;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        margin: 0;
        padding: 0 20px;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border-bottom: 1px solid var(--glass-border);
        box-shadow: 0 4px 24px rgba(0,0,0,0.12);
        z-index: 1000;
        color: var(--text-primary);
        letter-spacing: -0.3px;
      }

      /* ---- Course Table ---- */
      .course {
        border: 1px solid var(--border);
        text-align: center;
        padding: 8px 6px;
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
        font-size: 13px;
        border-radius: 4px;
      }

      .course:hover {
        opacity: 0.88;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      }

      .header {
        text-align: center;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        color: white;
        font-weight: 600;
        font-size: 13px;
        padding: 10px 8px;
        border-radius: 6px;
        border: none;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        letter-spacing: 0.3px;
      }

      .prev { background-color: #ede9fe; color: #5b21b6; }
      .direct { background-color: #dbeafe; color: #1d4ed8; }
      .selected { background-color: #d1fae5; color: #065f46; }
      .next { background-color: #fef3c7; color: #92400e; }

      input { margin-top: 7px; }

      /* ---- Legend ---- */
      #legend {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
        margin: 0;
        padding: 12px 16px;
        width: fit-content;
      }

      #legend tbody {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      #legend tr {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      #legend td {
        padding: 4px 6px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      #legend td:first-child {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
        border-radius: 4px;
        padding: 0;
      }

      #legend td:last-child {
        white-space: nowrap;
      }

      #courses_table {
        margin-bottom: 0;
        border-radius: var(--radius-md);
        overflow: hidden;
      }

      /* ---- Toggle container ---- */
      .legend-toggle-container {
        display: flex;
        align-items: center;
        gap: 24px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      /* ---- Toggle Switch ---- */
      .switch {
        position: relative;
        display: inline-block;
        line-height: 26px;
        width: 48px;
        height: 26px;
        margin: 0;
        flex-shrink: 0;
      }

      .switch input { opacity: 0; width: 0; height: 0; }

      .slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background-color: #cbd5e1;
        border-radius: 26px;
        transition: 0.3s;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 4px;
        bottom: 4px;
        background: white;
        transition: 0.3s;
        border-radius: 50%;
        box-shadow: 0 1px 4px rgba(0,0,0,0.15);
      }

      input:checked + .slider { background-color: var(--accent); }
      input:focus + .slider { box-shadow: 0 0 0 3px rgba(37,99,235,0.2); }
      input:checked + .slider:before { transform: translateX(22px); }

      /* ============================================================
         TECHBOT NOTIFICATION SYSTEM
      ============================================================ */
      
      /* Toast Notification (Bottom Right) */
      #techbot-toast {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 10000;
        display: flex;
        align-items: flex-end;
        gap: 15px;
        max-width: 400px;
        transform: translateX(500px);
        transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      #techbot-toast.show {
        transform: translateX(0);
      }

      .bot-character {
        flex-shrink: 0;
        width: 72px;
        height: 72px;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 56px;
        animation: headFloat 2.5s ease-in-out infinite;
      }
      
      .robot-mouth-overlay {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        width: 20px;
        height: 5px;
        background: #1f2937;
        border-radius: 2px;
        pointer-events: none;
      }

      .toast-message {
        background: linear-gradient(135deg, #1e293b, #0f172a);
        padding: 14px 18px 14px 16px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.35), 0 0 0 1px rgba(99,179,237,0.15);
        border: 1px solid rgba(99,179,237,0.25);
        position: relative;
        max-width: 280px;
        backdrop-filter: blur(8px);
      }

      .toast-message::before {
        content: '';
        position: absolute;
        bottom: 22px;
        left: -8px;
        width: 0;
        height: 0;
        border-style: solid;
        border-width: 7px 8px 7px 0;
        border-color: transparent #1e293b transparent transparent;
      }

      .toast-message-title {
        font-weight: 700;
        color: #60a5fa;
        margin-bottom: 5px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        font-family: 'Poppins', sans-serif;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .toast-message-text {
        color: #e2e8f0;
        font-size: 14px;
        line-height: 1.7;
        font-family: 'Inter', sans-serif;
        font-weight: 400;
        letter-spacing: 0.01em;
      }
      
      .toast-message-text strong {
        color: #60a5fa;
        font-weight: 600;
      }

      /* Modal Dialog with Bot */
      #techbot-modal {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(4px);
        z-index: 10001;
        display: none;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
      }

      #techbot-modal.show {
        display: flex;
      }

      .modal-content {
        background: white;
        border-radius: 24px;
        padding: 40px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        position: relative;
        animation: slideUp 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slideUp {
        from { 
          transform: translateY(50px);
          opacity: 0;
        }
        to { 
          transform: translateY(0);
          opacity: 1;
        }
      }

      .modal-bot {
        text-align: center;
        margin-bottom: 24px;
      }

      .modal-bot svg {
        width: 100px;
        height: 120px;
        margin: 0 auto;
      }

      .modal-message {
        text-align: center;
        margin-bottom: 24px;
      }

      .modal-message h3 {
        color: #2563eb;
        font-size: 17px;
        font-weight: 700;
        margin-bottom: 12px;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -0.3px;
      }

      .modal-message p {
        color: #374151;
        font-size: 15px;
        line-height: 1.8;
        font-family: 'Inter', sans-serif;
        white-space: pre-wrap;
        letter-spacing: 0.01em;
      }
      
      .modal-message p strong {
        color: #2563eb;
        font-weight: 600;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
      }

      .modal-btn {
        padding: 12px 28px;
        border-radius: 12px;
        border: none;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .modal-btn-primary {
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        color: white;
        box-shadow: 0 4px 12px rgba(37,99,235,0.3);
      }

      .modal-btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(37,99,235,0.4);
      }

      .modal-btn-secondary {
        background: #f3f4f6;
        color: #4b5563;
      }

      .modal-btn-secondary:hover {
        background: #e5e7eb;
      }

      /* ============================================================
         ROBOT ANIMATIONS
      ============================================================ */
      
      /* Speaking mouth â€” active when toast is visible */
      #techbot-toast.show .robot-mouth-overlay,
      #techbot-modal.show .robot-mouth-overlay {
        animation: mouthSpeak 0.2s ease-in-out infinite;
      }

      @keyframes headFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-4px); }
      }
      
      @keyframes mouthSpeak {
        0%, 100% { height: 5px; }
        50% { height: 2px; }
      }

      #div_sel {
        color: var(--text-muted);
        margin: 10px 0;
        font-size: 13px;
      }

      /* ---- Panels / Cards ---- */
      #courses_table {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-md);
        margin: 0 auto 0 auto;
        padding: 16px;
      }

      .select-multiple-container {
        text-align: center;
        display: flex;
        align-items: center;
        gap: 10px;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        padding: 12px 18px;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        box-shadow: var(--shadow-sm);
        width: fit-content;
      }

      .upload-container {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        margin: 20px auto;
        padding: 28px;
        max-width: 1200px;
      }

      .courses-section {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        margin: 20px auto;
        padding: 24px;
        max-width: 1400px;
      }

      /* ---- Upload Box ---- */
      .upload-box {
        background: linear-gradient(135deg, rgba(239,246,255,0.9), rgba(219,234,254,0.9));
        border-radius: var(--radius-lg);
        padding: 48px 24px;
        text-align: center;
        border: 2px dashed #93c5fd;
        transition: all 0.3s ease;
        cursor: pointer;
        max-width: 600px;
        margin: 0 auto;
      }

      .upload-box:hover {
        border-color: var(--accent);
        background: linear-gradient(135deg, rgba(219,234,254,0.95), rgba(199,220,254,0.95));
        transform: translateY(-3px);
        box-shadow: 0 12px 32px rgba(37,99,235,0.18);
      }

      .upload-box input[type="file"] { display: none; }

      .upload-label {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 14px 40px;
        background: linear-gradient(135deg, var(--accent) 0%, #1d4ed8 100%);
        color: white;
        border-radius: var(--radius-md);
        font-weight: 600;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s ease;
        pointer-events: none;
        box-shadow: 0 4px 16px rgba(37,99,235,0.35);
        letter-spacing: -0.2px;
      }

      .upload-hint {
        margin-top: 16px;
        color: var(--text-secondary);
        font-size: 15px;
        font-weight: 500;
      }

      /* ---- Stat Cards ---- */
      .stats-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-top: 24px;
      }

      .stat-card {
        background: white;
        border-radius: var(--radius-md);
        padding: 24px 20px;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        position: relative;
        overflow: hidden;
      }

      .stat-card::before {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--accent), #818cf8);
        border-radius: 3px 3px 0 0;
      }

      .stat-card:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow-lg);
      }

      .stat-card h3 {
        margin: 0 0 10px 0;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }

      .stat-value {
        font-size: 34px;
        font-weight: 700;
        color: var(--accent);
        margin-bottom: 8px;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -1px;
      }

      .stat-label {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* ---- Progress Bars ---- */
      .progress-bar {
        width: 100%;
        height: 6px;
        background: #e2e8f0;
        border-radius: 99px;
        overflow: hidden;
        margin-top: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent) 0%, #818cf8 100%);
        border-radius: 99px;
        transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* ---- Graduation Ring ---- */
      .graduation-ring-container {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-top: 12px;
      }

      .ring-svg { flex-shrink: 0; }

      .ring-bg { fill: none; stroke: #e2e8f0; stroke-width: 8; }
      .ring-fill {
        fill: none;
        stroke: url(#ringGrad);
        stroke-width: 8;
        stroke-linecap: round;
        transition: stroke-dashoffset 1s cubic-bezier(0.4,0,0.2,1);
        transform: rotate(-90deg);
        transform-origin: center;
      }

      /* ---- Remaining Courses ---- */
      .remaining-courses {
        background: white;
        border-radius: var(--radius-md);
        padding: 24px;
        margin-top: 20px;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
      }

      .remaining-courses h3 {
        margin: 0 0 18px 0;
        color: var(--text-primary);
        font-size: 17px;
        font-weight: 600;
        font-family: 'Poppins', sans-serif;
      }

      .course-list { display: grid; gap: 8px; }

      .course-item {
        padding: 12px 16px;
        border-radius: var(--radius-sm);
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.2s ease;
        cursor: grab;
      }

      .course-item:hover { transform: translateX(4px); }

      .course-item.available {
        background: var(--success-bg);
        border-left: 3px solid var(--success);
      }

      .course-item.locked {
        background: #fff5f5;
        border-left: 3px solid #fc8181;
      }

      .course-item-name { font-weight: 600; color: var(--text-primary); font-size: 14px; }
      .course-item-code { font-size: 12px; color: var(--text-muted); margin-left: 8px; }

      .course-item-hours {
        background: linear-gradient(135deg, var(--accent), #818cf8);
        color: white;
        padding: 4px 12px;
        border-radius: 99px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
      }

      /* ---- Study Plan ---- */
      .study-plan-container {
        background: white;
        border-radius: var(--radius-md);
        padding: 24px;
        margin-top: 20px;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
      }

      .study-plan-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 12px;
      }

      .study-plan-header h3 {
        margin: 0;
        color: var(--text-primary);
        font-size: 18px;
        font-weight: 700;
        font-family: 'Poppins', sans-serif;
      }

      .plan-selector { display: flex; gap: 8px; flex-wrap: wrap; }

      .plan-option {
        padding: 8px 18px;
        border: 2px solid var(--accent);
        background: white;
        color: var(--accent);
        border-radius: 99px;
        cursor: pointer;
        font-weight: 600;
        font-size: 13px;
        transition: all 0.2s ease;
      }

      .plan-option.active,
      .plan-option:hover {
        background: var(--accent);
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(37,99,235,0.25);
      }

      .generate-plan-btn {
        background: linear-gradient(135deg, var(--accent) 0%, #1d4ed8 100%);
        color: white;
        border: none;
        padding: 12px 28px;
        border-radius: 99px;
        font-weight: 700;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 16px rgba(37,99,235,0.35);
        letter-spacing: -0.2px;
      }

      .generate-plan-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 24px rgba(37,99,235,0.45);
      }

      /* ---- Semester Cards ---- */
      .semester-card {
        background: #f8faff;
        border-radius: var(--radius-md);
        padding: 20px;
        margin-bottom: 16px;
        border: 1px solid #e2e8f0;
        border-left: 4px solid var(--accent);
        transition: all 0.25s ease;
        position: relative;
      }

      .semester-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(37,99,235,0.10);
      }

      .semester-card.invalid-drop { background-color: #fef2f2; }

      .semester-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 14px;
        flex-wrap: wrap;
        gap: 8px;
      }

      .semester-title {
        font-weight: 700;
        color: var(--text-primary);
        font-size: 15px;
        font-family: 'Poppins', sans-serif;
      }

      .semester-hours {
        background: linear-gradient(135deg, var(--accent), #818cf8);
        color: white;
        padding: 5px 14px;
        border-radius: 99px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
      }

      .semester-courses {
        display: grid;
        gap: 8px;
        min-height: 64px;
        padding: 10px;
        border-radius: var(--radius-sm);
        transition: all 0.2s ease;
        background: rgba(255,255,255,0.7);
        border: 1px dashed transparent;
      }

      .semester-courses.drag-over {
        background-color: var(--accent-light);
        border-color: var(--accent);
      }

      .semester-course-item {
        background: white;
        padding: 10px 14px;
        border-radius: var(--radius-sm);
        font-size: 13px;
        color: var(--text-secondary);
        border-left: 3px solid var(--accent);
        cursor: grab;
        transition: all 0.2s ease;
        user-select: none;
        box-shadow: var(--shadow-sm);
        display: flex;
        align-items: center;
      }

      .semester-course-item:hover {
        background: #f0f9ff;
        box-shadow: 0 4px 12px rgba(37,99,235,0.12);
        transform: translateY(-1px);
      }

      .semester-course-item:active { cursor: grabbing; }

      .semester-course-item.dragging {
        opacity: 0.45;
        transform: scale(0.96);
      }

      .semester-course-code {
        font-weight: 700;
        color: var(--accent);
        margin-right: 8px;
        font-size: 12px;
        background: #eff6ff;
        padding: 2px 8px;
        border-radius: 99px;
      }

      .course-drag-handle {
        color: #cbd5e1;
        margin-right: 8px;
        font-size: 16px;
        flex-shrink: 0;
      }

      .plan-summary {
        background: linear-gradient(135deg, #f0fdf4, #dcfce7);
        padding: 18px 20px;
        border-radius: var(--radius-md);
        margin-top: 20px;
        border-left: 4px solid var(--success);
        border: 1px solid #bbf7d0;
      }

      .plan-summary-title {
        font-weight: 700;
        color: #166534;
        margin-bottom: 12px;
        font-size: 15px;
        font-family: 'Poppins', sans-serif;
      }

      .plan-summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* ---- Summer Semester ---- */
      .summer-semester {
        background: linear-gradient(135deg, #fffbeb, #fef9e7) !important;
        border-left-color: var(--warning) !important;
        border-color: #fde68a !important;
      }

      .summer-semester .semester-hours {
        background: linear-gradient(135deg, var(--warning), #ea580c) !important;
      }

      .summer-semester .semester-course-item {
        border-left-color: var(--warning);
      }

      .summer-semester .semester-course-code {
        color: var(--warning);
        background: #fff7ed;
      }

      /* ---- Action Buttons ---- */
      .semester-actions {
        display: flex;
        gap: 10px;
        align-items: flex-start;
        margin-top: 4px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      #validationMessage { flex: 1 1 100%; min-width: 100%; }

      .reset-plan-btn {
        background: white;
        color: var(--warning);
        border: 2px solid #fed7aa;
        padding: 8px 18px;
        border-radius: 99px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .reset-plan-btn:hover {
        background: #fff7ed;
        border-color: var(--warning);
        transform: translateY(-1px);
      }

      .export-btn {
        background: linear-gradient(135deg, var(--success), #16a34a);
        color: white;
        border: none;
        padding: 8px 18px;
        border-radius: 99px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.25s;
        box-shadow: 0 2px 8px rgba(34,197,94,0.25);
      }

      .export-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(34,197,94,0.35);
      }

      .export-btn.xlsx {
        background: linear-gradient(135deg, var(--accent), #1d4ed8);
        box-shadow: 0 2px 8px rgba(37,99,235,0.25);
      }

      .export-btn.xlsx:hover {
        box-shadow: 0 6px 16px rgba(37,99,235,0.35);
      }

      .export-btn.pdf-btn {
        background: linear-gradient(135deg, #dc2626, #b91c1c);
        box-shadow: 0 2px 8px rgba(220,38,38,0.25);
      }

      .export-btn.pdf-btn:hover {
        box-shadow: 0 6px 16px rgba(220,38,38,0.35);
      }

      /* ---- Program Selector ---- */
      .program {
        cursor: pointer;
        font-size: 22px;
        font-weight: 600;
        color: #94a3b8;
        transition: all 0.25s ease;
        padding: 4px 14px;
        border-radius: var(--radius-sm);
        font-family: 'Poppins', sans-serif;
      }

      .program:hover { background: rgba(37,99,235,0.08); color: var(--accent); }
      .program.active { color: var(--accent); background: rgba(37,99,235,0.1); }

      /* ---- Buttons (summer add / delete) ---- */
      .add-summer-btn {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        color: #1c1917;
        border: none;
        padding: 10px 20px;
        border-radius: 99px;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        margin: 10px 0;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(251,191,36,0.3);
      }

      .add-summer-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(251,191,36,0.4);
      }

      .add-summer-after-btn {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        color: #1c1917;
        border: none;
        padding: 6px 16px;
        border-radius: 99px;
        font-weight: 700;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(251,191,36,0.3);
      }

      .add-summer-after-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(251,191,36,0.4);
      }

      .delete-semester-btn {
        background: #fee2e2;
        color: var(--danger);
        border: 1px solid #fca5a5;
        padding: 5px 12px;
        border-radius: 99px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        margin-left: 10px;
        transition: all 0.2s;
      }

      .delete-semester-btn:hover {
        background: var(--danger);
        color: white;
        border-color: var(--danger);
      }

      /* ---- Validation Messages ---- */
      .validation-message {
        background: #fefce8;
        border: 1px solid #fde047;
        color: #713f12;
        padding: 12px 16px;
        border-radius: var(--radius-sm);
        margin: 10px 0;
        font-size: 13px;
        font-weight: 500;
        display: none;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from { opacity: 0; transform: translateY(-8px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .validation-message.error { background: var(--danger-bg); border-color: #fca5a5; color: #991b1b; }
      .validation-message.success { background: var(--success-bg); border-color: #86efac; color: #166534; }
      .validation-message.info { background: #eff6ff; border-color: #93c5fd; color: #1e40af; }

      /* ---- Student Info ---- */
      .student-info {
        background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
        border-radius: var(--radius-md);
        padding: 18px 20px;
        margin-top: 16px;
        border: 1px solid #bae6fd;
      }

      .student-info h4 {
        margin: 0 0 10px 0;
        color: var(--accent);
        font-size: 14px;
        font-weight: 700;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -0.2px;
      }

      .student-info p {
        margin: 5px 0;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* ---- Debug Log ---- */
      .debug-line { padding: 4px 0; border-bottom: 1px solid #1e293b; font-size: 12px; }
      .debug-success { color: #4ade80; }
      .debug-error { color: #f87171; }
      .debug-warning { color: #fbbf24; }

      /* ---- Floating Action Buttons ---- */
      .fab-container {
        position: fixed;
        bottom: 28px;
        right: 28px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 12px;
        z-index: 999;
      }

      .fab-btn {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px 22px;
        border-radius: 99px;
        border: none;
        font-family: 'Inter', sans-serif;
        font-weight: 700;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        white-space: nowrap;
        letter-spacing: -0.2px;
      }

      .fab-btn:hover {
        transform: translateY(-4px) scale(1.03);
        box-shadow: 0 16px 36px rgba(0,0,0,0.28);
      }

      .fab-btn:active { transform: translateY(-1px) scale(0.99); }

      .fab-pdf {
        background: linear-gradient(135deg, #dc2626, #b91c1c);
        color: white;
      }

      .fab-generate {
        background: linear-gradient(135deg, var(--accent), #1d4ed8);
        color: white;
      }

      /* ---- Progress Ring Stat Card ---- */
      .stat-card.ring-card {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .ring-info { flex: 1; }

      /* ---- Graduation Timeline ---- */
      .graduation-timeline {
        display: flex;
        align-items: center;
        gap: 0;
        overflow-x: auto;
        padding: 16px 0 8px;
        margin-top: 4px;
        scrollbar-width: thin;
      }

      .timeline-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        min-width: 90px;
      }

      .timeline-step:not(:last-child)::after {
        content: '';
        position: absolute;
        top: 15px;
        left: 50%;
        width: 100%;
        height: 2px;
        background: #e2e8f0;
        z-index: 0;
      }

      .timeline-step.completed:not(:last-child)::after {
        background: linear-gradient(90deg, var(--success), var(--accent));
      }

      .timeline-dot {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 3px solid #e2e8f0;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 700;
        position: relative;
        z-index: 1;
        transition: all 0.3s ease;
        color: #94a3b8;
      }

      .timeline-step.completed .timeline-dot {
        background: linear-gradient(135deg, var(--success), var(--accent));
        border-color: transparent;
        color: white;
        box-shadow: 0 4px 12px rgba(34,197,94,0.4);
      }

      .timeline-step.current .timeline-dot {
        background: linear-gradient(135deg, var(--accent), #818cf8);
        border-color: transparent;
        color: white;
        box-shadow: 0 4px 16px rgba(37,99,235,0.5);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%, 100% { box-shadow: 0 0 0 0 rgba(37,99,235,0.4); }
        50% { box-shadow: 0 0 0 8px rgba(37,99,235,0); }
      }

      .timeline-label {
        margin-top: 8px;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-align: center;
        max-width: 80px;
      }

      .timeline-step.completed .timeline-label { color: var(--success); }
      .timeline-step.current .timeline-label { color: var(--accent); }

      /* ---- Special Case Star Toggle ---- */
      .special-case-toggle {
        background: transparent;
        border: 1.5px solid #cbd5e1;
        border-radius: 99px;
        padding: 3px 10px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        color: #94a3b8;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        font-family: 'Inter', sans-serif;
      }
      .special-case-toggle:hover {
        border-color: #d4af37;
        color: #b8930a;
        background: #fef9e7;
      }
      .special-case-toggle.active {
        background: linear-gradient(135deg, #fef8e6, #fdf4d8);
        border-color: #d4af37;
        color: #8b7300;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
      }
      .special-case-toggle.active:hover {
        background: linear-gradient(135deg, #fdf4d8, #fcefc5);
        box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
      }

      /* ---- Special Case Semester Card ---- */
      .semester-card.special-case-active {
        border-left-color: #d4af37 !important;
        background: linear-gradient(135deg, #fef9e7, #fdf5dc) !important;
        box-shadow: 0 4px 12px rgba(212, 175, 55, 0.15) !important;
      }
      .summer-semester.special-case-active {
        background: linear-gradient(135deg, #fef8e6, #fdf4d8) !important;
      }
      
      /* Special case hours badge */
      .special-case-active .semester-hours {
        background: linear-gradient(135deg, #d4af37, #c19a2e) !important;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
      }
      .course-remove-btn {
        background: transparent;
        border: none;
        color: #cbd5e1;
        cursor: pointer;
        font-size: 14px;
        font-weight: 700;
        padding: 2px 6px;
        border-radius: 4px;
        line-height: 1;
        transition: all 0.15s ease;
        margin-left: auto;
        flex-shrink: 0;
      }
      .course-remove-btn:hover {
        background: #fee2e2;
        color: var(--danger);
      }

      /* ---- Semester Footer (Gained / Remaining) ---- */
      .semester-footer {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        padding: 8px 12px;
        background: rgba(37,99,235,0.05);
        border-radius: var(--radius-sm);
        border: 1px solid rgba(37,99,235,0.12);
        font-size: 13px;
        color: var(--text-secondary);
      }
      .summer-semester .semester-footer {
        background: rgba(249,115,22,0.06);
        border-color: rgba(249,115,22,0.15);
      }
      .footer-gained strong { color: #16a34a; }
      .footer-remaining strong { color: var(--accent); }
      .footer-sep { color: var(--border); }

      /* ---- Toast Notification ---- */
      #toastContainer {
        position: fixed;
        bottom: 90px;
        right: 28px;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-end;
        pointer-events: none;
      }
      .toast-msg {
        padding: 12px 18px;
        border-radius: var(--radius-sm);
        font-size: 13px;
        font-weight: 600;
        max-width: 380px;
        box-shadow: var(--shadow-lg);
        animation: toastIn 0.3s ease forwards;
        pointer-events: auto;
      }
      .toast-msg.error   { background: var(--danger-bg); border-left: 4px solid var(--danger); color: #991b1b; }
      .toast-msg.success { background: var(--success-bg); border-left: 4px solid var(--success); color: #166534; }
      .toast-msg.info    { background: #eff6ff; border-left: 4px solid var(--accent); color: #1e40af; }
      .toast-msg.warning { background: var(--warning-bg); border-left: 4px solid var(--warning); color: #92400e; }
      @keyframes toastIn {
        from { opacity: 0; transform: translateX(20px); }
        to   { opacity: 1; transform: translateX(0); }
      }

      /* ---- Print / PDF Styles ---- */
      @media print {
        body {
          background: white !important;
          padding: 0 !important;
          font-family: 'Inter', sans-serif;
        }
        h2, .courses-section, .fab-container, .upload-box, 
        .semester-actions, .add-summer-after-btn, .delete-semester-btn,
        .course-drag-handle, #statsContainer, #remainingCourses,
        #planSelectorDiv, .generate-plan-btn, .study-plan-header button {
          display: none !important;
        }
        .study-plan-container {
          box-shadow: none !important;
          border: none !important;
          padding: 0 !important;
          margin: 0 !important;
        }
        .upload-container {
          box-shadow: none !important;
          background: white !important;
          backdrop-filter: none !important;
          padding: 20px !important;
          margin: 0 !important;
        }
        .student-info { background: #f8fafc !important; }
        .semester-card { break-inside: avoid; margin-bottom: 12px !important; }
        .plan-summary { break-inside: avoid; }
        .semester-course-item { box-shadow: none !important; }
        #studyPlanDisplay::before {
          content: 'ðŸŽ“ Personalized Study Plan';
          display: block;
          font-size: 24px;
          font-weight: 700;
          font-family: 'Poppins', sans-serif;
          color: #0f172a;
          margin-bottom: 20px;
          padding-bottom: 12px;
          border-bottom: 2px solid #e2e8f0;
        }
      }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
      // Configure PDF.js worker - use workerSrc with a fallback
      if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
      // Polyfill: if worker fails, fall back to fake worker (slower but works)
      window.addEventListener('error', function(e) {
        if (e.filename && e.filename.includes('pdf.worker')) {
          console.warn('PDF worker failed to load, using fake worker');
          if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = '';
          }
        }
      });
    </script>
    <script>
      $(function () {
        let courses = null;
       
        const ai_courses = {
          //Sem1
          IT111: {
            name: "Electronics",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          MA111: {
            name: "Mathematics1",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          HU111: {
            name: "Technical Report Writing",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          HU113: {
            name: "Human Rights",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA112: {
            name: "Discrete Math",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          IT110: {
            name: "Introduction to Computers",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          //Sem2
          ST121: {
            name: "Probability and Statistics-1",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU112: {
            name: "Creative and Scientific Thinking",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA113: {
            name: "Mathematics-2",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU101: {
            name: "Micro Economics",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          IT113: {
            name: "Logic Design",
            semester: 2,
            prerequisites: ["IT111"],
            hours: 3,
            isTheoretical: true,
          },
          IT114: {
            name: "Programming Techniques",
            semester: 2,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },

          // Second Year
          //Sem3
          IT215: {
            name: "Object Oriented Programing",
            semester: 3,
            prerequisites: ["IT114"],
            hours: 3,
            isTheoretical: true,
          },
          DS211: {
            name: "Introduction to Database systems",
            semester: 3,
            prerequisites: ["IT114"],
            hours: 3,
            isTheoretical: true,
          },
          MA214: {
            name: "Mathematics-3 ",
            semester: 3,
            prerequisites: ["MA113"],
            hours: 3,
            isTheoretical: true,
          },
          IT231: {
            name: "Computer Networks Technology",
            semester: 3,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },
          ST222: {
            name: "Probability and Statistics-2",
            semester: 3,
            prerequisites: ["ST121"],
            hours: 3,
            isTheoretical: true,
          },
          CS240: {
            name: "Introduction to Software Engineering",
            semester: 3,
            prerequisites: ["IT114"],
            hours: 3,
            isTheoretical: true,
          },

          //Sem 4
          IT217: {
            name: "Introduction to Operation Research",
            semester: 4,
            prerequisites: ["ST121", "IT114"],
            hours: 3,
            isTheoretical: true,
          },
          IT216: {
            name: "Data Structure",
            semester: 4,
            prerequisites: ["IT215"],
            hours: 3,
            isTheoretical: true,
          },
          AI321: {
            name: "Machine Learning Fundamentals",
            semester: 4,
            prerequisites: ["MA214", "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT230: {
            name: "Web Technology",
            semester: 4,
            prerequisites: ["IT215"],
            hours: 3,
            isTheoretical: true,
          },
          HU427: {
            name: "Entrepreneurship",
            semester: 4,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },

          LB211: {
            name: "Networking Fundamentals lab",
            semester: 4,
            prerequisites: ["IT231"],
            hours: 2,
            isTheoretical: false,
          },

          //Third year

          AI341: {
            name: "Computer Vision",
            semester: 5,
            prerequisites: ["IT215"],
            hours: 3,
            isTheoretical: true,
          },
          AI311: {
            name: "Artificial intelligence",
            semester: 5,
            prerequisites: ["IT216"],
            hours: 3,
            isTheoretical: true,
          },
          CS319: {
            name: "Operating Systems",
            semester: 5,
            prerequisites: ["IT216"],
            hours: 3,
            isTheoretical: true,
          },
          AI213: {
            name: "Computational mathematics for learning and data analysis",
            semester: 5,
            prerequisites: ["MA214", "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT318: {
            name: "Computer Organization",
            semester: 5,
            prerequisites: ["IT113", "IT216"],
            hours: 3,
            isTheoretical: true,
          },
          IT341: {
            name: "Algorithms analysis and Design",
            semester: 5,
            prerequisites: ["IT216"],
            hours: 3,
            isTheoretical: true,
          },

          //Sem 6

          AI331: {
            name: "Reinforcement and Deep Learning",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          AI342: {
            name: "Natural Languages Processing",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          AI343: {
            name: "AI Systems Design and Implementation",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          AI351: {
            name: "Intelligent Autonomous Robotics",
            semester: 6,
            prerequisites: ["IT113"],
            hours: 3,
            isTheoretical: true,
          },
          AI361: {
            name: "Big Data",
            semester: 6,
            prerequisites: ["AI213"],
            hours: 3,
            isTheoretical: true,
          },

          // Fourth year

          AI41X: {
            name: "Image Processing",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI48X: {
            name: "Bioinformatics Systems",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI4X1: {
            name: "Artificial intelligence for Cybersecurity",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI212: {
            name: "Reasoning and Knowledge Representation",
            semester: 7,
            prerequisites: ["MA214", "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          LB496: {
            name: "Advanced Machine Learning lab",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          PC401: {
            name: "Graduation Project",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },

          // Sem 8

          AI43X: {
            name: "Elective 4",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI46X: {
            name: "Elective 5",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          LB497: {
            name: "AI Cloud Services lab",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          HU402: {
            name: "Fundamental of Management",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          LB431: {
            name: "Selected labs in AI ",
            semester: 8,
            prerequisites: ["AI311"],
            hours: 3,
            isTheoretical: false,
          },
          PC402: {
            name: "Graduation Project",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          // Additional courses
          TR: {
            name: "Summer Training",
            semester: 0,
            prerequisites: [],
            hours: 2,
            isTheoretical: false,
          },
          BMA001: {
            name: "Mathematics-0",
            semester: 0,
            prerequisites: [],
            hours: 0,
            isTheoretical: true,
          },
        };

        const it_courses = {
          //Sem1
          IT111: {
            name: "Electronics",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          MA111: {
            name: "Mathematics1",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          HU111: {
            name: "Technical Report Writing",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          HU413: {
            name: "Human Rights",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA112: {
            name: "Discrete Math",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          IT110: {
            name: "Introduction to Computers",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          //Sem2
          ST121: {
            name: "Probability and Statistics-1",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU112: {
            name: "Creative and Scientific Thinking",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA113: {
            name: "Mathematics-2",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU101: {
            name: "Micro Economics",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          IT113: {
            name: "Logic Design",
            semester: 2,
            prerequisites: ["IT111"],
            hours: 3,
            isTheoretical: true,
          },
          CS112: {
            name: "Programming Language",
            semester: 2,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },

          // Second Year
          //Sem3
          CS215: {
            name: "Object Oriented Programing",
            semester: 3,
            prerequisites: ["CS112"],
            hours: 3,
            isTheoretical: true,
          },
          DS211: {
            name: "Introduction to Database systems",
            semester: 3,
            prerequisites: ["CS112"],
            hours: 3,
            isTheoretical: true,
          },
          MA214: {
            name: "Mathematics-3 ",
            semester: 3,
            prerequisites: ["MA113"],
            hours: 3,
            isTheoretical: true,
          },
          IT231: {
            name: "Computer Networks Technology",
            semester: 3,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },
          ST222: {
            name: "Probability and Statistics-2",
            semester: 3,
            prerequisites: ["ST121"],
            hours: 3,
            isTheoretical: true,
          },
          CS240: {
            name: "Introduction to Software Engineering",
            semester: 3,
            prerequisites: ["CS112"],
            hours: 3,
            isTheoretical: true,
          },
          //Sem4
          IT217: {
            name: "Introduction to Operation Research",
            semester: 4,
            prerequisites: ["ST121", "CS112"],
            hours: 3,
            isTheoretical: true,
          },
          CS216: {
            name: "Data Structure",
            semester: 4,
            prerequisites: ["CS215"],
            hours: 3,
            isTheoretical: true,
          },
          AI321: {
            name: "Machine Learning Fundamentals",
            semester: 4,
            prerequisites: ["MA214" , "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT230: {
            name: "Web Technology",
            semester: 4,
            prerequisites: ["CS215"],
            hours: 3,
            isTheoretical: true,
          },
          HU427: {
            name: "Entrepreneurship",
            semester: 4,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          LB211: {
            name: "Networking Fundamentals lab",
            semester: 4,
            prerequisites: ["IT231"],
            hours: 2,
            isTheoretical: false,
          },

          // Third year
          //Sem  5
          LB312: {
            name: "Network Routing and Switching-Lab",
            semester: 5,
            prerequisites: ["LB211"],
            hours: 2,
            isTheoretical: false,
          },
          AI311: {
            name: "Artificial intelligence",
            semester: 5,
            prerequisites: ["CS216"],
            hours: 3,
            isTheoretical: true,
          },
          CS319: {
            name: "Operating Systems",
            semester: 5,
            prerequisites: ["CS216"],
            hours: 3,
            isTheoretical: true,
          },
          IT212: {
            name: "Digital Signal Processing",
            semester: 5,
            prerequisites: ["MA214"],
            hours: 3,
            isTheoretical: true,
          },
          CS318: {
            name: "Computer Organization",
            semester: 5,
            prerequisites: ["IT113", "CS216"],
            hours: 3,
            isTheoretical: true,
          },
          CS341: {
            name: "Algorithms analysis and Design",
            semester: 5,
            prerequisites: ["CS216"],
            hours: 3,
            isTheoretical: true,
          },

          // Sem 6
          IT322: {
            name: "Pattern Recognition",
            semester: 6,
            prerequisites: ["IT212" , "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT333: {
            name: "Information Computer Networks Security",
            semester: 6,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          AI448: {
            name: "op-Natural Language Processing",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          CS344: {
            name: "Advanced Software Engineering",
            semester: 6,
            prerequisites: ["CS240"],
            hours: 3,
            isTheoretical: true,
          },
          IT343: {
            name: "Microcontroller",
            semester: 6,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          LB313: {
            name: "Ethical Hacking-lab",
            semester: 6,
            prerequisites: ["IT231"],
            hours: 2,
            isTheoretical: false,
          },

          //Fourth year
          // Sem 7

          LB421: {
            name: "Selected labs in Software Engineering",
            semester: 7,
            prerequisites: ["CS341", "CS344"],
            hours: 2,
            isTheoretical: false,
          },
          IT423: {
            name: "Embedded Systems",
            semester: 7,
            prerequisites: ["IT343"],
            hours: 3,
            isTheoretical: true,
          },
          IT221: {
            name: "Computer Graphics",
            semester: 7,
            prerequisites: ["CS215"],
            hours: 3,
            isTheoretical: true,
          },
          IT434: {
            name: "Advanced Computer Networks",
            semester: 7,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          PC401: {
            name: "Project (1)",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          IT438: {
            name: "Communication Technology",
            semester: 7,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          // Sem 8
          IT436:{
            name: "Cloud Computing Networking",
            semester: 8,
            prerequisites: ["IT434"],
            hours: 3,
            isTheoretical: true,
          },
          AI435: {
            name: "Semantic Web and ontology",
            semester: 8,
            prerequisites: ["AI311", "IT230"],
            hours: 3,
            isTheoretical: true,
          },
          IT439: {
            name: "Wireless and Mobile Networks",
            semester: 8,
            prerequisites: ["IT434"],
            hours: 3,
            isTheoretical: true,
          },
          HU402: {
            name: "Fundamental of Management",
            semester: 8,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          PC402: {
            name: "Project (2)",
            semester: 8,
            prerequisites: ["PC401"],
            hours: 3,
            isTheoretical: false,
          },
          LB431: {
            name: "Selected labs in AI",
            semester: 8,
            prerequisites: ["AI311"],
            hours: 2,
            isTheoretical: false,
          },
          // Additional courses
          TR: {
            name: "Summer Training",
            semester: 0,
            prerequisites: [],
            hours: 2,
            isTheoretical: false,
          },
          BMA001: {
            name: "Mathematics-0",
            semester: 0,
            prerequisites: [],
            hours: 0,
            isTheoretical: true,
          },
        };

        function populateCourses(cs) {
          let coursesTable = document.querySelector("#courses_table");
          coursesTable.innerHTML = "";
          courses = cs;
          Object.keys(courses).forEach(function (c) {
            let key = c;
            let course = courses[c];
            addCourse(key, course);
            var prerequisites = courses[c].prerequisites;
            for (var pre of prerequisites) {
              if (!courses[pre].nextCourses) {
                courses[pre].nextCourses = [];
              }
              courses[pre].nextCourses.push(c);
            }
          });
          selected = [];
          $(".course").click(function () {
            var code = this.id;
            if (!document.querySelector("#selectMulti").checked) {
              //multiple course selection is disabled
              selected = [code];
              $(".course").removeClass("prev");
              $(".course").removeClass("direct");
              $(".course").removeClass("selected");
              $(".course").removeClass("next");
              markDependency(code, 0);
            } else {
              if (selected.indexOf(code) > -1) {
                //selected course; remove it
                unselect(code);
              } else {
                select(code);
              }
            }
            markNextCourses();
            showSelected();
            
            // Auto-scroll to show the selected course and related courses
            autoScrollToCourse(code);
          });
        }
        populateCourses(it_courses);

        var selected = [];
        var courseGrades = {}; // Store grades for each course
        var courseAttempts = {}; // Store number of attempts for each course

        $("#selectMulti").click(function () {
          selected = [];
          courseGrades = {}; // Clear grades
          courseAttempts = {}; // Clear attempts
          $(".course").removeClass("prev");
          $(".course").removeClass("direct");
          $(".course").removeClass("selected");
          $(".course").removeClass("next");
          $(".grade-badge").remove(); // Remove all grade badges
          $(".attempts-badge").remove(); // Remove all attempts badges
          showSelected();
          if (this.checked) {
            $("#legend tr:nth-child(2), #legend tr:nth-child(3)").hide();
          } else {
            $("#legend tr:nth-child(2), #legend tr:nth-child(3)").show();
          }
        });

        function select(code, grade, attempts) {
          selected.push(code);
          $("#" + code).addClass("selected");
          
          console.log(`=== SELECT FUNCTION ===`);
          console.log(`Code: ${code}, Grade: ${grade}, Attempts: ${attempts}`);
          
          // Store and display grade if provided
          if (grade) {
            courseGrades[code] = grade;
            courseAttempts[code] = attempts || 1;
            addBadgesToCourse(code, grade, attempts);
          }
        }
        
        // Helper function to add badges to a course (without selecting it)
        function addBadgesToCourse(code, grade, attempts) {
          const gradeColor = getGradeColor(grade);
          console.log(`Grade color: ${gradeColor}`);
          
          // Build the badge HTML
          let badgeHTML = `<span class="grade-badge" style="background-color: ${gradeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-left: 5px; font-weight: bold;">${grade}</span>`;
          
          // Add attempts badge if more than 1
          if (attempts > 1) {
            console.log(`Adding attempts badge: Ã—${attempts}`);
            badgeHTML += `<span class="attempts-badge" style="background-color: #dc2626; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 3px; font-weight: bold;">Ã—${attempts}</span>`;
          }
          
          console.log(`Badge HTML: ${badgeHTML}`);
          console.log(`Element #${code} exists: ${$("#" + code).length > 0}`);
          console.log(`Element current text: "${$("#" + code).text()}"`);
          
          // Remove existing badges if any
          $("#" + code + " .grade-badge").remove();
          $("#" + code + " .attempts-badge").remove();
          
          // Add new badges
          $("#" + code).append(badgeHTML);
          
          console.log(`After append, element text: "${$("#" + code).text()}"`);
          console.log(`After append, element HTML: "${$("#" + code).html()}"`);
        }
        
        function getGradeColor(grade) {
          const gradeColors = {
            'A+': '#10b981', 'A': '#34d399',
            'B+': '#3b82f6', 'B': '#60a5fa',
            'C+': '#f59e0b', 'C': '#fbbf24',
            'D+': '#ef4444', 'D': '#f87171',
            'P': '#8b5cf6', 'contd': '#6b7280',
            'F': '#991b1b', 'Fr': '#991b1b', 'Abs': '#991b1b', 'NP': '#991b1b'
          };
          return gradeColors[grade] || '#6b7280';
        }

        function unselect(code) {
          selected.splice(selected.indexOf(code), 1);
          $("#" + code).removeClass("selected");
          
          // Remove grade and attempts badges
          $("#" + code + " .grade-badge").remove();
          $("#" + code + " .attempts-badge").remove();
          delete courseGrades[code];
          delete courseAttempts[code];

          if (!courses[code].nextCourses) return;

          for (var i = 0; i < courses[code].nextCourses.length; i++) {
            var nxt = courses[code].nextCourses[i];
            if (selected.indexOf(nxt) > -1) {
              unselect(nxt);
            }
          }
        }

        function showSelected() {
          var credits = 0;
          for (var c of selected) {
            credits += courses[c].hours;
          }

          //$("#div_sel").html("Selected credit hours: " + credits);
        }

        function markDependency(start, level) {
          switch (level) {
            case 0:
              $("#" + start).addClass("selected");
              break;
            case 1:
              $("#" + start).addClass("direct");
              break;
            default:
              $("#" + start).addClass("prev");
              break;
          }

          for (var dep of courses[start].prerequisites) {
            markDependency(dep, level + 1);
          }
        }

        function markNextCourses() {
          $(".course").removeClass("next");
          for (var s of selected) {
            if (!courses[s].nextCourses) continue;
            for (var next of courses[s].nextCourses) {
              if (selected.indexOf(next) == -1) $("#" + next).addClass("next");
            }
          }
        }

        function autoScrollToCourse(courseCode) {
          const courseElement = document.getElementById(courseCode);
          if (!courseElement) return;
          
          // Get all highlighted courses (selected, direct, prev, next)
          const highlightedCourses = document.querySelectorAll('.course.selected, .course.direct, .course.prev, .course.next');
          
          if (highlightedCourses.length === 0) return;
          
          // Find the topmost and bottommost highlighted courses
          let topMostElement = courseElement;
          let bottomMostElement = courseElement;
          let topMostPosition = courseElement.getBoundingClientRect().top;
          let bottomMostPosition = courseElement.getBoundingClientRect().bottom;
          
          highlightedCourses.forEach(course => {
            const rect = course.getBoundingClientRect();
            if (rect.top < topMostPosition) {
              topMostPosition = rect.top;
              topMostElement = course;
            }
            if (rect.bottom > bottomMostPosition) {
              bottomMostPosition = rect.bottom;
              bottomMostElement = course;
            }
          });
          
          // Calculate if we need to scroll
          const viewportHeight = window.innerHeight;
          const headerHeight = 80; // Height of fixed header
          const scrollPadding = 20; // Extra padding for comfort
          
          // Check if all highlighted courses are visible
          const topVisible = topMostPosition >= headerHeight + scrollPadding;
          const bottomVisible = bottomMostPosition <= viewportHeight - scrollPadding;
          
          if (!topVisible || !bottomVisible) {
            // Calculate the center point between topmost and bottommost courses
            const centerY = (topMostElement.getBoundingClientRect().top + bottomMostElement.getBoundingClientRect().bottom) / 2;
            const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
            const targetScroll = currentScroll + centerY - (viewportHeight / 2);
            
            // Smooth scroll to center the highlighted courses
            window.scrollTo({
              top: Math.max(0, targetScroll),
              behavior: 'smooth'
            });
          }
        }

        // Sequential auto-scroll after upload completion
        function autoScrollAfterUpload() {
          // Helper function to scroll to an element smoothly
          function scrollToElement(elementId, duration = 1500) {
            return new Promise((resolve) => {
              const element = document.getElementById(elementId);
              if (!element) {
                resolve();
                return;
              }
              
              const targetPosition = element.getBoundingClientRect().top + window.pageYOffset - 100;
              const startPosition = window.pageYOffset;
              const distance = targetPosition - startPosition;
              let startTime = null;

              function animation(currentTime) {
                if (startTime === null) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const run = ease(timeElapsed, startPosition, distance, duration);
                window.scrollTo(0, run);
                if (timeElapsed < duration) {
                  requestAnimationFrame(animation);
                } else {
                  resolve();
                }
              }

              // Easing function for smooth animation
              function ease(t, b, c, d) {
                t /= d / 2;
                if (t < 1) return c / 2 * t * t + b;
                t--;
                return -c / 2 * (t * (t - 2) - 1) + b;
              }

              requestAnimationFrame(animation);
            });
          }

          // Execute scroll sequence
          async function scrollSequence() {
            // Wait a bit for DOM to update
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // 1. Scroll up to show courses table
            await scrollToElement('courses_table', 1200);
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // 2. Scroll down to show statistics
            await scrollToElement('statsContainer', 1000);
            await new Promise(resolve => setTimeout(resolve, 600));
            
            // 3. Scroll to show remaining courses
            await scrollToElement('remainingCourses', 1000);
            await new Promise(resolve => setTimeout(resolve, 600));
            
            // 4. Scroll to show study plan generator button
            await scrollToElement('studyPlanContainer', 1000);
          }

          scrollSequence();
        }

        // Auto-scroll when study plan is generated (once only)
        function autoScrollToStudyPlan() {
          if (!window._planJustGenerated) return; // Only scroll on fresh generation
          window._planJustGenerated = false;       // Clear flag immediately
          setTimeout(() => {
            const planDisplay = document.getElementById('studyPlanDisplay');
            if (planDisplay && planDisplay.children.length > 0) {
              planDisplay.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start'
              });
            }
          }, 300);
        }

        function addCourse(id, course) {
          const rowId = course.semester === 0 ? "additional-courses" : `semester-${course.semester}`;
          let semesterRow = document.querySelector(`#${rowId}`);
          if (semesterRow == null) {
            let coursesTable = document.querySelector("#courses_table");
            semesterRow = document.createElement("tr");
            semesterRow.id = rowId;
            let td = document.createElement("td");
            td.className = "header";
            td.textContent = course.semester === 0 ? "Additional Courses" : `Semester ${course.semester}`;
            semesterRow.appendChild(td);
            coursesTable.appendChild(semesterRow);
          }
          course_td = document.createElement("td");
          course_td.setAttribute("id", id);
          course_td.className = "course";
          course_td.textContent = course.name;
          // Make draggable for study plan
          course_td.draggable = true;
          course_td.dataset.courseCode = id;
          course_td.addEventListener('dragstart', function(e) {
            draggedElement = e.target;
            draggedCourseCode = id;
            draggedFromSemester = -1;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', id);
            e.target.style.opacity = '0.6';
          });
          course_td.addEventListener('dragend', function(e) {
            e.target.style.opacity = '';
            draggedCourseCode = null;
            draggedFromSemester = null;
            draggedElement = null;
          });
          semesterRow.appendChild(course_td);
        }

        $(".program").click((ev) => {
          let it = document.querySelector("#it");
          let ai = document.querySelector("#ai");
        
          it.classList.remove("active");
          ai.classList.remove("active");
         

          ev.target.classList.add("active");

          if (ev.target.id === "it") {
            console.log("it selected");
            populateCourses(it_courses);
          } else if (ev.target.id === "ai") {
            console.log("ai selected");
            populateCourses(ai_courses);
          } 
        });

        // ========================================
        // PDF AUTO-SELECTION FUNCTIONALITY
        // ========================================

        function addDebugLog(message, type = 'info') {
          const timestamp = new Date().toLocaleTimeString();
          const prefix = type === 'success' ? 'âœ…' : 
                        type === 'error' ? 'âŒ' : 
                        type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
          console.log(`[${timestamp}] ${prefix} ${message}`);
        }

        // Course name normalization for matching
        function normalizeName(name) {
          if (!name) return '';
          return name.toLowerCase()
            .replace(/[^a-z0-9\s]/g, ' ')  // Remove special chars
            .replace(/\s+/g, ' ')          // Normalize spaces
            .trim();
        }

        // Remove filler words
        function removeFillers(name) {
          const fillers = ['and', 'the', 'of', 'to', 'in', 'systems', 'system', 'a', 'an'];
          return name.split(' ').filter(word => !fillers.includes(word)).join(' ');
        }

        // Calculate similarity between two strings
        function similarity(s1, s2) {
          const longer = s1.length > s2.length ? s1 : s2;
          const shorter = s1.length > s2.length ? s2 : s1;
          if (longer.length === 0) return 1.0;
          const editDistance = levenshteinDistance(longer, shorter);
          return (longer.length - editDistance) / longer.length;
        }

        function levenshteinDistance(s1, s2) {
          const costs = [];
          for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
              if (i === 0) {
                costs[j] = j;
              } else if (j > 0) {
                let newValue = costs[j - 1];
                if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                  newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                }
                costs[j - 1] = lastValue;
                lastValue = newValue;
              }
            }
            if (i > 0) costs[s2.length] = lastValue;
          }
          return costs[s2.length];
        }

        // Smart course matching
        function matchCourse(pdfCourseName, pdfCourseCode) {
          // Normalize: Remove spaces from course code
          const normalizedCode = pdfCourseCode.replace(/\s+/g, '');
          
          // Known code aliases (when PDF uses different code than HTML)
          const codeAliases = {
            'HU113': 'HU413',
            'IT240': 'CS240',
            'CS240': 'IT240',
          };
          
          // Try alias first
          const aliasCode = codeAliases[normalizedCode];
          if (aliasCode && courses[aliasCode]) {
            return { code: aliasCode, name: courses[aliasCode].name, score: 1.0 };
          }
          
          // Try normalized code
          if (courses[normalizedCode]) {
            return { code: normalizedCode, name: courses[normalizedCode].name, score: 1.0 };
          }
          
          // Try original code
          if (courses[pdfCourseCode]) {
            return { code: pdfCourseCode, name: courses[pdfCourseCode].name, score: 1.0 };
          }
          
          // No match
          return null;
        }

        // Check if grade is passing - EXPLICIT LIST ONLY
        function isPassingGrade(grade) {
          // ONLY these grades are passing - everything else is FAILING
          const passingGrades = ['A+', 'A', 'B+', 'B', 'C+', 'C', 'D+', 'D', 'P', 'contd'];
          const isPassing = passingGrades.includes(grade);
          
          // Explicit check for common failing grades to catch errors
          const failingGrades = ['F', 'Fr', 'Abs', 'NP', 'W', 'I'];
          if (failingGrades.includes(grade)) {
            return false; // Explicitly return false for known failing grades
          }
          
          return isPassing;
        }

        // Parse PDF and extract courses
        async function parsePDF(file) {
          try {
            addDebugLog('ðŸ“„ Loading PDF file...', 'info');
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');
              fullText += pageText + '\n';
            }

            addDebugLog('âœ… PDF loaded successfully', 'success');
            return extractCoursesFromText(fullText);
          } catch (error) {
            addDebugLog(`âŒ Error parsing PDF: ${error.message}`, 'error');
            return null;
          }
        }

        // Extract courses from text
        function extractCoursesFromText(text) {
          const courses = [];
          
          // VALID GRADES - removed "0" as it's Ø§Ù„Ù†Ù‚Ø§Ø· not Ø§Ù„ØªÙ‚Ø¯ÙŠØ±!
          const gradePattern = 'A\\+|B\\+|C\\+|D\\+|Abs|Fr|NP|contd|A|B|C|D|F|P';
          
          // Pattern 1: CODE NAME CREDITS MAX POINTS GRADE (normal order)
          // Example: MA112 Discrete Mathematics 3 100 2.2000 D+
          const pattern1 = new RegExp(`([A-Z]{2,4}\\s?\\d{3,4}|TR|BMA\\d{3})\\s+(.+?)\\s+\\d+\\s+[\\d.]+\\s+[\\d.]+\\s+(${gradePattern})(?=\\s|$)`, 'g');
          
          // Pattern 2: GRADE POINTS MAX CREDITS NAME CODE (reversed order)
          // Example: D+ 2.2000 100 3 Discrete Mathematics MA112
          const pattern2 = new RegExp(`(${gradePattern})(?=\\s)\\s+[\\d.]+\\s+[\\d.]+\\s+\\d+\\s+(.+?)\\s+([A-Z]{2,4}\\s?\\d{3,4}|TR|BMA\\d{3})`, 'g');
          
          // Pattern 3: NO GRADE - for currently registered courses
          // When Ø§Ù„ØªÙ‚Ø¯ÙŠØ± is blank, the extracted text skips it entirely
          // Order becomes: POINTS MAX CREDITS NAME CODE
          // Example: 0 100 3 Pattern Recognition IT322
          // NOTE: No ^ or $ anchors - PDF text is joined with spaces per page (not per line),
          //       so line-anchored patterns never match mid-page courses.
          //       Use (?:^|\s) to match standalone 0 (not part of a decimal like 2.0000)
          const pattern3 = /(?:^|\s)(0)\s+100\s+(\d+)\s+(.+?)\s+([A-Z]{2,4}\s?\d{3,4}|TR|BMA\d{3})(?=\s|$)/g;
          
          // Also handle reverse: CODE NAME CREDITS MAX POINTS (no grade)
          // Example: IT322 Pattern Recognition 3 100 0
          const pattern4 = /([A-Z]{2,4}\s?\d{3,4}|TR|BMA\d{3})\s+(.+?)\s+\d+\s+100\s+0(?:\s|$)/gm;
          
          let match;
          
          // Try pattern 1 (normal order WITH grade)
          while ((match = pattern1.exec(text)) !== null) {
            const [, code, name, grade] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: grade.trim()
            });
            console.log(`ðŸ“„ Extracted (P1-WithGrade): ${code.trim()} - ${name.trim()} - Grade: "${grade.trim()}"`);
          }
          
          // Try pattern 2 (reversed order WITH grade)
          while ((match = pattern2.exec(text)) !== null) {
            const [, grade, name, code] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: grade.trim()
            });
            console.log(`ðŸ“„ Extracted (P2-WithGrade): ${code.trim()} - ${name.trim()} - Grade: "${grade.trim()}"`);
          }
          
          // Try pattern 3 (NO grade - reversed order, Ø§Ù„ØªÙ‚Ø¯ÙŠØ± missing)
          // Groups: [fullMatch, '0'(points), credits, name, code]
          while ((match = pattern3.exec(text)) !== null) {
            const [, , credits, name, code] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: '' // No grade = empty string
            });
            console.log(`ðŸ“„ Extracted (P3-NoGrade): ${code.trim()} - ${name.trim()} - Grade: "" (registered, no grade yet)`);
          }
          
          // Try pattern 4 (NO grade - normal order)
          while ((match = pattern4.exec(text)) !== null) {
            const [, code, name] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: '' // No grade = empty string
            });
            console.log(`ðŸ“„ Extracted (P4-NoGrade): ${code.trim()} - ${name.trim()} - Grade: "" (registered, no grade yet)`);
          }

          addDebugLog(`ðŸ“Š Found ${courses.length} course entries in document (including duplicates and retakes)`, 'info');
          
          // Don't deduplicate here - return ALL courses including retakes
          // The autoSelectCourses function will handle deduplication and count attempts

          // Extract student info
          const studentInfo = {
            name: text.match(/Ø§Ø³Ù… Ø§Ù„Ø·Ø§Ù„Ø¨\s*:\s*([^\n]+)/)?.[1]?.trim(),
            id: text.match(/Ø±Ù‚Ù… Ø§Ù„Ø·Ø§Ù„Ø¨\s*:\s*(\d+)/)?.[1]?.trim(),
            level: text.match(/Ø§Ù„Ù…Ø³ØªÙˆÙ‰\s*:\s*([^\n]+)/)?.[1]?.trim(),
            gpa: text.match(/Ø§Ù„Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ±Ø§ÙƒÙ…ÙŠ\s*:\s*(\d+\.\d+)/)?.[1]
          };
          
          return { courses: courses, studentInfo }; // Return ALL courses, not deduplicated
        }

        // Auto-select courses from PDF/Excel
        function autoSelectCourses(pdfCourses) {
          document.querySelector("#selectMulti").checked = true;
          selected = [];
          courseGrades = {}; // Clear grades
          courseAttempts = {}; // Clear attempts - will store ALL attempts (passing AND failing)
          $(".course").removeClass("prev direct selected next");
          $(".grade-badge").remove(); // Remove all existing grade badges
          $(".attempts-badge").remove(); // Remove all existing attempts badges

          const coursesByCode = {};
          
          // Separate completed courses from currently registered (no grade)
          const completedCourses = pdfCourses.filter(c => c.grade && c.grade.trim() !== '');
          
          // Deduplication guard: pattern3 can produce false-positive "no-grade" entries
          // for courses like IT438 (grade=F, points=0) because "F 0 100 3 name IT438"
          // also contains the sub-pattern "0 100 3 name IT438".
          // Discard any no-grade entry whose code also appears with a real grade.
          const completedCodes = new Set(completedCourses.map(c => c.code.replace(/\s+/g, '')));
          const rawRegistered = pdfCourses.filter(c => !c.grade || c.grade.trim() === '');
          const registeredCourses = rawRegistered.filter(c => 
            !completedCodes.has(c.code.replace(/\s+/g, ''))
          );
          
          if (registeredCourses.length > 0) {
            addDebugLog(`\nðŸ“Œ CURRENTLY REGISTERED COURSES (${registeredCourses.length} courses - NO GRADES YET):`, 'warning');
            addDebugLog(`   âš ï¸ These courses will NOT be marked as completed`, 'warning');
            addDebugLog(`   âœ… They will be treated as REMAINING courses in the study plan`, 'info');
            addDebugLog(`   ðŸ“ The study plan will start FROM the current semester`, 'info');
            registeredCourses.forEach(c => {
              addDebugLog(`   â³ ${c.code} - ${c.name}`, 'info');
            });
          }
          
          addDebugLog(`\nâœ… PROCESSING ${completedCourses.length} COMPLETED COURSES:`, 'info');
          
          completedCourses.forEach(pdfCourse => {
            const code = pdfCourse.code;
            if (!coursesByCode[code]) {
              coursesByCode[code] = [];
            }
            coursesByCode[code].push(pdfCourse);
          });

          let matched = 0;
          let notMatched = 0;

          for (const [code, attempts] of Object.entries(coursesByCode)) {
            const gradeValue = {
              'A+': 10, 'A': 9, 'B+': 8, 'B': 7, 'C+': 6, 'C': 5,
              'D+': 4, 'D': 3, 'P': 2, 'contd': 1,
              'F': -1, 'Fr': -1, 'Abs': -1, 'NP': -1
            };
            
            attempts.sort((a, b) => (gradeValue[b.grade] || -99) - (gradeValue[a.grade] || -99));
            const bestAttempt = attempts[0];
            const attemptCount = attempts.length; // Count how many times

            if (attemptCount > 1) {
              const allGrades = attempts.map(a => a.grade).join(', ');
              addDebugLog(`ðŸ”„ ${code} has ${attemptCount} attempts (${allGrades}) â†’ Using best: ${bestAttempt.grade}`, 'info');
            }

            const passing = isPassingGrade(bestAttempt.grade);
            
            // Match the course to get the actual course code from our system
            const match = matchCourse(bestAttempt.name, bestAttempt.code);
            
            if (match) {
              // ALWAYS store attempt count and grade for matched courses (whether passing or not)
              courseAttempts[match.code] = attemptCount;
              courseGrades[match.code] = bestAttempt.grade;
              
              if (!passing) {
                // Course failed - DON'T select it but SHOW the badges
                addBadgesToCourse(match.code, bestAttempt.grade, attemptCount);
                addDebugLog(`â­ï¸ Skipped ${code} - ${bestAttempt.name} (Grade: ${bestAttempt.grade} - NOT PASSING) - ${attemptCount} attempt(s) tracked`, 'warning');
                continue;
              }
              
              // Course passed - select it (which will also add badges)
              if (!selected.includes(match.code)) {
                select(match.code, bestAttempt.grade, attemptCount); // Pass attempt count
                matched++;
                addDebugLog(`âœ… ${bestAttempt.code} â†’ ${match.code} (Grade: ${bestAttempt.grade}, Attempts: ${attemptCount})`, 'success');
              }
            } else {
              notMatched++;
              addDebugLog(`âŒ No match: ${bestAttempt.code} - ${bestAttempt.name}`, 'error');
            }
          }

          markNextCourses();
          showSelected();

          addDebugLog(`\nðŸ“ˆ ${matched} matched, ${notMatched} not matched`, 'info');
          
          const uniqueSelected = [...new Set(selected)];
          addDebugLog(`\nðŸ“‹ SELECTED COURSES (${uniqueSelected.length}):`, 'success');
          uniqueSelected.sort().forEach(code => {
            addDebugLog(`   âœ“ ${code}`, 'success');
          });
          
          return { matched, notMatched };
        }

        // Calculate statistics
        function calculateStatistics() {
          // Get unique courses only (in case of duplicates in selected array)
          const uniqueSelected = [...new Set(selected)];
          
          addDebugLog(`\nðŸ’¯ CALCULATING STATISTICS FOR ${uniqueSelected.length} UNIQUE COURSES:`, 'info');
          
          let totalCredits = 0;
          let completedCount = 0; // Only count courses that exist in the current program
          let skippedCourses = []; // Track courses not found
          
          // Special course tracking
          let specialCourses = {
            TR: false,
            BMA001: false,
            PC401: false,
            PC402: false
          };
          
          let courseBreakdown = [];
          
          uniqueSelected.forEach(code => {
            // ===== CRITICAL VALIDATION: Check if course exists in current program =====
            if (!courses[code]) {
              skippedCourses.push(code);
              addDebugLog(`âš ï¸ WARNING: Course ${code} not found in current program - SKIPPED`, 'error');
              return; // Skip this course
            }
            
            completedCount++; // Only count if course exists
            const hours = courses[code].hours;
            const name = courses[code].name;
            
            // BMA001 has 0 hours, don't count in 135 total
            if (code === 'BMA001') {
              courseBreakdown.push(`   ${code}: ${name} - ${hours}h (NOT counted in 135h total)`);
            } else {
              totalCredits += hours;
              courseBreakdown.push(`   ${code}: ${name} - ${hours}h âœ“`);
            }
            
            // Track special courses
            if (specialCourses.hasOwnProperty(code)) {
              specialCourses[code] = true;
            }
          });
          
          // Log skipped courses summary
          if (skippedCourses.length > 0) {
            addDebugLog(`\nâš ï¸ SKIPPED ${skippedCourses.length} COURSES NOT IN CURRENT PROGRAM:`, 'error');
            addDebugLog(`   ${skippedCourses.join(', ')}`, 'error');
            addDebugLog(`   ðŸ’¡ Tip: Make sure you selected the correct program (IT vs AI) at the top`, 'warning');
          }
          
          // Log detailed breakdown
          addDebugLog(`\nðŸ“Š CREDIT HOURS BREAKDOWN (${completedCount} courses):`, 'info');
          courseBreakdown.forEach(line => addDebugLog(line, 'info'));
          addDebugLog(`\n   TOTAL: ${totalCredits} credit hours`, 'success');

          const percentage = Math.min(Math.round((totalCredits / 135) * 100), 100); // Cap at 100%
          
          // Update UI
          document.getElementById('creditHours').textContent = `${totalCredits}/135`;
          document.getElementById('creditProgress').style.width = `${percentage}%`;
          document.getElementById('creditPercentage').textContent = `${percentage}% Complete`;
          document.getElementById('completedCount').textContent = completedCount;
          
          const totalCourses = Object.keys(courses).length;
          const remaining = totalCourses - completedCount;
          document.getElementById('remainingCount').textContent = `${remaining} Remaining`;

          // Log special course status
          addDebugLog(`\nðŸ“‹ Special Requirements:`, 'info');
          addDebugLog(`   Summer Training (TR): ${specialCourses.TR ? 'âœ… Completed' : 'âŒ Not completed'}`, specialCourses.TR ? 'success' : 'warning');
          addDebugLog(`   Mathematics-0 (BMA001): ${specialCourses.BMA001 ? 'âœ… Completed' : 'âŒ Not completed'} (0h - not counted)`, specialCourses.BMA001 ? 'success' : 'warning');
          addDebugLog(`   Project 1 (PC401): ${specialCourses.PC401 ? 'âœ… Completed' : 'âŒ Not completed'}`, specialCourses.PC401 ? 'success' : 'warning');
          addDebugLog(`   Project 2 (PC402): ${specialCourses.PC402 ? 'âœ… Completed' : 'âŒ Not completed'}`, specialCourses.PC402 ? 'success' : 'warning');
          
          addDebugLog(`\nðŸ’¯ FINAL TOTAL: ${totalCredits}/135 credit hours (${percentage}%)`, totalCredits >= 135 ? 'success' : 'info');

          return { totalCredits, completedCount, percentage };
        }

        // Show remaining courses
        function showRemainingCourses() {
          const courseListEl = document.getElementById('courseList');
          courseListEl.innerHTML = '';

          // Get unique selected courses
          const uniqueSelected = [...new Set(selected)];
          const remaining = [];
          
          for (const [code, course] of Object.entries(courses)) {
            if (!uniqueSelected.includes(code)) {
              const prereqsMet = course.prerequisites.every(prereq => uniqueSelected.includes(prereq));
              // Get attempt count from courseAttempts if it exists
              const attempts = courseAttempts[code] || 0;
              remaining.push({ code, course, prereqsMet, attempts });
            }
          }

          remaining.sort((a, b) => {
            if (a.prereqsMet !== b.prereqsMet) return b.prereqsMet ? 1 : -1;
            return a.course.semester - b.course.semester;
          });

          remaining.forEach(({ code, course, prereqsMet, attempts }) => {
            const item = document.createElement('div');
            item.className = `course-item ${prereqsMet ? 'available' : 'locked'}`;
            // Make draggable for study plan
            item.draggable = true;
            item.dataset.courseCode = code;
            item.addEventListener('dragstart', function(e) {
              draggedElement = e.target;
              draggedCourseCode = code;
              draggedFromSemester = -1;
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', code);
              e.target.style.opacity = '0.6';
            });
            item.addEventListener('dragend', function(e) {
              e.target.style.opacity = '';
              draggedCourseCode = null;
              draggedFromSemester = null;
              draggedElement = null;
            });
            
            // Build the course info HTML
            let attemptBadge = '';
            if (attempts > 0) {
              attemptBadge = `<span class="course-attempts-badge" style="background-color: #dc2626; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px; font-weight: bold;">Ã—${attempts} attempt${attempts > 1 ? 's' : ''}</span>`;
            }
            
            item.innerHTML = `
              <div>
                <span class="course-item-name">${course.name}</span>
                <span class="course-item-code">(${code})</span>
                ${attemptBadge}
              </div>
              <span class="course-item-hours">${course.hours}h</span>
            `;
            courseListEl.appendChild(item);
          });
        }

        // ============ STUDY PLAN GENERATOR ============
        
        let generatedPlans = [];
        let currentPlanIndex = 0;

        // ============ ACADEMIC RULE ENGINE ============

        // Convert course's semester number (1-8) to semester type (1 or 2)
        // Semester 1,3,5,7 â†’ Type 1 (can be taken in student terms 1,3,5,7)
        // Semester 2,4,6,8 â†’ Type 2 (can be taken in student terms 2,4,6,8)
        function getSemesterType(courseSemester) {
          return (courseSemester % 2 === 1) ? 1 : 2;
        }

        // Detect student's current term from transcript
        // MODIFIED LOGIC:
        // 1. Find last registered semester (highest semester with registered courses)
        // 2. Check if that semester has grades:
        //    - If YES â†’ start plan from NEXT semester
        //    - If NO â†’ ignore that registration, start from previous completed semester + 1
        function detectCurrentTerm(pdfCourses) {
          let currentTerm = {
            termNumber: null,
            registeredCourses: [],
            isDetected: false,
            hasGrades: false
          };
          
          // Separate courses into completed and registered
          // c.grade holds Ø§Ù„ØªÙ‚Ø¯ÙŠØ± (letter grade like D, F, Fr, etc.)
          // It is NEVER '0' â€” '0' is Ø§Ù„Ù†Ù‚Ø§Ø· (points), not Ø§Ù„ØªÙ‚Ø¯ÙŠØ±
          const coursesWithGrades = pdfCourses.filter(c => 
            c.grade && c.grade.trim() !== ''
          );
          
          const coursesWithoutGrades = pdfCourses.filter(c => 
            !c.grade || c.grade.trim() === ''
          );
          
          // Deduplication guard: pattern3 (no-grade pattern) can produce false positives
          // for courses like IT438 (grade=F, points=0) because "F 0 100 3 name IT438"
          // contains "0 100 3 name IT438" which pattern3 also matches.
          // Solution: discard any "no-grade" entry whose code also appears WITH a grade.
          const codesWithGrades = new Set(
            coursesWithGrades.map(c => c.code.replace(/\s+/g, ''))
          );
          const trulyUngraded = coursesWithoutGrades.filter(c => {
            const norm = c.code.replace(/\s+/g, '');
            return !codesWithGrades.has(norm);
          });
          
          // Find the highest semester number from registered courses (without grades)
          let lastRegisteredSemester = 0;
          const lastRegisteredCourses = [];
          
          if (trulyUngraded.length > 0) {
            addDebugLog(`ðŸ“‹ Found ${trulyUngraded.length} registered courses (no grades):`, 'info');
            
            trulyUngraded.forEach(pdfCourse => {
              const match = matchCourse(pdfCourse.name, pdfCourse.code);
              if (match && courses[match.code]) {
                // BMA001 (Mathematics-0) has no real semester, exclude it from comparisons
                if (match.code === 'BMA001') return;
                
                const semesterNum = courses[match.code].semester;
                addDebugLog(`   ðŸ“Œ ${match.code} (Sem ${semesterNum}) - ${pdfCourse.name}`, 'info');
                
                if (semesterNum > lastRegisteredSemester) {
                  lastRegisteredSemester = semesterNum;
                  lastRegisteredCourses.length = 0;
                  lastRegisteredCourses.push(pdfCourse);
                } else if (semesterNum === lastRegisteredSemester) {
                  lastRegisteredCourses.push(pdfCourse);
                }
              }
            });
            
            if (lastRegisteredSemester > 0) {
              addDebugLog(`\nðŸ” Last Registered Semester: ${lastRegisteredSemester}`, 'warning');
              addDebugLog(`   Courses in this semester: ${lastRegisteredCourses.length}`, 'info');
              
              // Check if ANY course in this semester has a grade
              let semesterHasGrades = false;
              lastRegisteredCourses.forEach(c => {
                if (c.grade && c.grade.trim() !== '') {
                  semesterHasGrades = true;
                }
              });
              
              if (semesterHasGrades) {
                // Last registered semester HAS grades â†’ start from NEXT semester
                addDebugLog(`   âœ… Last registered semester HAS grades`, 'success');
                addDebugLog(`   â†’ Plan will start from Semester ${lastRegisteredSemester + 1}`, 'success');
                
                currentTerm.termNumber = lastRegisteredSemester + 1;
                currentTerm.hasGrades = true;
              } else {
                // Last registered semester has NO grades â†’ Plan should start FROM this semester
                // Treat these registered courses as remaining courses (not completed)
                addDebugLog(`   âš ï¸ Last registered semester has NO grades - TREATING AS CURRENT SEMESTER`, 'warning');
                addDebugLog(`   â†’ Registered courses will be treated as REMAINING (not completed)`, 'info');
                addDebugLog(`   â†’ Plan will start FROM Semester ${lastRegisteredSemester} (CURRENT SEMESTER)`, 'success');
                
                // Set the plan to start FROM the current registered semester
                // This way, the registered courses (which weren't marked as completed) 
                // will be included in the study plan
                currentTerm.termNumber = lastRegisteredSemester;
                currentTerm.hasGrades = false;
              }
              
              currentTerm.registeredCourses = lastRegisteredCourses;
              currentTerm.isDetected = true;
            }
          } else {
            // No courses without grades - student has completed all courses in transcript
            // Need to determine what semester they just finished
            
            // Get all courses with grades
            const completedCourses = pdfCourses.filter(c => 
              c.grade && c.grade.trim() !== ''
            );
            
            // Match them to our course database and find their semester types
            const semesterNumbers = [];
            
            completedCourses.forEach(pdfCourse => {
              const match = matchCourse(pdfCourse.name, pdfCourse.code);
              if (match && courses[match.code]) {
                // BMA001 (Mathematics-0) has no real semester, exclude it
                if (match.code === 'BMA001') return;
                semesterNumbers.push(courses[match.code].semester);
              }
            });
            
            if (semesterNumbers.length > 0) {
              // Find the most recent semester completed
              const maxSemester = Math.max(...semesterNumbers);
              
              // Determine what the NEXT term should be
              // If they finished semester 1 â†’ next is semester 2 (term 2)
              // If they finished semester 2 â†’ next is semester 3 (term 3)
              // etc.
              const nextSemester = maxSemester + 1;
              
              // Convert next semester to term number
              // Semester 1 â†’ Term 1, Semester 2 â†’ Term 2, etc.
              currentTerm.termNumber = nextSemester;
              
              if (currentTerm.termNumber > 8) {
                currentTerm.termNumber = 8; // Cap at term 8
              }
              
              currentTerm.isDetected = true;
              
              const passedCourses = pdfCourses.filter(c => 
                c.grade && isPassingGrade(c.grade)
              ).length;
              
              addDebugLog(`ðŸŽ¯ Last completed semester: ${maxSemester}, Next term: ${currentTerm.termNumber} (${passedCourses} passed courses)`, 'success');
            } else {
              // Fallback: estimate based on passed courses count
              const passedCourses = pdfCourses.filter(c => 
                c.grade && c.grade.trim() !== '' && isPassingGrade(c.grade)
              ).length;
              
              let estimatedYear = Math.ceil(passedCourses / 14);
              if (estimatedYear < 1) estimatedYear = 1;
              if (estimatedYear > 4) estimatedYear = 4;
              
              // Start from next term
              const baseTermForYear = (estimatedYear - 1) * 2;
              currentTerm.termNumber = baseTermForYear + 1; // Start from odd term of current year
              currentTerm.isDetected = true;
              
              addDebugLog(`ðŸŽ¯ No current registration, estimated next term: ${currentTerm.termNumber} (${passedCourses} passed courses)`, 'info');
            }
          }
          
          return currentTerm;
        }

        // Validate current term registration
        function validateCurrentRegistration(currentTerm, completedCourses) {
          const violations = [];
          
          if (!currentTerm.isDetected) return { isValid: true, violations: [] };
          
          const termType = (currentTerm.termNumber % 2 === 1) ? 1 : 2;
          
          currentTerm.registeredCourses.forEach(pdfCourse => {
            const match = matchCourse(pdfCourse.name, pdfCourse.code);
            if (!match) return;
            
            const course = courses[match.code];
            if (!course) return;
            
            // Check 1: Semester type matching
            const courseSemesterType = getSemesterType(course.semester);
            if (courseSemesterType !== termType) {
              violations.push({
                code: match.code,
                reason: `Wrong term type - ${match.code} is semester ${courseSemesterType} course, but registered in term ${currentTerm.termNumber} (type ${termType})`
              });
            }
            
            // Check 2: Prerequisites
            const unmetPrereqs = course.prerequisites.filter(prereq => !completedCourses.includes(prereq));
            if (unmetPrereqs.length > 0) {
              violations.push({
                code: match.code,
                reason: `Missing prerequisites: ${unmetPrereqs.join(', ')}`
              });
            }
          });
          
          return {
            isValid: violations.length === 0,
            violations: violations
          };
        }

        // Get available courses (prerequisites met)
        function getAvailableCourses(completedCourses, remainingCourses) {
          // Calculate current credit hours
          const currentHours = completedCourses.reduce((sum, code) => {
            // Don't count BMA001 (Math-0) toward credit hours
            if (code === 'BMA001') return sum;
            return sum + (courses[code]?.hours || 0);
          }, 0);

          return remainingCourses.filter(code => {
            const course = courses[code];
            
            // Check regular prerequisites
            const prereqsMet = course.prerequisites.every(prereq => completedCourses.includes(prereq));
            if (!prereqsMet) return false;
            
            // Special rule: TR (Summer Training) requires 60+ credit hours
            if (code === 'TR' && currentHours < 60) {
              return false;
            }
            
            // Special rule: PC401 (Project 1) requires 85+ credit hours
            if (code === 'PC401' && currentHours < 85) {
              return false;
            }
            
            return true;
          });
        }

        // Generate a study plan
        function generateStudyPlan(strategy = 'balanced', startTerm = 3) {
          const uniqueSelected = [...new Set(selected)];
          const remaining = Object.keys(courses).filter(code => {
            // Exclude completed courses and special courses
            if (uniqueSelected.includes(code)) return false;
            if (code === 'BMA001') return false; // Math-0 doesn't count
            return true;
          });

          const plan = [];
          let completed = [...uniqueSelected];
          let toSchedule = [...remaining];
          
          // Calculate current credit hours
          const calculateHours = (courseList) => {
            return courseList.reduce((sum, code) => {
              if (code === 'BMA001') return sum;
              return sum + (courses[code]?.hours || 0);
            }, 0);
          };
          
          let currentHours = calculateHours(completed);
          
          // Start from detected or provided term
          let currentTermNumber = startTerm;
          let semesterCount = 0;
          const maxSemesters = 12; // Safety limit

          // ==========================================
          // CALCULATE BASE YEAR FROM CURRENT DATE
          // ==========================================
          const now = new Date();
          const currentCalendarYear = now.getFullYear(); // e.g., 2026
          const currentMonth = now.getMonth() + 1; // e.g., 2 for February
          
          // Current academic year (Sep-Aug cycle)
          // If month >= 9 (Sep-Dec), use current year as base
          // If month < 9 (Jan-Aug), use previous year as base
          const currentAcademicYear = (currentMonth >= 9) ? currentCalendarYear : currentCalendarYear - 1;
          
          // Calculate which "year of study" the startTerm is in (0-indexed)
          // Terms 1-2 = year 0, Terms 3-4 = year 1, Terms 5-6 = year 2, etc.
          const startTermYearIndex = Math.floor((startTerm - 1) / 2);
          
          // Calculate base year for terms 1-2 (year 0)
          // If we're starting at term 6 (year index 2) in Feb 2026 (academic year 2025-2026)
          // then term 1-2 would have been in 2023-2024
          const term1BaseYear = currentAcademicYear - startTermYearIndex;
          
          addDebugLog(`\nðŸ“… DATE-BASED YEAR CALCULATION:`, 'info');
          addDebugLog(`   Current date: ${now.toLocaleDateString()}`, 'info');
          addDebugLog(`   Current academic year: ${currentAcademicYear}-${currentAcademicYear + 1}`, 'info');
          addDebugLog(`   Starting from term ${startTerm} (year index ${startTermYearIndex})`, 'info');
          addDebugLog(`   Calculated base year for terms 1-2: ${term1BaseYear}-${term1BaseYear + 1}`, 'info');

          addDebugLog(`\nðŸŽ¯ Planning starts from Term ${currentTermNumber} (${toSchedule.length} courses remaining, ${currentHours}h completed)`, 'info');
          
          // Log what courses need to be scheduled
          const failedCourses = toSchedule.filter(code => {
            return completed.includes(code) === false && 
                   Object.keys(courses).includes(code);
          });
          
          addDebugLog(`ðŸ“ Courses to schedule: ${toSchedule.join(', ')}`, 'info');

          while (toSchedule.length > 0 && semesterCount < maxSemesters) {
            // Determine term type (1 = odd/First, 2 = even/Second)
            const termType = (currentTermNumber % 2 === 1) ? 1 : 2;
            
            addDebugLog(`\n--- Planning Term ${currentTermNumber} (Type ${termType}) ---`, 'info');
            
            // Calculate remaining hours
            const remainingHours = calculateHours(toSchedule);
            addDebugLog(`   Remaining to schedule: ${toSchedule.length} courses, ${remainingHours} hours`, 'info');
            
            // Determine semester limits
            let maxHours = 18; // Default max
            let minHours = 9;
            
            // FILTER: Get courses available for this term
            let available = toSchedule.filter(code => {
              const course = courses[code];
              if (!course) {
                addDebugLog(`   âŒ ${code}: Course not found in database`, 'error');
                return false;
              }
              
              // Rule 1: Semester type must match term type
              const courseSemesterType = getSemesterType(course.semester);
              if (courseSemesterType !== termType) {
                addDebugLog(`   â­ï¸ ${code} (Sem ${course.semester}): Wrong type (need type ${termType}, has type ${courseSemesterType})`, 'info');
                return false;
              }
              
              // Rule 2: Prerequisites must be met
              const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
              if (!prereqsMet) {
                const missing = course.prerequisites.filter(p => !completed.includes(p));
                addDebugLog(`   â­ï¸ ${code}: Missing prerequisites: ${missing.join(', ')}`, 'info');
                return false;
              }
              
              // Rule 3: TR requires 60+ hours (but TR can only be in summer, so skip in normal terms)
              if (code === 'TR') {
                addDebugLog(`   â­ï¸ TR: Can only be taken in summer`, 'info');
                return false;
              }
              
              // Rule 4: PC401 requires 85+ hours
              if (code === 'PC401' && currentHours < 85) {
                addDebugLog(`   â­ï¸ PC401: Not enough hours (${currentHours}/85)`, 'info');
                return false;
              }
              
              addDebugLog(`   âœ… ${code} (Sem ${course.semester}): Available`, 'success');
              return true;
            });
            
            addDebugLog(`   â†’ ${available.length} courses available for this term`, 'info');
            
            // PRIORITIZE: Smart dependency management + fill to max
            available = available.map(code => {
              const unlocks = Object.keys(courses).filter(c => 
                courses[c].prerequisites.includes(code) && toSchedule.includes(c)
              ).length;
              
              // SPECIAL PRIORITY: Projects get highest priority when eligible
              let priority = unlocks;
              if (code === 'PC401' && currentHours >= 85) {
                priority = 1000;
              } else if (code === 'PC402' && completed.includes('PC401')) {
                priority = 999;
              }
              
              return { code, unlocks, priority, hours: courses[code].hours };
            });
            
            // Sort by priority first, then by hours (to fill to max)
            available.sort((a, b) => {
              if (b.priority !== a.priority) return b.priority - a.priority;
              return b.hours - a.hours;
            });
            
            const availableCodes = available.map(item => item.code);
            if (availableCodes.includes('PC401')) {
              addDebugLog(`   ðŸŽ¯ PC401 prioritized (current hours: ${currentHours})`, 'success');
            }
            if (availableCodes.includes('PC402')) {
              addDebugLog(`   ðŸŽ¯ PC402 prioritized`, 'success');
            }
            
            available = available.map(item => item.code);
            
            // SELECT: Fill semester to max hours (18 or special limits)
            const termCourses = [];
            let termHours = 0;
            
            for (const code of available) {
              const courseHours = courses[code].hours;
              if (termHours + courseHours <= maxHours) {
                termCourses.push(code);
                termHours += courseHours;
              }
            }
            
            // If no courses can be added, break
            if (termCourses.length === 0) {
              addDebugLog(`   âš ï¸ No courses available to schedule`, 'warning');
              break;
            }
            
            // Add term to plan
            // Calculate year based on the term number and base year
            const termYearIndex = Math.floor((currentTermNumber - 1) / 2);
            const year = term1BaseYear + termYearIndex;
            const termName = termType === 1 ? 'First' : 'Second';
            
            plan.push({
              name: `${termName} Term ${year}-${year + 1}`,
              courses: termCourses,
              hours: termHours,
              isSummer: false,
              isSpecialCase: false
            });
            
            // Mark courses as completed
            completed.push(...termCourses);
            toSchedule = toSchedule.filter(code => !termCourses.includes(code));
            currentHours = calculateHours(completed);
            
            addDebugLog(`   âœ… Added ${termCourses.length} courses (${termHours}h). Total hours: ${currentHours}`, 'success');
            
            // ==========================================
            // POST-SEMESTER CHECKS (IN SEQUENCE)
            // ==========================================
            
            // CHECK 1: TR SUMMER (after even semesters with 60+ hours)
            if (termType === 2 && toSchedule.includes('TR') && currentHours >= 60) {
              addDebugLog(`\n   ðŸŒž CHECK 1: TR CONDITION MET`, 'success');
              addDebugLog(`      â†’ Current semester is EVEN (Second Term)`, 'info');
              addDebugLog(`      â†’ Gained hours: ${currentHours} >= 60`, 'info');
              addDebugLog(`      â†’ TR not added yet`, 'info');
              addDebugLog(`      â†’ AUTO-ADDING TR Summer`, 'success');
              
              const trPrereqsMet = courses['TR'].prerequisites.every(prereq => completed.includes(prereq));
              if (trPrereqsMet) {
                plan.push({
                  name: `Summer Term ${year}-${year + 1}`,
                  courses: ['TR'],
                  hours: 2,
                  isSummer: true,
                  isSpecialCase: false
                });
                
                completed.push('TR');
                toSchedule = toSchedule.filter(code => code !== 'TR');
                currentHours = calculateHours(completed);
                
                addDebugLog(`      âœ… Added TR summer. Total hours: ${currentHours}`, 'success');
              }
            }
            
            // Recalculate remaining after potential TR addition
            const newRemainingHours = calculateHours(toSchedule);
            
            // CHECK 3: SPECIAL SUMMER (after even, â‰¤12 hours remaining - REGARDLESS of type mix)
            // This check must come BEFORE CHECK 2 because it's more specific
            if (termType === 2 && newRemainingHours > 0 && newRemainingHours <= 12 && toSchedule.length > 0) {
              // After even semester with â‰¤12h remaining, always use summer special case
              addDebugLog(`\n   â­ CHECK 3: SPECIAL SUMMER CASE`, 'success');
              addDebugLog(`      â†’ Current semester is EVEN (Second Term)`, 'info');
              addDebugLog(`      â†’ Next would be ODD (First Term)`, 'info');
              addDebugLog(`      â†’ Remaining hours: ${newRemainingHours} (0 < hours <= 12)`, 'info');
              addDebugLog(`      â†’ Adding special summer with NO semester restrictions`, 'success');
              
              // Filter courses (can take ANY semester type, except PC401/PC402)
              const summerCourses = toSchedule.filter(code => {
                const course = courses[code];
                if (!course) return false;
                
                // Check prerequisites
                const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                if (!prereqsMet) return false;
                
                // TR special requirement
                if (code === 'TR' && currentHours < 60) return false;
                
                // PC401 and PC402 CANNOT be in summer
                if (code === 'PC401' || code === 'PC402') {
                  addDebugLog(`      â­ï¸ ${code}: Cannot be taken in summer (projects restricted)`, 'warning');
                  return false;
                }
                
                return true;
              });
                
              if (summerCourses.length > 0) {
                let summerHours = 0;
                const selectedSummer = [];
                
                // Prioritize and fill to max 12 hours
                const prioritizedSummer = summerCourses.map(code => {
                  const unlocks = Object.keys(courses).filter(c => 
                    courses[c].prerequisites.includes(code) && toSchedule.includes(c)
                  ).length;
                  return { code, unlocks, hours: courses[code].hours };
                }).sort((a, b) => {
                  if (b.unlocks !== a.unlocks) return b.unlocks - a.unlocks;
                  return b.hours - a.hours;
                });
                
                for (const item of prioritizedSummer) {
                  const hours = item.hours;
                  if (summerHours + hours <= 12) {
                    selectedSummer.push(item.code);
                    summerHours += hours;
                  }
                }
                
                if (selectedSummer.length > 0) {
                  plan.push({
                    name: `Summer Term Special Case`,
                    courses: selectedSummer,
                    hours: summerHours,
                    isSummer: true,
                    isSpecialCase: true
                  });
                  
                  completed.push(...selectedSummer);
                  toSchedule = toSchedule.filter(code => !selectedSummer.includes(code));
                  currentHours = calculateHours(completed);
                  
                  addDebugLog(`      âœ… Added special summer: ${selectedSummer.length} courses, ${summerHours}h`, 'success');
                  addDebugLog(`      â†’ Courses: ${selectedSummer.join(', ')}`, 'info');
                }
              }
            }
            
            // Recalculate remaining again after potential summer addition
            const finalRemainingHours = calculateHours(toSchedule);
            
            // CHECK 2: SPECIAL CASE 21-HOUR SEMESTER (same semester type, 0-21 hours)
            // This check comes AFTER CHECK 3 (more general fallback)
            if (finalRemainingHours > 0 && finalRemainingHours <= 21 && toSchedule.length > 0) {
              // Check if all remaining courses are from same semester type
              const remainingSemesterTypes = toSchedule.map(code => {
                const course = courses[code];
                return course ? getSemesterType(course.semester) : null;
              }).filter(t => t !== null);
              
              const allType1 = remainingSemesterTypes.every(t => t === 1);
              const allType2 = remainingSemesterTypes.every(t => t === 2);
              
              if (allType1 || allType2) {
                const sameSemesterType = allType1 ? 1 : 2;
                addDebugLog(`\n   â­ CHECK 2: SPECIAL CASE 21-HOUR SEMESTER`, 'success');
                addDebugLog(`      â†’ Remaining hours: ${finalRemainingHours} (0 < hours <= 21)`, 'info');
                addDebugLog(`      â†’ All courses are from ${allType1 ? 'ODD (First)' : 'EVEN (Second)'} semesters`, 'info');
                addDebugLog(`      â†’ Adding all as special 21-hour semester`, 'success');
                
                // Filter courses that meet prerequisites
                const finalCourses = toSchedule.filter(code => {
                  const course = courses[code];
                  if (!course) return false;
                  if (code === 'TR') return false; // TR only in summer
                  
                  const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                  if (!prereqsMet) return false;
                  
                  if (code === 'PC401' && currentHours < 85) return false;
                  
                  return true;
                });
                
                if (finalCourses.length > 0) {
                  const finalHours = calculateHours(finalCourses);
                  const nextTermNumber = currentTermNumber + 1;
                  const nextTermType = (nextTermNumber % 2 === 1) ? 1 : 2;
                  const nextTermYearIndex = Math.floor((nextTermNumber - 1) / 2);
                  const nextYear = term1BaseYear + nextTermYearIndex;
                  const nextTermName = nextTermType === 1 ? 'First' : 'Second';
                  
                  plan.push({
                    name: `${nextTermName} Term ${nextYear}-${nextYear + 1}`,
                    courses: finalCourses,
                    hours: finalHours,
                    isSummer: false,
                    isSpecialCase: true
                  });
                  
                  completed.push(...finalCourses);
                  toSchedule = toSchedule.filter(code => !finalCourses.includes(code));
                  currentHours = calculateHours(completed);
                  
                  addDebugLog(`      âœ… Added special 21-hour semester: ${finalCourses.length} courses, ${finalHours}h`, 'success');
                }
              }
            }
            
            // Move to next term
            currentTermNumber++;
            if (currentTermNumber > 12) {
              addDebugLog(`âš ï¸ Reached maximum term (12), stopping`, 'warning');
              break;
            }
            
            semesterCount++;
          }
          
          // Add warning if not all courses could be scheduled
          if (toSchedule.length > 0) {
            addDebugLog(`\nâš ï¸ Warning: ${toSchedule.length} courses could not be scheduled:`, 'warning');
            toSchedule.forEach(code => {
              addDebugLog(`   - ${code}: ${courses[code]?.name}`, 'warning');
            });
          }
          
          return plan;
        }

        // Display study plan with drag-and-drop
        function displayStudyPlan(planIndex) {
          const plan = generatedPlans[planIndex];
          if (!plan) return;

          // Calculate initial completed hours (before the plan starts)
          const initialCompletedHours = selected.reduce((sum, code) => {
            if (code === 'BMA001') return sum;
            return sum + (courses[code]?.hours || 0);
          }, 0);

          const displayDiv = document.getElementById('studyPlanDisplay');
          displayDiv.innerHTML = '';

          // Add action buttons at top
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'semester-actions';
          actionsDiv.innerHTML = `
            <button class="reset-plan-btn" id="resetPlanBtn">
              ðŸ”„ Reset Plan
            </button>
            <button class="export-btn" id="exportTextBtn">
              ðŸ“„ Export as Text
            </button>
            <button class="export-btn xlsx" id="exportXlsxBtn">
              ðŸ“Š Export as XLSX
            </button>
            <button class="export-btn pdf-btn" id="exportPdfBtn">
              ðŸ–¨ï¸ Export as PDF
            </button>
            <div id="validationMessage"></div>
          `;
          displayDiv.appendChild(actionsDiv);

          plan.semesters.forEach((semester, semesterIndex) => {
            const semesterCard = document.createElement('div');
            semesterCard.className = `semester-card ${semester.isSummer ? 'summer-semester' : ''} ${semester.isSpecialCase ? 'special-case-active' : ''}`;
            semesterCard.dataset.semesterIndex = semesterIndex;

            // Calculate gained hours up to this semester (including initial completed hours)
            let gainedHours = initialCompletedHours;
            for (let i = 0; i <= semesterIndex; i++) {
              gainedHours += plan.semesters[i].hours;
            }
            
            // Calculate remaining hours
            const totalRequiredHours = 135;
            const remainingHours = totalRequiredHours - gainedHours;
            
            // Count number of courses in this semester
            const courseCount = semester.courses.length;

            // Special case star toggle
            const maxHoursLabel = semester.isSummer
              ? (semester.isSpecialCase ? '12h max' : '9h max')
              : (semester.isSpecialCase ? '21h max' : '18h max');
            const starToggleHTML = `
              <button class="special-case-toggle ${semester.isSpecialCase ? 'active' : ''}" 
                      data-semester-index="${semesterIndex}" 
                      title="${semester.isSpecialCase ? 'Remove special case' : 'Mark as special case (increases hour limit)'}">
                ${semester.isSpecialCase ? 'â­ Special Case' : 'â˜†'}
              </button>`;
            
            const semesterHeader = document.createElement('div');
            semesterHeader.className = 'semester-header';
            semesterHeader.innerHTML = `
              <span class="semester-title">${semester.name}</span>
              <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                ${starToggleHTML}
                <span class="semester-hours" id="hours-${semesterIndex}">${semester.hours}h (${courseCount} courses) (${maxHoursLabel.toUpperCase()})</span>
                ${semester.isSummer ? '<button class="delete-semester-btn" data-semester="' + semesterIndex + '">âŒ Delete</button>' : ''}
              </div>
            `;

            const coursesDiv = document.createElement('div');
            coursesDiv.className = 'semester-courses';
            coursesDiv.dataset.semesterIndex = semesterIndex;

            // Add placeholder if empty
            if (semester.courses.length === 0) {
              coursesDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">Drop courses here</div>';
            }

            // Make drop zone
            coursesDiv.addEventListener('dragover', handleDragOver);
            coursesDiv.addEventListener('drop', handleDrop);
            coursesDiv.addEventListener('dragleave', handleDragLeave);

            semester.courses.forEach((code, courseIndex) => {
              const course = courses[code];
              if (!course) return;
              
              const courseItem = document.createElement('div');
              courseItem.className = 'semester-course-item';
              courseItem.draggable = true;
              courseItem.dataset.courseCode = code;
              courseItem.dataset.semesterIndex = semesterIndex;
              courseItem.dataset.courseIndex = courseIndex;
              
              courseItem.innerHTML = `
                <span class="course-drag-handle">â‹®â‹®</span>
                <span class="semester-course-code">${code}</span>
                <span style="flex:1;">${course.name} (${course.hours}h)</span>
                <button class="course-remove-btn" data-code="${code}" data-semester="${semesterIndex}" title="Remove course (cascades dependents)">âœ•</button>
              `;

              // Drag events
              courseItem.addEventListener('dragstart', handleDragStart);
              courseItem.addEventListener('dragend', handleDragEnd);

              // Remove button
              courseItem.querySelector('.course-remove-btn').addEventListener('click', function(e) {
                e.stopPropagation();
                const code = this.dataset.code;
                const semIdx = parseInt(this.dataset.semester);
                removeCourseFromPlan(code, semIdx);
              });

              coursesDiv.appendChild(courseItem);
            });

            semesterCard.appendChild(semesterHeader);
            semesterCard.appendChild(coursesDiv);

            // Gained/Remaining footer at bottom of card
            const cardFooter = document.createElement('div');
            cardFooter.className = 'semester-footer';
            cardFooter.id = `footer-${semesterIndex}`;
            cardFooter.innerHTML = `
              <span class="footer-gained">ðŸ“ˆ Gained: <strong>${gainedHours}h</strong></span>
              <span class="footer-sep">|</span>
              <span class="footer-remaining">ðŸŽ¯ Remaining: <strong>${remainingHours}h</strong></span>
            `;
            semesterCard.appendChild(cardFooter);
            
            // Add "Add Summer After This Semester" button ONLY after Second semesters (Spring)
            // Summer comes after spring, not after fall
            const isSecondSemester = semester.name.includes('Second Term') || semester.isSummer;
            
            if (isSecondSemester || semesterIndex === plan.semesters.length - 1) {
              // Show after second semesters or after the last semester (for flexibility)
              const addSummerDiv = document.createElement('div');
              addSummerDiv.style.textAlign = 'center';
              addSummerDiv.style.margin = '8px 0';
              addSummerDiv.innerHTML = `
                <button class="add-summer-after-btn" data-after-index="${semesterIndex}">
                  â˜€ï¸ Add Summer After This
                </button>
              `;
              semesterCard.appendChild(addSummerDiv);
            }
            
            displayDiv.appendChild(semesterCard);
          });

          // Add summary
          updatePlanSummary(plan);

          // Add event listeners for action buttons
          document.getElementById('resetPlanBtn').addEventListener('click', resetPlan);
          document.getElementById('exportTextBtn').addEventListener('click', () => exportAsText(planIndex));
          document.getElementById('exportXlsxBtn').addEventListener('click', () => exportAsXlsx(planIndex));
          document.getElementById('exportPdfBtn').addEventListener('click', () => exportStudyPlanAsPDF());
          
          // Delete semester buttons
          document.querySelectorAll('.delete-semester-btn').forEach(btn => {
            btn.addEventListener('click', function() {
              const semIndex = parseInt(this.dataset.semester);
              deleteSemester(semIndex);
            });
          });

          // Add summer after buttons
          document.querySelectorAll('.add-summer-after-btn').forEach(btn => {
            btn.addEventListener('click', function() {
              const afterIndex = parseInt(this.dataset.afterIndex);
              addSummerSemesterAfter(afterIndex);
            });
          });

          // Special case star toggle buttons
          document.querySelectorAll('.special-case-toggle').forEach(btn => {
            btn.addEventListener('click', function() {
              const semIdx = parseInt(this.dataset.semesterIndex);
              toggleSpecialCase(semIdx);
            });
          });
          
          // Auto-scroll to show the generated plan
          autoScrollToStudyPlan();
        }

        // Update plan summary
        function updatePlanSummary(plan) {
          const displayDiv = document.getElementById('studyPlanDisplay');
          
          // Remove old summary if exists
          const oldSummary = displayDiv.querySelector('.plan-summary');
          if (oldSummary) oldSummary.remove();

          const totalHours = plan.semesters.reduce((sum, sem) => sum + sem.hours, 0);
          const totalSemesters = plan.semesters.length;
          const normalSemesters = plan.semesters.filter(s => !s.isSummer).length;
          const summerSemesters = plan.semesters.filter(s => s.isSummer).length;

          const summary = document.createElement('div');
          summary.className = 'plan-summary';
          summary.innerHTML = `
            <div class="plan-summary-title">ðŸ“Š Plan Summary</div>
            <div class="plan-summary-stats">
              <div><strong>Total Hours:</strong> ${totalHours}h</div>
              <div><strong>Total Semesters:</strong> ${totalSemesters}</div>
              <div><strong>Normal Semesters:</strong> ${normalSemesters}</div>
              <div><strong>Summer Semesters:</strong> ${summerSemesters}</div>
            </div>
          `;
          displayDiv.appendChild(summary);
        }

        // Export as Text
        function exportAsText(planIndex) {
          const plan = generatedPlans[planIndex];
          if (!plan) return;

          let textContent = `Study Plan - ${plan.name}\n`;
          textContent += `=${'='.repeat(60)}\n\n`;
          
          // Student info
          if (studentInfo) {
            textContent += `Student: ${studentInfo.name || 'N/A'}\n`;
            textContent += `ID: ${studentInfo.id || 'N/A'}\n`;
            textContent += `Level: ${studentInfo.level || 'N/A'}\n`;
          }
          
          const totalHours = plan.semesters.reduce((sum, sem) => sum + sem.hours, 0);
          const completedHours = selected.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
          const remainingHours = 135 - completedHours;
          
          textContent += `Total Credits: ${completedHours}/135\n`;
          textContent += `GPA: ${studentInfo?.gpa || '0.00'}\n`;
          textContent += `Generated: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}\n`;
          textContent += `\n${'-'.repeat(60)}\n\n`;

          plan.semesters.forEach((semester, index) => {
            // Calculate gained hours up to this semester (including initial completed hours)
            let gainedHours = completedHours;
            for (let i = 0; i <= index; i++) {
              gainedHours += plan.semesters[i].hours;
            }
            
            // Calculate remaining hours
            const remainingHours = 135 - gainedHours;
            const courseCount = semester.courses.length;
            
            const specialCase = semester.isSpecialCase ? ' â­ Special Case' : '';
            textContent += `${semester.name} - ${semester.hours} hours (${courseCount} courses)${specialCase}\n`;
            textContent += `Gained: ${gainedHours}h | Remaining: ${remainingHours}h\n`;
            textContent += `${'-'.repeat(60)}\n`;
            
            semester.courses.forEach(code => {
              const course = courses[code];
              if (course) {
                textContent += `  ${code.padEnd(10)} ${course.name.padEnd(45)} ${course.hours}h\n`;
              }
            });
            textContent += `\n`;
          });

          textContent += `${'-'.repeat(60)}\n`;
          textContent += `TOTAL: ${totalHours}h | ${plan.semesters.length} Semesters\n`;
          textContent += `${'-'.repeat(60)}\n`;
          textContent += `\nStudy Plan generated by Course Planning System\n`;
          textContent += `This plan is subject to course availability and prerequisite validation\n`;

          // Download
          const blob = new Blob([textContent], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Study_Plan_${plan.name.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.txt`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Export as XLSX
        function exportAsXlsx(planIndex) {
          const plan = generatedPlans[planIndex];
          if (!plan) return;

          // Create workbook
          const wb = XLSX.utils.book_new();
          
          // Prepare data
          const data = [];
          
          // Title
          data.push([`Study Plan - ${plan.name}`]);
          data.push([]);
          
          // Student info
          if (studentInfo) {
            data.push(['Student:', studentInfo.name || 'N/A']);
            data.push(['ID:', studentInfo.id || 'N/A']);
            data.push(['Level:', studentInfo.level || 'N/A']);
          }
          
          const completedHours = selected.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
          data.push(['Total Credits:', `${completedHours}/135`]);
          data.push(['GPA:', studentInfo?.gpa || '0.00']);
          data.push(['Generated:', new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })]);
          data.push([]);
          
          // Headers
          data.push(['Course Code', 'Course Name', 'Hours', 'Type', 'Gained Hours', 'Remaining Hours']);

          // Semesters and courses
          plan.semesters.forEach((semester, index) => {
            // Calculate gained hours up to this semester (including initial completed hours)
            let gainedHours = completedHours;
            for (let i = 0; i <= index; i++) {
              gainedHours += plan.semesters[i].hours;
            }
            
            // Calculate remaining hours
            const remainingHours = 135 - gainedHours;
            const courseCount = semester.courses.length;
            
            const specialCase = semester.isSpecialCase ? ' â­ Special Case' : '';
            data.push([`${semester.name} - ${semester.hours} hours (${courseCount} courses)${specialCase}`, '', '', '', `${gainedHours}h`, `${remainingHours}h`]);
            
            semester.courses.forEach(code => {
              const course = courses[code];
              if (course) {
                const courseType = course.hours === 2 ? 'Lab' : 'Theoretical';
                data.push([code, course.name, `${course.hours}h`, courseType, '', '']);
              }
            });
          });
          
          // Total
          const totalHours = plan.semesters.reduce((sum, sem) => sum + sem.hours, 0);
          data.push([]);
          data.push(['TOTAL', '', `${totalHours}h`, `${plan.semesters.length} Semesters`]);

          // Create worksheet
          const ws = XLSX.utils.aoa_to_sheet(data);
          
          // Set column widths
          ws['!cols'] = [
            { wch: 15 },  // Course Code
            { wch: 50 },  // Course Name
            { wch: 10 },  // Hours
            { wch: 15 },  // Type
            { wch: 15 },  // Gained Hours
            { wch: 15 }   // Remaining Hours
          ];

          // Add worksheet to workbook
          XLSX.utils.book_append_sheet(wb, ws, 'Study Plan');

          // Generate filename
          const filename = `Study_Plan_${plan.name.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`;
          
          // Download
          XLSX.writeFile(wb, filename);
        }

        // Drag and Drop Handlers
        let draggedElement = null;
        let draggedCourseCode = null;
        let draggedFromSemester = null;
        let autoScrollInterval = null;
        let scrollSpeed = 0;

        function handleDragStart(e) {
          draggedElement = e.target;
          draggedCourseCode = e.target.dataset.courseCode;
          // -1 means dragging from an external source (courses table or remaining list)
          draggedFromSemester = e.target.dataset.semesterIndex !== undefined 
            ? parseInt(e.target.dataset.semesterIndex) 
            : -1;
          
          e.target.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', draggedCourseCode);
        }

        function handleDragEnd(e) {
          e.target.classList.remove('dragging');
          e.target.style.opacity = '';
          
          // Clear drag state so stale values can never be re-used
          draggedCourseCode = null;
          draggedFromSemester = null;
          draggedElement = null;
          
          // Stop auto-scrolling
          if (autoScrollInterval) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
            scrollSpeed = 0;
          }
          
          // Remove all drag-over effects
          document.querySelectorAll('.semester-courses').forEach(el => {
            el.classList.remove('drag-over');
          });
          document.querySelectorAll('.semester-card').forEach(el => {
            el.classList.remove('invalid-drop');
          });
        }

        function handleDragOver(e) {
          if (e.preventDefault) {
            e.preventDefault();
          }
          
          const dropZone = e.target.closest('.semester-courses');
          if (dropZone) {
            dropZone.classList.add('drag-over');
          }
          
          e.dataTransfer.dropEffect = 'move';
          
          // Auto-scroll when dragging near edges
          const scrollThreshold = 100; // Distance from edge to trigger scroll (pixels)
          const maxScrollSpeed = 20; // Maximum scroll speed (pixels per frame)
          const mouseY = e.clientY;
          const windowHeight = window.innerHeight;
          
          // Calculate scroll speed based on proximity to edge
          let newScrollSpeed = 0;
          
          if (mouseY < scrollThreshold) {
            // Near top edge - scroll up
            const proximity = 1 - (mouseY / scrollThreshold);
            newScrollSpeed = -Math.ceil(proximity * maxScrollSpeed);
          } else if (mouseY > windowHeight - scrollThreshold) {
            // Near bottom edge - scroll down
            const proximity = (mouseY - (windowHeight - scrollThreshold)) / scrollThreshold;
            newScrollSpeed = Math.ceil(proximity * maxScrollSpeed);
          }
          
          // Update scroll speed
          scrollSpeed = newScrollSpeed;
          
          // Start or stop scrolling interval
          if (scrollSpeed !== 0 && !autoScrollInterval) {
            autoScrollInterval = setInterval(() => {
              if (scrollSpeed !== 0) {
                window.scrollBy(0, scrollSpeed);
              }
            }, 16); // ~60fps
          } else if (scrollSpeed === 0 && autoScrollInterval) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
          }
          
          return false;
        }

        function handleDragLeave(e) {
          const dropZone = e.target.closest('.semester-courses');
          if (dropZone && !dropZone.contains(e.relatedTarget)) {
            dropZone.classList.remove('drag-over');
          }
        }

        // Drop guard â€” prevents double-fire within the same browser tick
        let _dropHandled = false;

        function handleDrop(e) {
          if (e.stopPropagation) e.stopPropagation();
          e.preventDefault();

          // Stop auto-scrolling
          if (autoScrollInterval) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
            scrollSpeed = 0;
          }

          // Guard: ignore if this drop was already handled this tick
          if (_dropHandled) return;
          _dropHandled = true;
          setTimeout(() => { _dropHandled = false; }, 0);

          // Guard: no course being dragged
          if (!draggedCourseCode) return;

          const dropTarget = e.target.closest('.semester-courses');
          if (!dropTarget) return;

          const toSemesterIndex = parseInt(dropTarget.dataset.semesterIndex);
          if (isNaN(toSemesterIndex)) return;

          console.log(`Drop event: from ${draggedFromSemester} to ${toSemesterIndex}`);

          // â”€â”€ External drag (from courses table or remaining courses list) â”€â”€
          if (draggedFromSemester === -1) {
            const plan = generatedPlans[currentPlanIndex];
            if (!plan) return;

            const course = courses[draggedCourseCode];
            if (!course) {
              TechBot.error(`Unknown course "${draggedCourseCode}"`);
              return;
            }

            // 1. Already completed / selected by student
            const uniqueSelected = [...new Set(selected)];
            if (uniqueSelected.includes(draggedCourseCode)) {
              TechBot.warning(`"${course.name}" is already marked as completed`);
              return;
            }

            // 2. Already scheduled in any semester of the plan
            const alreadyScheduled = plan.semesters.some(sem =>
              sem.courses.includes(draggedCourseCode)
            );
            if (alreadyScheduled) {
              TechBot.warning(`"${course.name}" is already in the study plan`);
              return;
            }

            const toSemester = plan.semesters[toSemesterIndex];

            // 3. Hour limit validation
            if (toSemester.isSummer) {
              const maxSummerH = toSemester.isSpecialCase ? 12 : 9;
              const newH = toSemester.hours + course.hours;
              if (newH > maxSummerH) {
                TechBot.error(`Summer limit is ${maxSummerH}h â€” adding this would reach ${newH}h`);
                return;
              }
              if (!course.isTheoretical && draggedCourseCode !== 'TR') {
                TechBot.error('Only theoretical courses (and TR) can be placed in summer');
                return;
              }
            } else {
              const maxH = toSemester.isSpecialCase ? 21 : 18;
              const newH = toSemester.hours + course.hours;
              if (newH > maxH) {
                TechBot.error(`This semester is capped at ${maxH}h â€” adding this would reach ${newH}h`);
                return;
              }
            }

            // 4. Prerequisite validation
            const prereqValidation = validatePrerequisites(draggedCourseCode, toSemesterIndex);
            if (!prereqValidation.valid) {
              TechBot.error(prereqValidation.message);
              return;
            }

            // 5. Course-specific constraints (Summer Training, Project 1, Project 2)
            const allSemesters = plan.semesters;
            const completedCredits = CourseConstraints.calculateCompletedCredits(
              document.querySelectorAll('.semester-card'), 
              toSemesterIndex
            );
            const completedCourses = CourseConstraints.getCompletedCourses(
              document.querySelectorAll('.semester-card'), 
              toSemesterIndex
            );
            
            const semesterType = toSemester.isSummer ? 'Summer' : 
                                (toSemesterIndex % 2 === 0 ? 'Odd' : 'Even');
            
            const constraintCheck = CourseConstraints.canAddCourse(
              course.name, 
              semesterType, 
              toSemesterIndex,
              completedCredits,
              completedCourses
            );
            
            if (!constraintCheck.allowed) {
              TechBot.error(constraintCheck.reason);
              return;
            }

            // Save state for undo
            UndoRedoManager.saveState(`Added ${draggedCourseCode} to ${toSemester.name}`);

            // Odd/Even type warning for external drop
            if (!toSemester.isSummer) {
              const extSemType = getSemesterType(course.semester);
              const extTermType = toSemester.name.includes('First') ? 1 : 2;
              if (extSemType && extSemType !== extTermType) {
                const fl = extSemType === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
                const tl = extTermType === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
                TechBot.warning(`âš ï¸ "${course.name}" is a ${fl} course added to a ${tl} semester. Check your plan carefully.`);
              }
            }

            // All checks passed â€” add the course
            toSemester.courses.push(draggedCourseCode);
            toSemester.hours += course.hours;
            displayStudyPlan(currentPlanIndex);
            TechBot.success(`Added "${course.name}" to ${toSemester.name} âœ“`);
            return;
          }

          // â”€â”€ Internal drag (within the study plan) â”€â”€

          // Don't drop on same semester
          if (draggedFromSemester === toSemesterIndex) {
            TechBot.error('Course is already in this semester');
            return;
          }

          // Validate the move
          const validation = validateCourseMove(draggedCourseCode, draggedFromSemester, toSemesterIndex);
          if (!validation.valid) {
            TechBot.error(validation.message);
            return;
          }

          moveCourse(draggedCourseCode, draggedFromSemester, toSemesterIndex);
          if (validation.isWarning) {
            TechBot.warning(validation.message);
          } else {
            TechBot.success(validation.message || 'Course moved successfully! âœ“');
          }
        }

        // Validate if a course can be moved
        function validateCourseMove(courseCode, fromIndex, toIndex) {
          const plan = generatedPlans[currentPlanIndex];
          const toSemester = plan.semesters[toIndex];
          const course = courses[courseCode];

          if (!course) {
            return { valid: false, message: 'Course not found' };
          }

          // â”€â”€ Odd/Even semester type mismatch warning â”€â”€
          let semesterTypeWarning = null;
          if (!toSemester.isSummer) {
            const courseSemType = getSemesterType(course.semester);
            const toTermType = toSemester.name.includes('First') ? 1 : 2;
            if (courseSemType && courseSemType !== toTermType) {
              const fromLabel = courseSemType === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
              const toLabel   = toTermType   === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
              semesterTypeWarning = `âš ï¸ "${course.name}" is a ${fromLabel} semester course being moved to a ${toLabel} semester. This is an irregular placement â€” double-check your plan.`;
            }
          }

          // Check if it's summer semester
          if (toSemester.isSummer) {            // Summer rules: max 9 hours normally, but special case allows up to 12 hours
            if (!course.isTheoretical && courseCode !== 'TR') {
              return { valid: false, message: 'Only theoretical courses (and TR) can be taken in summer' };
            }
            
            // Calculate new summer hours after adding the course
            const newSummerHours = toSemester.hours + course.hours;
            
            // Check if this is a special case semester (marked as such)
            const isSpecialCaseSemester = toSemester.isSpecialCase || false;
            
            // Determine max hours based on special case status
            const maxSummerHours = isSpecialCaseSemester ? 12 : 9;
            
            if (newSummerHours > maxSummerHours) {
              if (isSpecialCaseSemester) {
                return { valid: false, message: `Summer special case limit is 12 hours (would be ${newSummerHours}h)` };
              } else {
                // Check if this could become a special case (total remaining hours 0-12)
                const remainingCourses = Object.keys(courses).filter(code => {
                  const selected = [...new Set(window.selected || [])];
                  return !selected.includes(code) && code !== 'BMA001';
                });
                const remainingHours = remainingCourses.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
                
                if (remainingHours > 0 && remainingHours <= 12 && newSummerHours <= 12) {
                  return { valid: true, message: 'â­ Summer special case: Last semester with 0-12 hours remaining âœ“' };
                }
                
                return { valid: false, message: `Summer semester limit is 9 hours (would be ${newSummerHours}h). Special case (12h max) only for last semester with 0-12 hours remaining.` };
              }
            }

            // TR can only be in summer
            if (courseCode === 'TR') {
              return { valid: true, message: 'Summer Training moved to summer âœ“' };
            }
          } else {
            // Normal semester rules
            // TR can ONLY be in summer
            if (courseCode === 'TR') {
              return { valid: false, message: 'TR (Summer Training) can only be taken in summer semesters' };
            }

            // PC402 cannot be in summer
            // (this is already a normal semester so it's ok)

            // Check normal semester hour limit
            // Regular semesters: max 18 hours
            // Last semester (isSpecialCase): max 21 hours
            const newHours = toSemester.hours + course.hours;
            const isLastSemester = toSemester.isSpecialCase;
            const maxHoursLimit = isLastSemester ? 21 : 18;

            if (newHours > maxHoursLimit) {
              if (!isLastSemester && newHours <= 21) {
                return { valid: false, message: `âš ï¸ Regular semesters are capped at 18 hours (would be ${newHours}h). Only the final semester can reach 21h.` };
              }
              return { valid: false, message: `Semester limit is ${maxHoursLimit} hours (would be ${newHours}h)` };
            }
            
            // Special case notification when entering 21-hour territory (last semester only)
            if (isLastSemester && newHours > 18) {
              return { valid: true, message: `â­ Final semester special case: ${newHours} credit hours âœ“` };
            }
          }

          // Check prerequisites are met
          const validation = validatePrerequisites(courseCode, toIndex);
          if (!validation.valid) {
            return validation;
          }

          if (semesterTypeWarning) {
            return { valid: true, message: semesterTypeWarning, isWarning: true };
          }

          return { valid: true, message: 'Move validated âœ“' };
        }

        // Validate prerequisites for a course in a specific semester
        function validatePrerequisites(courseCode, semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          const course = courses[courseCode];
          
          // Get all courses completed before this semester
          const completedBefore = new Set(selected); // Already completed
          
          for (let i = 0; i < semesterIndex; i++) {
            plan.semesters[i].courses.forEach(code => completedBefore.add(code));
          }

          // Check if all prerequisites are met
          const unmetPrereqs = course.prerequisites.filter(prereq => !completedBefore.has(prereq));
          
          if (unmetPrereqs.length > 0) {
            return { 
              valid: false, 
              message: `Missing prerequisites: ${unmetPrereqs.join(', ')}. Complete these first or move to a later semester.` 
            };
          }

          return { valid: true };
        }

        // Move course between semesters and re-plan
        function moveCourse(courseCode, fromIndex, toIndex) {
          const plan = generatedPlans[currentPlanIndex];
          
          console.log(`Moving ${courseCode} from semester ${fromIndex} to ${toIndex}`);
          
          // Save state for undo
          UndoRedoManager.saveState(`Moved ${courseCode} from ${plan.semesters[fromIndex].name} to ${plan.semesters[toIndex].name}`);
          
          // Store the course being moved
          const movedCourse = courses[courseCode];
          
          // Remove from source semester
          const fromSemester = plan.semesters[fromIndex];
          const courseIndex = fromSemester.courses.indexOf(courseCode);
          if (courseIndex > -1) {
            fromSemester.courses.splice(courseIndex, 1);
            fromSemester.hours -= movedCourse.hours;
            console.log(`Removed from semester ${fromIndex}, new hours: ${fromSemester.hours}`);
          }

          // Add to destination semester
          const toSemester = plan.semesters[toIndex];
          toSemester.courses.push(courseCode);
          toSemester.hours += movedCourse.hours;
          console.log(`Added to semester ${toIndex}, new hours: ${toSemester.hours}`);

          // RE-PLAN: Re-optimize from the earlier affected semester
          // If we moved to an earlier semester (toIndex < fromIndex):
          //   - The destination semester (toIndex) is now locked with the new course
          //   - Re-plan from the semester after it to optimize the rest
          // If we moved to a later semester (toIndex > fromIndex):
          //   - The source semester (fromIndex) now has a gap
          //   - Re-plan from fromIndex to fill the gap and optimize
          
          const replanStartIndex = toIndex < fromIndex ? toIndex : fromIndex;
          console.log(`Triggering re-plan from semester ${replanStartIndex} onwards`);
          replanAfterMove(replanStartIndex);
          
          console.log('Move completed');
        }

        // Re-plan remaining semesters after a course move
        function replanAfterMove(fromIndex) {
          const plan = generatedPlans[currentPlanIndex];
          
          console.log(`Re-planning from semester ${fromIndex} onwards`);
          TechBot.notify('Re-optimizing plan...');
          
          // Collect all completed courses up to and including the target semester
          const completedCourses = new Set([...selected]); // Already completed from transcript
          
          for (let i = 0; i <= fromIndex; i++) {
            plan.semesters[i].courses.forEach(code => completedCourses.add(code));
          }
          
          console.log('Completed courses:', Array.from(completedCourses));
          
          // Collect all remaining courses from semesters after the move point
          const remainingCourses = [];
          for (let i = fromIndex + 1; i < plan.semesters.length; i++) {
            remainingCourses.push(...plan.semesters[i].courses);
          }
          
          console.log('Courses to re-schedule:', remainingCourses);
          
          // Keep semesters up to and including the target
          const semestersToKeep = plan.semesters.slice(0, fromIndex + 1);
          
          // Determine the starting point for re-planning
          // Calculate based on the semester we just filled
          const lastKeptSemester = semestersToKeep[semestersToKeep.length - 1];
          let nextTermNumber;
          
          if (lastKeptSemester.isSummer) {
            // If last kept was summer, next is the following fall/spring term
            // Extract year from summer name and continue
            const yearMatch = lastKeptSemester.name.match(/(\d{4})/);
            if (yearMatch) {
              const year = parseInt(yearMatch[1]);
              // Summer is between spring and fall, so next would be fall (term 1 of new year)
              nextTermNumber = ((year - 2024) * 2) + 1;
            } else {
              nextTermNumber = fromIndex + 2; // Default fallback
            }
          } else {
            // Regular semester - just increment
            // Determine current term type from the semester name
            const isFirstTerm = lastKeptSemester.name.includes('First');
            const yearMatch = lastKeptSemester.name.match(/(\d{4})/);
            
            if (yearMatch) {
              const year = parseInt(yearMatch[1]);
              const baseYear = year - 2024;
              
              if (isFirstTerm) {
                // After first term comes second term of same academic year
                nextTermNumber = (baseYear * 2) + 2;
              } else {
                // After second term comes first term of next academic year
                nextTermNumber = ((baseYear + 1) * 2) + 1;
              }
            } else {
              nextTermNumber = fromIndex + 2; // Default fallback
            }
          }
          
          console.log(`Next term number: ${nextTermNumber}`);
          
          // Re-generate the plan for remaining courses
          const newSemesters = generateRemainingPlan(
            Array.from(completedCourses),
            remainingCourses,
            nextTermNumber
          );
          
          // Replace the plan
          plan.semesters = [...semestersToKeep, ...newSemesters];
          
          console.log('Re-plan complete, new semester count:', plan.semesters.length);
          
          // Refresh display
          displayStudyPlan(currentPlanIndex);
          TechBot.success('Plan re-optimized successfully!');
        }

        // Generate plan for remaining courses
        function generateRemainingPlan(completedCourses, remainingCourses, startTermNumber) {
          const newSemesters = [];
          let completed = [...completedCourses];
          let toSchedule = [...remainingCourses];
          
          // Calculate current credit hours
          const calculateHours = (courseList) => {
            return courseList.reduce((sum, code) => {
              if (code === 'BMA001') return sum;
              return sum + (courses[code]?.hours || 0);
            }, 0);
          };
          
          let currentHours = calculateHours(completed);
          let currentTermNumber = startTermNumber;
          const maxIterations = 12;
          let iterations = 0;
          
          // ==========================================
          // CALCULATE BASE YEAR FROM CURRENT DATE
          // ==========================================
          const now = new Date();
          const currentCalendarYear = now.getFullYear();
          const currentMonth = now.getMonth() + 1;
          const currentAcademicYear = (currentMonth >= 9) ? currentCalendarYear : currentCalendarYear - 1;
          const startTermYearIndex = Math.floor((startTermNumber - 1) / 2);
          const term1BaseYear = currentAcademicYear - startTermYearIndex;
          
          console.log(`Re-planning from term ${currentTermNumber}, ${toSchedule.length} courses to schedule`);
          
          while (toSchedule.length > 0 && iterations < maxIterations) {
            iterations++;
            
            const termType = (currentTermNumber % 2 === 1) ? 1 : 2;
            console.log(`\n--- Re-planning term ${currentTermNumber} (type ${termType}) ---`);
            
            const remainingHours = calculateHours(toSchedule);
            console.log(`   Remaining: ${toSchedule.length} courses, ${remainingHours}h`);
            
            let maxHours = 18;
            
            // FILTER: Get courses available for this term
            let available = toSchedule.filter(code => {
              const course = courses[code];
              if (!course) return false;
              
              // Semester type must match
              const courseSemesterType = getSemesterType(course.semester);
              if (courseSemesterType !== termType) return false;
              
              // Prerequisites must be met
              const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
              if (!prereqsMet) return false;
              
              // TR only in summer
              if (code === 'TR') return false;
              
              // PC401 requires 85+ hours
              if (code === 'PC401' && currentHours < 85) return false;
              
              return true;
            });
            
            console.log(`   ${available.length} courses available`);
            
            // PRIORITIZE
            available = available.map(code => {
              const unlocks = Object.keys(courses).filter(c => 
                courses[c].prerequisites.includes(code) && toSchedule.includes(c)
              ).length;
              
              let priority = unlocks;
              if (code === 'PC401' && currentHours >= 85) priority = 1000;
              else if (code === 'PC402' && completed.includes('PC401')) priority = 999;
              
              return { code, priority, hours: courses[code].hours };
            });
            
            available.sort((a, b) => {
              if (b.priority !== a.priority) return b.priority - a.priority;
              return b.hours - a.hours;
            });
            
            available = available.map(item => item.code);
            
            // SELECT courses
            const termCourses = [];
            let termHours = 0;
            
            for (const code of available) {
              const courseHours = courses[code].hours;
              if (termHours + courseHours <= maxHours) {
                termCourses.push(code);
                termHours += courseHours;
              }
            }
            
            if (termCourses.length === 0) {
              console.log('   No courses available, stopping');
              break;
            }
            
            // Add semester
            const termYearIndex = Math.floor((currentTermNumber - 1) / 2);
            const year = term1BaseYear + termYearIndex;
            const termName = termType === 1 ? 'First' : 'Second';
            
            newSemesters.push({
              name: `${termName} Term ${year}-${year + 1}`,
              courses: termCourses,
              hours: termHours,
              isSummer: false,
              isSpecialCase: false
            });
            
            completed.push(...termCourses);
            toSchedule = toSchedule.filter(code => !termCourses.includes(code));
            currentHours = calculateHours(completed);
            
            console.log(`   Added ${termCourses.length} courses (${termHours}h). Total: ${currentHours}h`);
            
            // ==========================================
            // POST-SEMESTER CHECKS
            // ==========================================
            
            // CHECK 1: TR Summer
            if (termType === 2 && toSchedule.includes('TR') && currentHours >= 60) {
              console.log(`   ðŸŒž TR condition met, adding TR summer`);
              
              const trPrereqsMet = courses['TR'].prerequisites.every(prereq => completed.includes(prereq));
              if (trPrereqsMet) {
                newSemesters.push({
                  name: `Summer Term ${year}-${year + 1}`,
                  courses: ['TR'],
                  hours: 2,
                  isSummer: true,
                  isSpecialCase: false
                });
                
                completed.push('TR');
                toSchedule = toSchedule.filter(code => code !== 'TR');
                currentHours = calculateHours(completed);
                
                console.log(`   âœ… Added TR summer. Total: ${currentHours}h`);
              }
            }
            
            // Recalculate remaining
            const newRemainingHours = calculateHours(toSchedule);
            
            // CHECK 3: Special Summer (â‰¤12h after even semester - REGARDLESS of type mix)
            // This check must come BEFORE CHECK 2 because it's more specific
            if (termType === 2 && newRemainingHours > 0 && newRemainingHours <= 12 && toSchedule.length > 0) {
              console.log(`   â­ Special summer case: ${newRemainingHours}h after even semester`);
              
              const summerCourses = toSchedule.filter(code => {
                const course = courses[code];
                if (!course) return false;
                
                const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                if (!prereqsMet) return false;
                
                if (code === 'TR' && currentHours < 60) return false;
                if (code === 'PC401' || code === 'PC402') return false;
                
                return true;
              });
                
              if (summerCourses.length > 0) {
                let summerHours = 0;
                const selectedSummer = [];
                
                const prioritizedSummer = summerCourses.map(code => {
                  const unlocks = Object.keys(courses).filter(c => 
                    courses[c].prerequisites.includes(code) && toSchedule.includes(c)
                  ).length;
                  return { code, unlocks, hours: courses[code].hours };
                }).sort((a, b) => {
                  if (b.unlocks !== a.unlocks) return b.unlocks - a.unlocks;
                  return b.hours - a.hours;
                });
                
                for (const item of prioritizedSummer) {
                  if (summerHours + item.hours <= 12) {
                    selectedSummer.push(item.code);
                    summerHours += item.hours;
                  }
                }
                
                if (selectedSummer.length > 0) {
                  newSemesters.push({
                    name: `Summer Term Special Case`,
                    courses: selectedSummer,
                    hours: summerHours,
                    isSummer: true,
                    isSpecialCase: true
                  });
                  
                  completed.push(...selectedSummer);
                  toSchedule = toSchedule.filter(code => !selectedSummer.includes(code));
                  currentHours = calculateHours(completed);
                  
                  console.log(`   âœ… Added special summer: ${selectedSummer.length} courses`);
                }
              }
            }
            
            // Recalculate again after potential summer addition
            const finalRemainingHours = calculateHours(toSchedule);
            
            // CHECK 2: Special 21-Hour Semester
            // This check comes AFTER CHECK 3 (more general fallback)
            if (finalRemainingHours > 0 && finalRemainingHours <= 21 && toSchedule.length > 0) {
              const remainingSemesterTypes = toSchedule.map(code => {
                const course = courses[code];
                return course ? getSemesterType(course.semester) : null;
              }).filter(t => t !== null);
              
              const allType1 = remainingSemesterTypes.every(t => t === 1);
              const allType2 = remainingSemesterTypes.every(t => t === 2);
              
              if (allType1 || allType2) {
                console.log(`   â­ Special 21-hour case: all courses same type, ${finalRemainingHours}h`);
                
                const finalCourses = toSchedule.filter(code => {
                  const course = courses[code];
                  if (!course || code === 'TR') return false;
                  
                  const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                  if (!prereqsMet) return false;
                  
                  if (code === 'PC401' && currentHours < 85) return false;
                  
                  return true;
                });
                
                if (finalCourses.length > 0) {
                  const finalHours = calculateHours(finalCourses);
                  const nextTermNumber = currentTermNumber + 1;
                  const nextTermType = (nextTermNumber % 2 === 1) ? 1 : 2;
                  const nextTermYearIndex = Math.floor((nextTermNumber - 1) / 2);
                  const nextYear = term1BaseYear + nextTermYearIndex;
                  const nextTermName = nextTermType === 1 ? 'First' : 'Second';
                  
                  newSemesters.push({
                    name: `${nextTermName} Term ${nextYear}-${nextYear + 1}`,
                    courses: finalCourses,
                    hours: finalHours,
                    isSummer: false,
                    isSpecialCase: true
                  });
                  
                  completed.push(...finalCourses);
                  toSchedule = toSchedule.filter(code => !finalCourses.includes(code));
                  currentHours = calculateHours(completed);
                  
                  console.log(`   âœ… Added special 21-hour semester: ${finalCourses.length} courses`);
                }
              }
            }
            
            currentTermNumber++;
            if (currentTermNumber > 12) {
              console.log('âš ï¸ Reached maximum term (12)');
              break;
            }
          }
          
          console.log(`\nRe-planning complete: ${newSemesters.length} new semesters`);
          if (toSchedule.length > 0) {
            console.log(`âš ï¸ ${toSchedule.length} courses not scheduled: ${toSchedule.join(', ')}`);
          }
          
          return newSemesters;
        }

        // Add summer semester after a specific semester
        function addSummerSemesterAfter(afterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          
          // Determine the year based on the semester after which we're adding
          const afterSemester = plan.semesters[afterIndex];
          let year = 2024;
          
          // Extract year from semester name if possible
          const yearMatch = afterSemester.name.match(/(\d{4})/);
          if (yearMatch) {
            year = parseInt(yearMatch[1]);
          }
          
          // Check if remaining hours qualify for special case
          const remainingCourses = Object.keys(courses).filter(code => {
            const selected = [...new Set(window.selected || [])];
            return !selected.includes(code) && code !== 'BMA001';
          });
          const remainingHours = remainingCourses.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
          
          const isSpecialCase = (remainingHours > 0 && remainingHours <= 12);
          
          // Create summer semester
          const summerSemester = {
            name: `Summer Term ${year}-${year + 1}${isSpecialCase ? ' (Special Case)' : ''}`,
            courses: [],
            hours: 0,
            isSummer: true,
            isSpecialCase: isSpecialCase
          };

          // Insert after the specified index
          plan.semesters.splice(afterIndex + 1, 0, summerSemester);
          
          displayStudyPlan(currentPlanIndex);
          
          const maxHours = isSpecialCase ? 12 : 9;
          const message = isSpecialCase 
            ? `â­ Summer special case added after ${afterSemester.name}! Drag theoretical courses here (max ${maxHours} hours - any semester 1-8).`
            : `Summer semester added after ${afterSemester.name}! Drag courses here (max ${maxHours} hours, theoretical only).`;
          
          TechBot.success(message);
        }

        // Delete semester
        function deleteSemester(semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          const semester = plan.semesters[semesterIndex];
          
          if (!semester.isSummer) {
            TechBot.error('Cannot delete regular semesters, only summer semesters.');
            return;
          }

          const doDelete = function() {
            // Save state for undo
            UndoRedoManager.saveState(`Deleted ${semester.name}`);
            
            plan.semesters.splice(semesterIndex, 1);
            displayStudyPlan(currentPlanIndex);
            TechBot.success('Summer semester deleted.');
          };

          if (semester.courses.length > 0) {
            window.confirmDeleteSemester = doDelete;
            TechBot.confirm(
              'ðŸ—‘ï¸ Delete Summer Semester',
              `This summer semester has ${semester.courses.length} course(s). Delete anyway? Courses will be unscheduled.`,
              'confirmDeleteSemester'
            );
          } else {
            doDelete();
          }
        }

        // Toggle special case for a semester
        function toggleSpecialCase(semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          if (!plan) return;
          
          const semester = plan.semesters[semesterIndex];
          UndoRedoManager.saveState(`${semester.isSpecialCase ? 'Removed' : 'Added'} special case on ${semester.name}`);
          
          semester.isSpecialCase = !semester.isSpecialCase;
          
          const isSummer = semester.isSummer;
          const maxH = semester.isSpecialCase
            ? (isSummer ? 12 : 21)
            : (isSummer ? 9 : 18);
          const prevMax = semester.isSpecialCase
            ? (isSummer ? 9 : 18)
            : (isSummer ? 12 : 21);
          
          if (semester.isSpecialCase) {
            TechBot.success(`â­ "${semester.name}" is now a Special Case â€” max hours raised to ${maxH}h`);
          } else {
            // Check if current hours exceed the new (reduced) limit
            if (semester.hours > maxH) {
              TechBot.warning(`âš ï¸ Special case removed from "${semester.name}". Max hours is now ${maxH}h, but semester has ${semester.hours}h â€” please move some courses out.`);
            } else {
              TechBot.notify(`â˜† Special case removed from "${semester.name}" â€” max is ${maxH}h again.`);
            }
          }
          
          displayStudyPlan(currentPlanIndex);
        }

        // Reset plan to original
        function resetPlan() {
          window.confirmResetPlan = function() {
            // Save state for undo
            UndoRedoManager.saveState('Reset plan to original');
            
            generateMultiplePlans();
            TechBot.success('Plan reset to original.');
          };
          
          TechBot.confirm(
            'ðŸ”„ Reset Plan',
            'Reset plan to original? All your changes will be lost.',
            'confirmResetPlan'
          );
        }

        // Show toast notification (replaces old inline validationMessage)
        function showValidation(message, type = 'info') {
          // Also update inline message for backward compat
          const msgDiv = document.getElementById('validationMessage');
          if (msgDiv) {
            msgDiv.className = `validation-message ${type}`;
            msgDiv.textContent = message;
            msgDiv.style.display = 'block';
            setTimeout(() => { msgDiv.style.display = 'none'; }, 5000);
          }

          // Toast
          let container = document.getElementById('toastContainer');
          if (!container) {
            container = document.createElement('div');
            container.id = 'toastContainer';
            document.body.appendChild(container);
          }
          const toast = document.createElement('div');
          toast.className = `toast-msg ${type}`;
          toast.textContent = message;
          container.appendChild(toast);
          setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease';
            setTimeout(() => toast.remove(), 350);
          }, 4500);
        }

        // ============================================================
        // REMOVE COURSE FROM PLAN (with cascade deletion of dependents)
        // ============================================================
        function removeCourseFromPlan(courseCode, semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          if (!plan) return;

          // Find all courses in later semesters that depend on this one (cascade)
          function findDependents(code, fromSemIdx) {
            const deps = [];
            for (let i = fromSemIdx + 1; i < plan.semesters.length; i++) {
              plan.semesters[i].courses.forEach(c => {
                if (courses[c] && courses[c].prerequisites.includes(code)) {
                  deps.push({ code: c, semIdx: i });
                  // Recurse to find dependents of dependents
                  const nested = findDependents(c, i);
                  nested.forEach(n => {
                    if (!deps.find(d => d.code === n.code)) deps.push(n);
                  });
                }
              });
            }
            return deps;
          }

          const dependents = findDependents(courseCode, semesterIndex);

          // Build confirmation message
          let msg = `Remove <strong>"${courses[courseCode]?.name}"</strong>?`;
          if (dependents.length > 0) {
            const names = dependents.map(d => `<strong>${courses[d.code]?.name || d.code}</strong>`).join(', ');
            msg += `\n\nThis will also remove <strong>${dependents.length}</strong> dependent course(s):\n${names}`;
          }

          // Store the removal function
          window.confirmRemoveCourse = function() {
            // Save state for undo
            UndoRedoManager.saveState(`Removed ${courseCode} from ${plan.semesters[semesterIndex].name}`);
            
            // Remove course from its semester
            const sem = plan.semesters[semesterIndex];
            const idx = sem.courses.indexOf(courseCode);
            if (idx > -1) {
              sem.courses.splice(idx, 1);
              sem.hours -= (courses[courseCode]?.hours || 0);
            }

            // Remove cascaded dependents
            dependents.forEach(({ code: depCode, semIdx }) => {
              const depSem = plan.semesters[semIdx];
              const depIdx = depSem.courses.indexOf(depCode);
              if (depIdx > -1) {
                depSem.courses.splice(depIdx, 1);
                depSem.hours -= (courses[depCode]?.hours || 0);
              }
            });

            // Refresh display
            displayStudyPlan(currentPlanIndex);

            const msg2 = dependents.length > 0
              ? `Removed "${courses[courseCode]?.name}" and ${dependents.length} dependent(s): ${dependents.map(d=>courses[d.code]?.name||d.code).join(', ')}`
              : `Removed "${courses[courseCode]?.name}" from the plan`;
            TechBot.success(msg2);
          };

          // Show TechBot confirmation dialog
          TechBot.confirm(
            'ðŸ—‘ï¸ Remove Course',
            msg,
            'confirmRemoveCourse'
          );
        }

        // Generate optimized study plan
        function generateMultiplePlans() {
          addDebugLog('\nðŸŽ“ Generating optimized study plan...', 'info');
          
          // Try to detect current term from most recent PDF parse
          let detectedStartTerm = null;
          
          // Check if we have stored PDF course data
          if (window.lastParsedPdfCourses && window.lastParsedPdfCourses.length > 0) {
            const currentTerm = detectCurrentTerm(window.lastParsedPdfCourses);
            
            if (currentTerm.isDetected) {
              addDebugLog(`\nðŸ” CURRENT TERM DETECTED: Term ${currentTerm.termNumber}`, 'info');
              addDebugLog(`   Currently registered: ${currentTerm.registeredCourses.length} courses`, 'info');
              
              // Validate current registration
              const uniqueSelected = [...new Set(selected)];
              const validation = validateCurrentRegistration(currentTerm, uniqueSelected);
              
              if (!validation.isValid) {
                addDebugLog(`\nâš ï¸ REGISTRATION VIOLATIONS DETECTED:`, 'warning');
                validation.violations.forEach(v => {
                  addDebugLog(`   âŒ ${v.code}: ${v.reason}`, 'error');
                });
              } else {
                addDebugLog(`   âœ… Current registration is valid`, 'success');
              }
              
              detectedStartTerm = currentTerm.termNumber;
            }
          }
          
          // Use detected term or fallback to term 1
          let finalStartTerm = detectedStartTerm || 1;
          
          // Ensure we start from at least term 1
          if (finalStartTerm < 1) finalStartTerm = 1;
          
          addDebugLog(`\nðŸ“… Starting plan from Term ${finalStartTerm}`, 'info');
          
          generatedPlans = [];
          
          // Generate single OPTIMIZED plan with all requirements:
          // 1. Prioritizes courses that unlock the most other courses
          // 2. Smart dependency management
          // 3. Projects (PC401, PC402) get highest priority when eligible
          // 4. Fills semesters to maximum hours (18 or 21 at special cases)
          // 5. Aims for fastest graduation
          // 6. Automatically adds Summer term with TR when 60 hours gained
          const optimizedPlan = generateStudyPlan('optimized', finalStartTerm);
          generatedPlans.push({
            name: 'Optimized Study Plan',
            semesters: optimizedPlan,
            strategy: 'optimized'
          });

          addDebugLog(`âœ… Generated optimized study plan with ${optimizedPlan.length} semesters`, 'success');

          // Display plan selector (even though there's only one plan)
          const selectorDiv = document.getElementById('planSelectorDiv');
          const selector = document.getElementById('planSelector');
          selector.innerHTML = '';

          generatedPlans.forEach((plan, index) => {
            const btn = document.createElement('button');
            btn.className = `plan-option ${index === 0 ? 'active' : ''}`;
            btn.textContent = plan.name;
            btn.onclick = () => {
              document.querySelectorAll('.plan-option').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              currentPlanIndex = index;
              displayStudyPlan(index);
            };
            selector.appendChild(btn);
          });

          selectorDiv.style.display = 'block';
          window._planJustGenerated = true; // Flag set before display so scroll fires once
          displayStudyPlan(0);
        }

        // Handle generate plan button
        document.getElementById('generatePlanBtn').addEventListener('click', function() {
          if (selected.length === 0) {
            alert('Please upload a student transcript first!');
            return;
          }

          generateMultiplePlans();
          // Note: draggability on .course cells is already set by addCourse().
          // No need to re-register listeners here; that would create duplicates.
        });

        // Handle file upload
        document.getElementById('pdfInput').addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (!file) {
            console.log('No file selected');
            return;
          }

          console.log('File selected:', file.name, file.type, file.size);
          
          // ===== FILE VALIDATION =====
          const maxSize = 10 * 1024 * 1024; // 10MB limit
          if (file.size > maxSize) {
            alert(`File too large! Maximum size is 10MB. Your file is ${(file.size / 1024 / 1024).toFixed(2)}MB`);
            addDebugLog(`âŒ File too large: ${(file.size / 1024 / 1024).toFixed(2)}MB (max 10MB)`, 'error');
            return;
          }
          
          debugLog = []; // Clear debug log
          addDebugLog(`ðŸš€ Starting to process: ${file.name} (${(file.size / 1024).toFixed(2)}KB)`, 'info');

          let result;
          
          // Check file type
          if (file.name.endsWith('.pdf') || file.type === 'application/pdf') {
            addDebugLog('ðŸ“„ Detected PDF file', 'info');
            result = await parsePDF(file);
          } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || 
                     file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                     file.type === 'application/vnd.ms-excel') {
            addDebugLog('ðŸ“Š Detected Excel file', 'info');
            result = await parseExcel(file);
          } else {
            addDebugLog(`âŒ Unsupported file type: ${file.type}. Please upload PDF or Excel file.`, 'error');
            alert('Please upload a PDF or Excel file');
            return;
          }

          if (!result) {
            addDebugLog('âŒ Failed to parse file', 'error');
            return;
          }

          const { courses: pdfCourses, studentInfo } = result;

          if (!pdfCourses || pdfCourses.length === 0) {
            addDebugLog('âš ï¸ No courses found in the file', 'warning');
            alert('No courses found in the uploaded file. Please check the file format.');
            return;
          }

          // Store PDF courses for term detection
          window.lastParsedPdfCourses = pdfCourses;
          addDebugLog(`ðŸ’¾ Stored ${pdfCourses.length} course records for analysis`, 'info');

          // Display student info
          if (studentInfo.name) {
            document.getElementById('studentInfo').style.display = 'block';
            document.getElementById('studentName').textContent = `ðŸ‘¤ Name: ${studentInfo.name}`;
            document.getElementById('studentId').textContent = `ðŸ†” ID: ${studentInfo.id || 'N/A'}`;
            document.getElementById('studentLevel').textContent = `ðŸ“š Level: ${studentInfo.level || 'N/A'}`;
            
            if (studentInfo.gpa) {
              document.getElementById('gpaValue').textContent = studentInfo.gpa;
              const gpaNum = parseFloat(studentInfo.gpa);
              document.getElementById('gpaGrade').textContent = 
                gpaNum >= 3.7 ? 'Excellent' : 
                gpaNum >= 3.0 ? 'Very Good' : 
                gpaNum >= 2.5 ? 'Good' : 'Pass';
            }
          }

          // Auto-select courses
          const stats = autoSelectCourses(pdfCourses);
          
          // ===== CRITICAL SAFEGUARD: Remove any duplicates from selected array =====
          const beforeDedup = selected.length;
          selected = [...new Set(selected)];  // Convert to Set and back to remove duplicates
          const afterDedup = selected.length;
          
          if (beforeDedup !== afterDedup) {
            addDebugLog(`âš ï¸ WARNING: Removed ${beforeDedup - afterDedup} duplicate entries from selected courses!`, 'error');
            addDebugLog(`   Before: ${beforeDedup} courses, After: ${afterDedup} courses`, 'warning');
          } else {
            addDebugLog(`âœ… No duplicates found in selected courses (${afterDedup} unique courses)`, 'success');
          }
          
          // Sanity check: A typical 4th year student should have ~25-30 courses completed
          if (afterDedup > 40) {
            addDebugLog(`âš ï¸âš ï¸ SANITY CHECK FAILED: ${afterDedup} courses seems too high!`, 'error');
            addDebugLog(`   ðŸ’¡ This might indicate duplicate matching or program mismatch`, 'error');
            addDebugLog(`   ðŸ’¡ Check if you selected the correct program (IT vs AI) at the top of the page`, 'warning');
          } else if (afterDedup < 10) {
            addDebugLog(`âš ï¸ SANITY CHECK: Only ${afterDedup} courses matched`, 'warning');
            addDebugLog(`   ðŸ’¡ This might indicate matching issues - check the debug log for unmatched courses`, 'warning');
          } else {
            addDebugLog(`âœ… Sanity check passed: ${afterDedup} courses is reasonable for year 4`, 'success');
          }
          
          // Verify no failing courses were selected
          addDebugLog(`\nðŸ” VERIFICATION: Checking selected courses...`, 'info');
          const uniqueSelected = [...new Set(selected)];
          addDebugLog(`   Total selected: ${uniqueSelected.length} unique courses`, 'info');
          
          // Check if IT438 was selected (for debugging)
          if (uniqueSelected.includes('IT438')) {
            addDebugLog(`   âš ï¸ WARNING: IT438 (Communication Technology) was selected - this might be an error!`, 'error');
          } else {
            addDebugLog(`   âœ… IT438 (Communication Technology) NOT selected`, 'success');
          }
          
          // Show statistics
          document.getElementById('statsContainer').style.display = 'grid';
          calculateStatistics();

          // Show remaining courses
          document.getElementById('remainingCourses').style.display = 'block';
          showRemainingCourses();

          // Show study plan generator
          document.getElementById('studyPlanContainer').style.display = 'block';

          addDebugLog(`âœ¨ Processing complete!`, 'success');
          
          // Trigger auto-scroll sequence
          autoScrollAfterUpload();
        });

        // Make upload box clickable
        document.getElementById('uploadBox').addEventListener('click', function() {
          document.getElementById('pdfInput').click();
        });

        // Prevent default drag and drop behavior
        document.getElementById('uploadBox').addEventListener('dragover', function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.style.borderColor = '#2563eb';
          this.style.background = '#eff6ff';
        });

        document.getElementById('uploadBox').addEventListener('dragleave', function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.style.borderColor = '#3b82f6';
          this.style.background = 'white';
        });

        document.getElementById('uploadBox').addEventListener('drop', function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.style.borderColor = '#3b82f6';
          this.style.background = 'white';
          
          const files = e.dataTransfer.files;
          if (files.length > 0) {
            document.getElementById('pdfInput').files = files;
            document.getElementById('pdfInput').dispatchEvent(new Event('change'));
          }
        });

        // Parse Excel file
        async function parseExcel(file) {
          try {
            addDebugLog('ðŸ“Š Loading Excel file...', 'info');
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
            
            // Convert to text format similar to PDF
            let text = '';
            data.forEach(row => {
              text += row.join(' ') + '\n';
            });

            addDebugLog('âœ… Excel loaded successfully', 'success');
            return extractCoursesFromText(text);
          } catch (error) {
            addDebugLog(`âŒ Error parsing Excel: ${error.message}`, 'error');
            return null;
          }
        }
      });
    </script>
  </head>
  <body>
    <h2>
      New Regulation -( <span id="it" class="program active">IT</span> )- (
      <span id="ai" class="program">AI</span>) Courses
    </h2>

    <div class="courses-section">
      <table id="courses_table"><tr id="semester-1"><td class="header">Semester 1</td><td id="IT111" class="course">Electronics</td><td id="MA111" class="course">Mathematics1</td><td id="HU111" class="course">Technical Report Writing</td><td id="HU413" class="course">Human Rights</td><td id="MA112" class="course">Discrete Math</td><td id="IT110" class="course">Introduction to Computers</td></tr><tr id="semester-2"><td class="header">Semester 2</td><td id="ST121" class="course">Probability and Statistics-1</td><td id="HU112" class="course">Creative and Scientific Thinking</td><td id="MA113" class="course">Mathematics-2</td><td id="HU101" class="course">Micro Economics</td><td id="IT113" class="course">Logic Design</td><td id="CS112" class="course">Programming Language</td></tr><tr id="semester-3"><td class="header">Semester 3</td><td id="CS215" class="course">Object Oriented Programing</td><td id="DS211" class="course">Introduction to Database systems</td><td id="MA214" class="course">Mathematics-3 </td><td id="IT231" class="course">Computer Networks Technology</td><td id="ST222" class="course">Probability and Statistics-2</td><td id="CS240" class="course">Introduction to Software Engineering</td></tr><tr id="semester-4"><td class="header">Semester 4</td><td id="IT217" class="course">Introduction to Operation Research</td><td id="CS216" class="course">Data Structure</td><td id="AI321" class="course">Machine Learning Fundamentals</td><td id="IT230" class="course">Web Technology</td><td id="HU427" class="course">Entrepreneurship</td><td id="LB211" class="course">Networking Fundamentals lab</td></tr><tr id="semester-5"><td class="header">Semester 5</td><td id="LB312" class="course">Network Routing and Switching-Lab</td><td id="AI311" class="course">Artificial intelligence</td><td id="CS319" class="course">Operating Systems</td><td id="IT212" class="course">Digital Signal Processing</td><td id="CS318" class="course">Computer Organization</td><td id="CS341" class="course">Algorithms analysis and Design</td></tr><tr id="semester-6"><td class="header">Semester 6</td><td id="IT322" class="course">Pattern Recognition</td><td id="IT333" class="course">Information Computer Networks Security</td><td id="AI448" class="course">op-Natural Language Processing</td><td id="CS344" class="course">Advanced Software Engineering</td><td id="IT343" class="course">Microcontroller</td><td id="LB313" class="course">Ethical Hacking-lab</td></tr><tr id="semester-7"><td class="header">Semester 7</td><td id="LB421" class="course">Selected labs in Software Engineering</td><td id="IT423" class="course">Embedded Systems</td><td id="IT221" class="course">Computer Graphics</td><td id="IT434" class="course">Advanced Computer Networks</td><td id="PC401" class="course">Project (1)</td><td id="IT438" class="course">Communication Technology</td></tr><tr id="semester-8"><td class="header">Semester 8</td><td id="IT436" class="course">Cloud Computing Networking</td><td id="AI435" class="course">Semantic Web and ontology</td><td id="IT439" class="course">Wireless and Mobile Networks</td><td id="HU402" class="course">Fundamental of Management</td><td id="PC402" class="course">Project (2)</td><td id="LB431" class="course">Selected labs in AI</td></tr><tr id="additional-courses"><td class="header">Additional Courses</td><td id="TR" class="course">Summer Training</td><td id="BMA001" class="course">Mathematics-0</td></tr></table>

      <div class="legend-toggle-container">
        <table id="legend">
          <tbody>
          <tr>
            <td class="selected" style="width: 20px; height: 20px;"></td>
            <td>Selected courses</td>
          </tr>
          <tr>
            <td class="direct" style="width: 20px; height: 20px;"></td>
            <td>Direct prerequisite</td>
          </tr>
          <tr>
            <td class="prev" style="width: 20px; height: 20px;"></td>
            <td>Indirect prerequisite</td>
          </tr>
          <tr>
            <td class="next" style="width: 20px; height: 20px;"></td>
            <td>Next courses</td>
          </tr>
        </tbody></table>
        
        <div class="select-multiple-container">
          <label class="switch">
            <input id="selectMulti" type="checkbox">
            <span class="slider"></span>
          </label>
          Select multiple courses
        </div>
      </div>
      <div id="div_sel"></div>
    </div>

    <!-- PDF Upload Interface -->
    <div class="upload-container">
      <div class="upload-box" id="uploadBox">
        <input type="file" id="pdfInput" accept=".pdf,.xlsx" />
        <div class="upload-label">ðŸ“„ Upload Student Record (PDF/Excel)</div>
        <p class="upload-hint">Click to upload Ø¨ÙŠØ§Ù† Ø­Ø§Ù„Ø© - PDF or Excel format</p>
      </div>

      <!-- Student Info -->
      <div class="student-info" id="studentInfo" style="display: none;">
        <h4>ðŸ“‹ Student Information</h4>
        <p id="studentName"></p>
        <p id="studentId"></p>
        <p id="studentLevel"></p>
      </div>

      <!-- Statistics -->
      <div class="stats-container" id="statsContainer" style="display: none;">
        <!-- Graduation Progress Ring Card -->
        <div class="stat-card ring-card">
          <svg class="ring-svg" width="90" height="90" viewBox="0 0 90 90">
            <defs>
              <linearGradient id="ringGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#2563eb"/>
                <stop offset="100%" stop-color="#818cf8"/>
              </linearGradient>
            </defs>
            <circle class="ring-bg" cx="45" cy="45" r="36"/>
            <circle class="ring-fill" id="progressRing" cx="45" cy="45" r="36"
              style="stroke-dasharray: 226.19; stroke-dashoffset: 226.19;" stroke="url(#ringGrad)"/>
            <text id="progressRingText" x="45" y="50" text-anchor="middle"
              font-size="14" font-weight="700" fill="#2563eb" font-family="Inter,sans-serif">0%</text>
          </svg>
          <div class="ring-info">
            <h3>Graduation Progress</h3>
            <div class="stat-value" id="creditHours" style="font-size:22px;">0/135</div>
            <div class="progress-bar">
              <div class="progress-fill" id="creditProgress" style="width: 0%"></div>
            </div>
            <div class="stat-label" id="creditPercentage" style="margin-top:6px;">0% Complete</div>
          </div>
        </div>

        <div class="stat-card">
          <h3>GPA</h3>
          <div class="stat-value" id="gpaValue">0.00</div>
          <div class="stat-label" id="gpaGrade">Not Available</div>
        </div>

        <div class="stat-card">
          <h3>Completed Courses</h3>
          <div class="stat-value" id="completedCount">0</div>
          <div class="stat-label" id="remainingCount">0 Remaining</div>
        </div>
      </div>

      <!-- Remaining Courses -->
      <div class="remaining-courses" id="remainingCourses" style="display: none;">
        <h3>ðŸ“š Remaining Courses <span style="font-size:12px; font-weight:500; color:var(--text-muted); background:#f1f5f9; padding:3px 10px; border-radius:99px; margin-left:8px;">âœ‹ Drag into study plan</span></h3>
        <div class="course-list" id="courseList"></div>
      </div>

      <!-- Study Plan Generator -->
      <div class="study-plan-container" id="studyPlanContainer" style="display: none;">
        <div class="study-plan-header">
          <h3>ðŸŽ“ Study Plan Generator</h3>
          <button class="generate-plan-btn" id="generatePlanBtn">Generate Optimized Study Plan</button>
        </div>
        
        <div id="planSelectorDiv" style="display: none;">
          <div class="plan-selector" id="planSelector"></div>
        </div>

        <div id="studyPlanDisplay"></div>
      </div>

    </div>

  


 

  <!-- Floating Action Buttons (PDF moved to study plan actions bar) -->
  <div class="fab-container" id="fabContainer" style="display:none;">
    <button class="fab-btn fab-pdf" id="fabExportPdf" onclick="exportStudyPlanAsPDF()" title="Export study plan as PDF">
      ðŸ–¨ï¸ Export as PDF
    </button>
  </div>

  <!-- TechBot Toast Notification -->
  <div id="techbot-toast">
    <div class="bot-character">
      ðŸ¤–
      <div class="robot-mouth-overlay"></div>
    </div>
      <div class="toast-message">
        <div class="toast-message-title">ðŸ¤– Assistant Bot</div>
        <div class="toast-message-text" id="toast-text"></div>
      </div>
  </div>

  <!-- TechBot Modal Dialog -->
  <div id="techbot-modal">
    <div class="modal-content">
      <div class="modal-bot">
        <div style="text-align:center; font-size: 72px; position: relative; display: inline-block;">
          ðŸ¤–
          <div class="robot-mouth-overlay" style="bottom: 22px;"></div>
        </div>
      </div>
      <div class="modal-message">
        <h3 id="modal-title">Assistant Bot Says</h3>
        <p id="modal-text"></p>
      </div>
      <div class="modal-buttons" id="modal-buttons">
        <button class="modal-btn modal-btn-primary" onclick="closeTechBotModal()">Got it!</button>
      </div>
    </div>
  </div>

  <script>
    // ============================================================
    // TECHBOT NOTIFICATION SYSTEM
    // ============================================================
    
    const TechBot = {
      prefixes: ['Processing...', 'System update:', 'Optimization complete:', 'Analysis:', 'Computing...', 'Executing...'],
      
      // Show toast notification (bottom right)
      notify(message, duration = 4000) {
        const toast = document.getElementById('techbot-toast');
        const textEl = document.getElementById('toast-text');
        
        // Random prefix
        const prefix = this.prefixes[Math.floor(Math.random() * this.prefixes.length)];
        textEl.innerHTML = `${prefix} ${message}`;
        
        toast.classList.add('show');
        
        setTimeout(() => {
          toast.classList.remove('show');
        }, duration);
      },
      
      // Show modal dialog
      showModal(title, message, buttons = null) {
        const modal = document.getElementById('techbot-modal');
        const titleEl = document.getElementById('modal-title');
        const textEl = document.getElementById('modal-text');
        const buttonsEl = document.getElementById('modal-buttons');
        
        titleEl.textContent = title || 'ðŸ¤– Assistant Bot Says';
        textEl.innerHTML = message;
        
        // Custom buttons or default
        if (buttons) {
          buttonsEl.innerHTML = buttons;
        } else {
          buttonsEl.innerHTML = '<button class="modal-btn modal-btn-primary" onclick="closeTechBotModal()">Got it!</button>';
        }
        
        modal.classList.add('show');
      },
      
      // Confirm dialog
      confirm(title, message, onConfirm, onCancel) {
        const buttons = `
          <button class="modal-btn modal-btn-secondary" onclick="closeTechBotModal(); ${onCancel ? onCancel + '()' : ''}">Cancel</button>
          <button class="modal-btn modal-btn-primary" onclick="closeTechBotModal(); ${onConfirm}()">Confirm</button>
        `;
        this.showModal(title, message, buttons);
      },
      
      // Success message
      success(message) {
        this.notify(message);
      },
      
      // Error message
      error(message) {
        this.showModal('âš ï¸ System Alert', message);
      },
      
      // Warning message
      warning(message) {
        this.notify(message, 5000);
      }
    };
    
    function closeTechBotModal() {
      document.getElementById('techbot-modal').classList.remove('show');
    }
    
    // Close modal on outside click
    document.addEventListener('click', (e) => {
      const modal = document.getElementById('techbot-modal');
      if (e.target === modal) {
        closeTechBotModal();
      }
    });

    // ============================================================
    // UNDO/REDO SYSTEM
    // ============================================================
    
    const UndoRedoManager = {
      undoStack: [],
      redoStack: [],
      maxStackSize: 50,
      
      saveState(description) {
        const state = {
          description: description,
          studyPlanHTML: document.getElementById('studyPlanDisplay')?.innerHTML || '',
          courseListHTML: document.getElementById('courseList')?.innerHTML || '',
          timestamp: Date.now()
        };
        
        this.undoStack.push(state);
        if (this.undoStack.length > this.maxStackSize) {
          this.undoStack.shift();
        }
        
        // Clear redo stack on new action
        this.redoStack = [];
        
        console.log('State saved:', description);
      },
      
      undo() {
        if (this.undoStack.length === 0) {
          TechBot.notify('No actions to undo');
          return;
        }
        
        // Save current state to redo stack
        const currentState = {
          studyPlanHTML: document.getElementById('studyPlanDisplay')?.innerHTML || '',
          courseListHTML: document.getElementById('courseList')?.innerHTML || '',
          timestamp: Date.now()
        };
        this.redoStack.push(currentState);
        
        // Restore previous state
        const previousState = this.undoStack.pop();
        document.getElementById('studyPlanDisplay').innerHTML = previousState.studyPlanHTML;
        document.getElementById('courseList').innerHTML = previousState.courseListHTML;
        
        // Reinitialize drag and drop
        if (window.initializeDragAndDrop) {
          window.initializeDragAndDrop();
        }
        
        TechBot.notify(`Undone: ${previousState.description}`);
      },
      
      redo() {
        if (this.redoStack.length === 0) {
          TechBot.notify('No actions to redo');
          return;
        }
        
        // Save current state to undo stack
        const currentState = {
          studyPlanHTML: document.getElementById('studyPlanDisplay')?.innerHTML || '',
          courseListHTML: document.getElementById('courseList')?.innerHTML || '',
          timestamp: Date.now()
        };
        this.undoStack.push(currentState);
        
        // Restore next state
        const nextState = this.redoStack.pop();
        document.getElementById('studyPlanDisplay').innerHTML = nextState.studyPlanHTML;
        document.getElementById('courseList').innerHTML = nextState.courseListHTML;
        
        // Reinitialize drag and drop
        if (window.initializeDragAndDrop) {
          window.initializeDragAndDrop();
        }
        
        TechBot.notify('Action redone');
      }
    };
    
    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', (e) => {
      // Ctrl+Z or Cmd+Z for undo
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        UndoRedoManager.undo();
      }
      
      // Ctrl+Y or Cmd+Y for redo
      if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        UndoRedoManager.redo();
      }
      
      // Ctrl+Shift+Z for redo (alternative)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') {
        e.preventDefault();
        UndoRedoManager.redo();
      }
    });

    // ============================================================
    // COURSE CONSTRAINTS VALIDATION
    // ============================================================
    
    const CourseConstraints = {
      // Check if course can be added to a semester
      canAddCourse(courseName, semesterType, semesterNumber, completedCredits, completedCourses) {
        const normalizedName = courseName.trim();
        
        // Summer Training constraints
        if (normalizedName.includes('Summer Training') || normalizedName.includes('Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ØµÙŠÙÙŠ')) {
          if (semesterType !== 'Summer') {
            return {
              allowed: false,
              reason: 'Summer Training can only be added to summer semesters.'
            };
          }
          if (completedCredits < 60) {
            return {
              allowed: false,
              reason: `Summer Training requires at least 60 credit hours. You currently have ${completedCredits} hours.`
            };
          }
        }
        
        // Project 1 constraints
        if (normalizedName.includes('Project 1') || normalizedName.includes('Ù…Ø´Ø±ÙˆØ¹ 1')) {
          if (semesterType === 'Even') {
            return {
              allowed: false,
              reason: 'Project 1 can only be taken in odd semesters (Fall).'
            };
          }
          if (semesterType === 'Summer') {
            return {
              allowed: false,
              reason: 'Project 1 cannot be taken in summer semesters.'
            };
          }
          if (completedCredits < 85) {
            return {
              allowed: false,
              reason: `Project 1 requires at least 85 credit hours. You currently have ${completedCredits} hours.`
            };
          }
        }
        
        // Project 2 constraints
        if (normalizedName.includes('Project 2') || normalizedName.includes('Ù…Ø´Ø±ÙˆØ¹ 2')) {
          if (semesterType === 'Odd') {
            return {
              allowed: false,
              reason: 'Project 2 can only be taken in even semesters (Spring).'
            };
          }
          if (semesterType === 'Summer') {
            return {
              allowed: false,
              reason: 'Project 2 cannot be taken in summer semesters.'
            };
          }
          
          // Check if Project 1 is completed
          const hasProject1 = completedCourses.some(course => 
            course.includes('Project 1') || course.includes('Ù…Ø´Ø±ÙˆØ¹ 1')
          );
          
          if (!hasProject1) {
            return {
              allowed: false,
              reason: 'Project 2 requires completion of Project 1 first.'
            };
          }
        }
        
        return { allowed: true };
      },
      
      // Calculate completed credits from semesters before current
      calculateCompletedCredits(allSemesters, currentSemesterIndex) {
        let credits = 0;
        for (let i = 0; i < currentSemesterIndex; i++) {
          const semester = allSemesters[i];
          const courses = semester.querySelectorAll('.semester-course-item');
          courses.forEach(course => {
            const creditMatch = course.textContent.match(/\((\d+)\s*(?:Ø³Ø§Ø¹Ø©|hours?)\)/i);
            if (creditMatch) {
              credits += parseInt(creditMatch[1]);
            }
          });
        }
        return credits;
      },
      
      // Get completed courses from previous semesters
      getCompletedCourses(allSemesters, currentSemesterIndex) {
        const courses = [];
        for (let i = 0; i < currentSemesterIndex; i++) {
          const semester = allSemesters[i];
          const courseElements = semester.querySelectorAll('.semester-course-item');
          courseElements.forEach(el => {
            courses.push(el.textContent.trim());
          });
        }
        return courses;
      }
    };

    // ============================================================
    // EXPORT STUDY PLAN AS PDF (using html2pdf.js)
    // ============================================================
    function exportStudyPlanAsPDF() {
      const planDisplay = document.getElementById('studyPlanDisplay');
      const studentInfo = document.getElementById('studentInfo');
      
      if (!planDisplay || planDisplay.innerHTML.trim() === '') {
        TechBot.error('Please generate a study plan first before exporting!');
        return;
      }
      
      TechBot.notify('Initializing PDF export sequence...');
      
      // Build print-friendly container
      const printWrapper = document.createElement('div');
      printWrapper.id = 'pdf-export-wrapper';
      printWrapper.style.cssText = 'font-family: Inter, sans-serif; padding: 24px; color: #0f172a; background: white; width: 794px; min-height: 500px;';
      
      // Header
      const header = document.createElement('div');
      header.style.cssText = 'border-bottom: 3px solid #2563eb; padding-bottom: 16px; margin-bottom: 24px;';
      header.innerHTML = `
        <h1 style="margin:0; font-size:22px; font-weight:700; color:#0f172a;">ðŸŽ“ Personalized Study Plan</h1>
        <p style="margin:6px 0 0; font-size:14px; color:#64748b;">Generated on ${new Date().toLocaleDateString('en-US', {year:'numeric', month:'long', day:'numeric'})}</p>
      `;
      printWrapper.appendChild(header);
      
      // Student info if available
      if (studentInfo && studentInfo.style.display !== 'none') {
        const infoClone = studentInfo.cloneNode(true);
        infoClone.style.cssText = 'background:#f0f9ff; border:1px solid #bae6fd; border-radius:12px; padding:14px 18px; margin-bottom:20px; display:block;';
        // Make sure all child elements are visible
        infoClone.querySelectorAll('*').forEach(el => {
          if (el.style.display === 'none') el.style.display = 'block';
        });
        printWrapper.appendChild(infoClone);
      }
      
      // Stats
      const statsEl = document.getElementById('statsContainer');
      if (statsEl && statsEl.style.display !== 'none') {
        const statsClone = statsEl.cloneNode(true);
        statsClone.style.cssText = 'display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-bottom:20px;';
        // Style each stat card
        statsClone.querySelectorAll('.stat-card').forEach(card => {
          card.style.cssText = 'background:#f8fafc; border:1px solid #e2e8f0; border-radius:12px; padding:14px; break-inside:avoid; display:block;';
        });
        // Remove SVG ring as it may not render well in PDF
        const ringSvg = statsClone.querySelector('.ring-svg');
        if (ringSvg) ringSvg.remove();
        printWrapper.appendChild(statsClone);
      }
      
      // Plan
      const planClone = planDisplay.cloneNode(true);
      planClone.style.display = 'block';
      planClone.style.visibility = 'visible';
      
      // Remove buttons from clone
      planClone.querySelectorAll('.semester-actions, .add-summer-after-btn, .delete-semester-btn, .course-drag-handle, .reset-plan-btn, .export-btn').forEach(el => el.remove());
      
      // Style semester cards
      planClone.querySelectorAll('.semester-card').forEach(card => {
        card.style.cssText = 'page-break-inside:avoid; margin-bottom:12px; border:1px solid #e2e8f0; border-radius:12px; padding:14px; background:#f8faff; border-left:4px solid #2563eb; display:block; visibility:visible;';
        // Make all children visible
        card.querySelectorAll('*').forEach(el => {
          if (el.style.display === 'none') el.style.display = 'block';
          el.style.visibility = 'visible';
        });
      });
      
      // Style course items
      planClone.querySelectorAll('.semester-course-item').forEach(item => {
        item.style.cssText = 'background:white; padding:8px 12px; border-radius:6px; font-size:13px; border-left:3px solid #2563eb; margin-bottom:6px; display:block; visibility:visible;';
      });
      
      printWrapper.appendChild(planClone);
      
      // Show loading state
      const fabBtn = document.getElementById('fabExportPdf');
      const origText = fabBtn.innerHTML;
      fabBtn.innerHTML = 'â³ Generating PDF...';
      fabBtn.disabled = true;
      
      // Add to document with temporary visibility
      document.body.appendChild(printWrapper);
      printWrapper.style.position = 'fixed';
      printWrapper.style.left = '0';
      printWrapper.style.top = '0';
      printWrapper.style.zIndex = '-9999';
      printWrapper.style.opacity = '0';
      printWrapper.style.pointerEvents = 'none';
      
      // PDF options
      const opt = {
        margin: [10, 10, 10, 10],
        filename: `study-plan-${new Date().toISOString().split('T')[0]}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { 
          scale: 2, 
          useCORS: true, 
          letterRendering: true,
          logging: false,
          backgroundColor: '#ffffff'
        },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      };
      
      // Generate PDF with a small delay to ensure rendering
      setTimeout(() => {
        html2pdf().set(opt).from(printWrapper).save().then(() => {
          document.body.removeChild(printWrapper);
          fabBtn.innerHTML = 'âœ… PDF Saved!';
          TechBot.success('PDF exported successfully! Download should start automatically.');
          setTimeout(() => {
            fabBtn.innerHTML = origText;
            fabBtn.disabled = false;
          }, 2500);
        }).catch(err => {
          console.error('PDF error:', err);
          if (document.body.contains(printWrapper)) {
            document.body.removeChild(printWrapper);
          }
          fabBtn.innerHTML = origText;
          fabBtn.disabled = false;
          TechBot.error('PDF generation failed. Please try again or use browser print (Ctrl+P).');
        });
      }, 100);
    }

    // ============================================================
    // GRADUATION PROGRESS RING (updates whenever stats update)
    // ============================================================
    function updateProgressRing(percent) {
      const ring = document.getElementById('progressRing');
      const ringText = document.getElementById('progressRingText');
      if (!ring) return;
      
      const radius = 36;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percent / 100) * circumference;
      ring.style.strokeDasharray = circumference;
      ring.style.strokeDashoffset = offset;
      if (ringText) ringText.textContent = Math.round(percent) + '%';
    }

    // Patch calculateStatistics to also update ring
    const _origCalcStats = window.calculateStatistics;
    // We'll override after DOM is ready via MutationObserver on creditPercentage
    const ringObserver = new MutationObserver(function() {
      const pctEl = document.getElementById('creditPercentage');
      if (pctEl) {
        const match = pctEl.textContent.match(/([\d.]+)%/);
        if (match) updateProgressRing(parseFloat(match[1]));
      }
    });
    document.addEventListener('DOMContentLoaded', function() {
      const pctEl = document.getElementById('creditPercentage');
      if (pctEl) ringObserver.observe(pctEl, { childList: true, characterData: true, subtree: true });
    });
  </script>

</body></html>
