<!DOCTYPE html>
<!-- saved from url=(0044)file:///C:/Users/Amr1/Desktop/CSCourses.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } 
</style>
    <style>
      /* ============================================================
         MODERN 2025 UI DESIGN SYSTEM
         - Inter typography
         - Glassmorphism panels
         - Soft color palette
         - Micro-animations
         - Card-based layout
      ============================================================ */

      :root {
        --bg-primary: #f0f4ff;
        --bg-secondary: #ffffff;
        --accent: #2563eb;
        --accent-dark: #1d4ed8;
        --accent-light: #eff6ff;
        --success: #22c55e;
        --success-bg: #f0fdf4;
        --warning: #f97316;
        --warning-bg: #fff7ed;
        --danger: #ef4444;
        --danger-bg: #fef2f2;
        --text-primary: #0f172a;
        --text-secondary: #475569;
        --text-muted: #94a3b8;
        --border: #e2e8f0;
        --shadow-sm: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
        --shadow-md: 0 4px 16px rgba(0,0,0,0.06), 0 2px 8px rgba(0,0,0,0.04);
        --shadow-lg: 0 20px 40px rgba(0,0,0,0.10), 0 8px 16px rgba(0,0,0,0.06);
        --radius-sm: 8px;
        --radius-md: 16px;
        --radius-lg: 24px;
        --glass-bg: rgba(255,255,255,0.72);
        --glass-border: rgba(255,255,255,0.5);
        --glass-blur: blur(16px);
      }

      * { box-sizing: border-box; }

      body {
        font-family: 'Inter', 'Segoe UI', sans-serif;
        background: linear-gradient(135deg, #1e3a8a 0%, #1e293b 100%);
        background-attachment: fixed;
        min-height: 100vh;
        margin: 0;
        padding: 20px;
        padding-top: 80px;
        padding-bottom: 80px;
        scroll-behavior: smooth;
        color: var(--text-primary);
      }

      /* ---- Navbar ---- */
      h2 {
        text-align: center;
        font-family: 'Poppins', 'Inter', sans-serif;
        font-size: 18px;
        font-weight: 600;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        margin: 0;
        padding: 0 20px;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border-bottom: 1px solid var(--glass-border);
        box-shadow: 0 4px 24px rgba(0,0,0,0.12);
        z-index: 1000;
        color: var(--text-primary);
        letter-spacing: -0.3px;
      }

      /* ---- Course Table ---- */
      .course {
        border: 1px solid var(--border);
        text-align: center;
        padding: 8px 6px;
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
        font-size: 13px;
        border-radius: 4px;
      }

      .course:hover {
        opacity: 0.88;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      }

      .header {
        text-align: center;
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        color: white;
        font-weight: 600;
        font-size: 13px;
        padding: 10px 8px;
        border-radius: 6px;
        border: none;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        letter-spacing: 0.3px;
      }

      .prev { background-color: #ede9fe; color: #5b21b6; }
      .direct { background-color: #dbeafe; color: #1d4ed8; }
      .selected { background-color: #d1fae5; color: #065f46; }
      .next { background-color: #fef3c7; color: #92400e; }

      input { margin-top: 7px; }

      /* ---- Legend ---- */
      #legend {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
        margin: 0;
        padding: 12px 16px;
        width: fit-content;
      }

      #legend tbody {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      #legend tr {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      #legend td {
        padding: 4px 6px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      #legend td:first-child {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
        border-radius: 4px;
        padding: 0;
      }

      #legend td:last-child {
        white-space: nowrap;
      }

      #courses_table {
        margin-bottom: 0;
        border-radius: var(--radius-md);
        overflow: hidden;
      }

      /* ---- Toggle container ---- */
      .legend-toggle-container {
        display: flex;
        align-items: center;
        gap: 24px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      /* ---- Toggle Switch ---- */
      .switch {
        position: relative;
        display: inline-block;
        line-height: 26px;
        width: 48px;
        height: 26px;
        margin: 0;
        flex-shrink: 0;
      }

      .switch input { opacity: 0; width: 0; height: 0; }

      .slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background-color: #cbd5e1;
        border-radius: 26px;
        transition: 0.3s;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 4px;
        bottom: 4px;
        background: white;
        transition: 0.3s;
        border-radius: 50%;
        box-shadow: 0 1px 4px rgba(0,0,0,0.15);
      }

      input:checked + .slider { background-color: var(--accent); }
      input:focus + .slider { box-shadow: 0 0 0 3px rgba(37,99,235,0.2); }
      input:checked + .slider:before { transform: translateX(22px); }

      /* ============================================================
         TECHBOT NOTIFICATION SYSTEM
      ============================================================ */
      
      /* Toast Notification (Bottom Right) */
      #techbot-toast {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 10000;
        display: flex;
        align-items: flex-end;
        gap: 15px;
        max-width: 400px;
        transform: translateX(500px);
        transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      #techbot-toast.show {
        transform: translateX(0);
      }

      .bot-character {
        flex-shrink: 0;
        width: 72px;
        height: 72px;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 56px;
        animation: headFloat 2.5s ease-in-out infinite;
      }
      
      .robot-mouth-overlay {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        width: 20px;
        height: 5px;
        background: #1f2937;
        border-radius: 2px;
        pointer-events: none;
      }

      .toast-message {
        background: linear-gradient(135deg, #1e293b, #0f172a);
        padding: 14px 18px 14px 16px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.35), 0 0 0 1px rgba(99,179,237,0.15);
        border: 1px solid rgba(99,179,237,0.25);
        position: relative;
        max-width: 280px;
        backdrop-filter: blur(8px);
      }

      .toast-message::before {
        content: '';
        position: absolute;
        bottom: 22px;
        left: -8px;
        width: 0;
        height: 0;
        border-style: solid;
        border-width: 7px 8px 7px 0;
        border-color: transparent #1e293b transparent transparent;
      }

      .toast-message-title {
        font-weight: 700;
        color: #60a5fa;
        margin-bottom: 5px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        font-family: 'Poppins', sans-serif;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .toast-message-text {
        color: #e2e8f0;
        font-size: 14px;
        line-height: 1.7;
        font-family: 'Inter', sans-serif;
        font-weight: 400;
        letter-spacing: 0.01em;
      }
      
      .toast-message-text strong {
        color: #60a5fa;
        font-weight: 600;
      }

      /* Modal Dialog with Bot */
      #techbot-modal {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(4px);
        z-index: 10001;
        display: none;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
      }

      #techbot-modal.show {
        display: flex;
      }

      .modal-content {
        background: white;
        border-radius: 24px;
        padding: 40px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        position: relative;
        animation: slideUp 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slideUp {
        from { 
          transform: translateY(50px);
          opacity: 0;
        }
        to { 
          transform: translateY(0);
          opacity: 1;
        }
      }

      .modal-bot {
        text-align: center;
        margin-bottom: 24px;
      }

      .modal-bot svg {
        width: 100px;
        height: 120px;
        margin: 0 auto;
      }

      .modal-message {
        text-align: center;
        margin-bottom: 24px;
      }

      .modal-message h3 {
        color: #2563eb;
        font-size: 17px;
        font-weight: 700;
        margin-bottom: 12px;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -0.3px;
      }

      .modal-message p {
        color: #374151;
        font-size: 15px;
        line-height: 1.8;
        font-family: 'Inter', sans-serif;
        white-space: pre-wrap;
        letter-spacing: 0.01em;
      }
      
      .modal-message p strong {
        color: #2563eb;
        font-weight: 600;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
      }

      .modal-btn {
        padding: 12px 28px;
        border-radius: 12px;
        border: none;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .modal-btn-primary {
        background: linear-gradient(135deg, #2563eb, #3b82f6);
        color: white;
        box-shadow: 0 4px 12px rgba(37,99,235,0.3);
      }

      .modal-btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(37,99,235,0.4);
      }

      .modal-btn-secondary {
        background: #f3f4f6;
        color: #4b5563;
      }

      .modal-btn-secondary:hover {
        background: #e5e7eb;
      }

      /* ============================================================
         ROBOT ANIMATIONS
      ============================================================ */
      
      /* Speaking mouth — active when toast is visible */
      #techbot-toast.show .robot-mouth-overlay,
      #techbot-modal.show .robot-mouth-overlay {
        animation: mouthSpeak 0.2s ease-in-out infinite;
      }

      @keyframes headFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-4px); }
      }
      
      @keyframes mouthSpeak {
        0%, 100% { height: 5px; }
        50% { height: 2px; }
      }

      #div_sel {
        color: var(--text-muted);
        margin: 10px 0;
        font-size: 13px;
      }

      /* ---- Panels / Cards ---- */
      #courses_table {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-md);
        margin: 0 auto 0 auto;
        padding: 16px;
      }

      .select-multiple-container {
        text-align: center;
        display: flex;
        align-items: center;
        gap: 10px;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        padding: 12px 18px;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        box-shadow: var(--shadow-sm);
        width: fit-content;
      }

      .upload-container {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        margin: 20px auto;
        padding: 28px;
        max-width: 1200px;
      }

      .courses-section {
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        margin: 20px auto;
        padding: 24px;
        max-width: 1400px;
      }

      /* ---- Upload Box ---- */
      .upload-box {
        background: linear-gradient(135deg, rgba(239,246,255,0.9), rgba(219,234,254,0.9));
        border-radius: var(--radius-lg);
        padding: 48px 24px;
        text-align: center;
        border: 2px dashed #93c5fd;
        transition: all 0.3s ease;
        cursor: pointer;
        max-width: 600px;
        margin: 0 auto;
      }

      .upload-box:hover {
        border-color: var(--accent);
        background: linear-gradient(135deg, rgba(219,234,254,0.95), rgba(199,220,254,0.95));
        transform: translateY(-3px);
        box-shadow: 0 12px 32px rgba(37,99,235,0.18);
      }

      .upload-box input[type="file"] { display: none; }

      .upload-label {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 14px 40px;
        background: linear-gradient(135deg, var(--accent) 0%, #1d4ed8 100%);
        color: white;
        border-radius: var(--radius-md);
        font-weight: 600;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s ease;
        pointer-events: none;
        box-shadow: 0 4px 16px rgba(37,99,235,0.35);
        letter-spacing: -0.2px;
      }

      .upload-hint {
        margin-top: 16px;
        color: var(--text-secondary);
        font-size: 15px;
        font-weight: 500;
      }

      /* ---- Stat Cards ---- */
      .stats-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-top: 24px;
      }

      .stat-card {
        background: white;
        border-radius: var(--radius-md);
        padding: 24px 20px;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        position: relative;
        overflow: hidden;
      }

      .stat-card::before {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--accent), #818cf8);
        border-radius: 3px 3px 0 0;
      }

      .stat-card:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow-lg);
      }

      .stat-card h3 {
        margin: 0 0 10px 0;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }

      .stat-value {
        font-size: 34px;
        font-weight: 700;
        color: var(--accent);
        margin-bottom: 8px;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -1px;
      }

      .stat-label {
        font-size: 13px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* ---- Progress Bars ---- */
      .progress-bar {
        width: 100%;
        height: 6px;
        background: #e2e8f0;
        border-radius: 99px;
        overflow: hidden;
        margin-top: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent) 0%, #818cf8 100%);
        border-radius: 99px;
        transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* ---- Graduation Ring ---- */
      .graduation-ring-container {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-top: 12px;
      }

      .ring-svg { flex-shrink: 0; }

      .ring-bg { fill: none; stroke: #e2e8f0; stroke-width: 8; }
      .ring-fill {
        fill: none;
        stroke: url(#ringGrad);
        stroke-width: 8;
        stroke-linecap: round;
        transition: stroke-dashoffset 1s cubic-bezier(0.4,0,0.2,1);
        transform: rotate(-90deg);
        transform-origin: center;
      }

      /* ---- Remaining Courses ---- */
      .remaining-courses {
        background: white;
        border-radius: var(--radius-md);
        padding: 24px;
        margin-top: 20px;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
      }

      .remaining-courses h3 {
        margin: 0 0 18px 0;
        color: var(--text-primary);
        font-size: 17px;
        font-weight: 600;
        font-family: 'Poppins', sans-serif;
      }

      .course-list { display: grid; gap: 8px; }

      .course-item {
        padding: 12px 16px;
        border-radius: var(--radius-sm);
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.2s ease;
        cursor: grab;
      }

      .course-item:hover { transform: translateX(4px); }

      .course-item.available {
        background: var(--success-bg);
        border-left: 3px solid var(--success);
      }

      .course-item.locked {
        background: #fff5f5;
        border-left: 3px solid #fc8181;
      }

      .course-item-name { font-weight: 600; color: var(--text-primary); font-size: 14px; }
      .course-item-code { font-size: 12px; color: var(--text-muted); margin-left: 8px; }

      .course-item-hours {
        background: linear-gradient(135deg, var(--accent), #818cf8);
        color: white;
        padding: 4px 12px;
        border-radius: 99px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
      }

      /* ---- Study Plan ---- */
      .study-plan-container {
        background: white;
        border-radius: var(--radius-md);
        padding: 24px;
        margin-top: 20px;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border);
      }

      .study-plan-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 12px;
      }

      .study-plan-header h3 {
        margin: 0;
        color: var(--text-primary);
        font-size: 18px;
        font-weight: 700;
        font-family: 'Poppins', sans-serif;
      }

      .plan-selector { display: flex; gap: 8px; flex-wrap: wrap; }

      .plan-option {
        padding: 8px 18px;
        border: 2px solid var(--accent);
        background: white;
        color: var(--accent);
        border-radius: 99px;
        cursor: pointer;
        font-weight: 600;
        font-size: 13px;
        transition: all 0.2s ease;
      }

      .plan-option.active,
      .plan-option:hover {
        background: var(--accent);
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(37,99,235,0.25);
      }

      .generate-plan-btn {
        background: linear-gradient(135deg, var(--accent) 0%, #1d4ed8 100%);
        color: white;
        border: none;
        padding: 12px 28px;
        border-radius: 99px;
        font-weight: 700;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 16px rgba(37,99,235,0.35);
        letter-spacing: -0.2px;
      }

      .generate-plan-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 24px rgba(37,99,235,0.45);
      }

      /* ---- Semester Cards ---- */
      .semester-card {
        background: #f8faff;
        border-radius: var(--radius-md);
        padding: 20px;
        margin-bottom: 16px;
        border: 1px solid #e2e8f0;
        border-left: 4px solid var(--accent);
        transition: all 0.25s ease;
        position: relative;
      }

      .semester-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(37,99,235,0.10);
      }

      .semester-card.invalid-drop { background-color: #fef2f2; }

      /* Incomplete semester — warm amber left border */
      .semester-card.has-incomplete-semester {
        border-left: 4px solid #d97706 !important;
        background: #fffbf5 !important;
      }

      /* Incomplete course items in plan */
      .semester-course-item.incomplete-course-item {
        background: linear-gradient(90deg, #fff7ed, #fffbf5) !important;
        border-left: 3px solid #d97706 !important;
      }

      .semester-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 14px;
        flex-wrap: wrap;
        gap: 8px;
      }

      .semester-title {
        font-weight: 700;
        color: var(--text-primary);
        font-size: 15px;
        font-family: 'Poppins', sans-serif;
      }

      .semester-hours {
        background: linear-gradient(135deg, var(--accent), #818cf8);
        color: white;
        padding: 5px 14px;
        border-radius: 99px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
      }

      .semester-courses {
        display: grid;
        gap: 8px;
        min-height: 64px;
        padding: 10px;
        border-radius: var(--radius-sm);
        transition: all 0.2s ease;
        background: rgba(255,255,255,0.7);
        border: 1px dashed transparent;
      }

      .semester-courses.drag-over {
        background-color: var(--accent-light);
        border-color: var(--accent);
      }

      .semester-course-item {
        background: white;
        padding: 10px 14px;
        border-radius: var(--radius-sm);
        font-size: 13px;
        color: var(--text-secondary);
        border-left: 3px solid var(--accent);
        cursor: grab;
        transition: all 0.2s ease;
        user-select: none;
        box-shadow: var(--shadow-sm);
        display: flex;
        align-items: center;
      }

      .semester-course-item:hover {
        background: #f0f9ff;
        box-shadow: 0 4px 12px rgba(37,99,235,0.12);
        transform: translateY(-1px);
      }

      .semester-course-item:active { cursor: grabbing; }

      .semester-course-item.dragging {
        opacity: 0.45;
        transform: scale(0.96);
      }

      .semester-course-code {
        font-weight: 700;
        color: var(--accent);
        margin-right: 8px;
        font-size: 12px;
        background: #eff6ff;
        padding: 2px 8px;
        border-radius: 99px;
      }

      .course-drag-handle {
        color: #cbd5e1;
        margin-right: 8px;
        font-size: 16px;
        flex-shrink: 0;
      }

      .plan-summary {
        background: linear-gradient(135deg, #f0fdf4, #dcfce7);
        padding: 18px 20px;
        border-radius: var(--radius-md);
        margin-top: 20px;
        border-left: 4px solid var(--success);
        border: 1px solid #bbf7d0;
      }

      .plan-summary-title {
        font-weight: 700;
        color: #166534;
        margin-bottom: 12px;
        font-size: 15px;
        font-family: 'Poppins', sans-serif;
      }

      .plan-summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* ---- Summer Semester ---- */
      .summer-semester {
        background: linear-gradient(135deg, #fffbeb, #fef9e7) !important;
        border-left-color: var(--warning) !important;
        border-color: #fde68a !important;
      }

      .summer-semester .semester-hours {
        background: linear-gradient(135deg, var(--warning), #ea580c) !important;
      }

      .summer-semester .semester-course-item {
        border-left-color: var(--warning);
      }

      .summer-semester .semester-course-code {
        color: var(--warning);
        background: #fff7ed;
      }

      /* ---- Action Buttons ---- */
      .semester-actions {
        display: flex;
        gap: 10px;
        align-items: flex-start;
        margin-top: 4px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      #validationMessage { flex: 1 1 100%; min-width: 100%; }

      .reset-plan-btn {
        background: white;
        color: var(--warning);
        border: 2px solid #fed7aa;
        padding: 8px 18px;
        border-radius: 99px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .reset-plan-btn:hover {
        background: #fff7ed;
        border-color: var(--warning);
        transform: translateY(-1px);
      }

      .export-btn {
        background: linear-gradient(135deg, var(--success), #16a34a);
        color: white;
        border: none;
        padding: 8px 18px;
        border-radius: 99px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.25s;
        box-shadow: 0 2px 8px rgba(34,197,94,0.25);
      }

      .export-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(34,197,94,0.35);
      }

      .export-btn.xlsx {
        background: linear-gradient(135deg, var(--accent), #1d4ed8);
        box-shadow: 0 2px 8px rgba(37,99,235,0.25);
      }

      .export-btn.xlsx:hover {
        box-shadow: 0 6px 16px rgba(37,99,235,0.35);
      }

      .export-btn.pdf-btn {
        background: linear-gradient(135deg, #dc2626, #b91c1c);
        box-shadow: 0 2px 8px rgba(220,38,38,0.25);
      }

      .export-btn.pdf-btn:hover {
        box-shadow: 0 6px 16px rgba(220,38,38,0.35);
      }

      /* ---- Program Selector ---- */
      .program {
        cursor: pointer;
        font-size: 22px;
        font-weight: 600;
        color: #94a3b8;
        transition: all 0.25s ease;
        padding: 4px 14px;
        border-radius: var(--radius-sm);
        font-family: 'Poppins', sans-serif;
      }

      .program:hover { background: rgba(37,99,235,0.08); color: var(--accent); }
      .program.active { color: var(--accent); background: rgba(37,99,235,0.1); }

      /* ---- Buttons (summer add / delete) ---- */
      .add-summer-btn {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        color: #1c1917;
        border: none;
        padding: 10px 20px;
        border-radius: 99px;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        margin: 10px 0;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(251,191,36,0.3);
      }

      .add-summer-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(251,191,36,0.4);
      }

      .add-summer-after-btn {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        color: #1c1917;
        border: none;
        padding: 6px 16px;
        border-radius: 99px;
        font-weight: 700;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(251,191,36,0.3);
      }

      .add-summer-after-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(251,191,36,0.4);
      }

      .delete-semester-btn {
        background: #fee2e2;
        color: var(--danger);
        border: 1px solid #fca5a5;
        padding: 5px 12px;
        border-radius: 99px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        margin-left: 10px;
        transition: all 0.2s;
      }

      .delete-semester-btn:hover {
        background: var(--danger);
        color: white;
        border-color: var(--danger);
      }

      /* ---- Validation Messages ---- */
      .validation-message {
        background: #fefce8;
        border: 1px solid #fde047;
        color: #713f12;
        padding: 12px 16px;
        border-radius: var(--radius-sm);
        margin: 10px 0;
        font-size: 13px;
        font-weight: 500;
        display: none;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from { opacity: 0; transform: translateY(-8px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .validation-message.error { background: var(--danger-bg); border-color: #fca5a5; color: #991b1b; }
      .validation-message.success { background: var(--success-bg); border-color: #86efac; color: #166534; }
      .validation-message.info { background: #eff6ff; border-color: #93c5fd; color: #1e40af; }

      /* ---- Student Info ---- */
      .student-info {
        background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
        border-radius: var(--radius-md);
        padding: 18px 20px;
        margin-top: 16px;
        border: 1px solid #bae6fd;
      }

      .student-info h4 {
        margin: 0 0 10px 0;
        color: var(--accent);
        font-size: 14px;
        font-weight: 700;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -0.2px;
      }

      .student-info p {
        margin: 5px 0;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* ---- Debug Log ---- */
      .debug-line { padding: 4px 0; border-bottom: 1px solid #1e293b; font-size: 12px; }
      .debug-success { color: #4ade80; }
      .debug-error { color: #f87171; }
      .debug-warning { color: #fbbf24; }

      /* ---- Floating Action Buttons ---- */
      .fab-container {
        position: fixed;
        bottom: 28px;
        right: 28px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 12px;
        z-index: 999;
      }

      .fab-btn {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px 22px;
        border-radius: 99px;
        border: none;
        font-family: 'Inter', sans-serif;
        font-weight: 700;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        white-space: nowrap;
        letter-spacing: -0.2px;
      }

      .fab-btn:hover {
        transform: translateY(-4px) scale(1.03);
        box-shadow: 0 16px 36px rgba(0,0,0,0.28);
      }

      .fab-btn:active { transform: translateY(-1px) scale(0.99); }

      .fab-pdf {
        background: linear-gradient(135deg, #dc2626, #b91c1c);
        color: white;
      }

      .fab-generate {
        background: linear-gradient(135deg, var(--accent), #1d4ed8);
        color: white;
      }

      /* ---- Progress Ring Stat Card ---- */
      .stat-card.ring-card {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .ring-info { flex: 1; }

      /* ---- Graduation Timeline ---- */
      .graduation-timeline {
        display: flex;
        align-items: center;
        gap: 0;
        overflow-x: auto;
        padding: 16px 0 8px;
        margin-top: 4px;
        scrollbar-width: thin;
      }

      .timeline-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        min-width: 90px;
      }

      .timeline-step:not(:last-child)::after {
        content: '';
        position: absolute;
        top: 15px;
        left: 50%;
        width: 100%;
        height: 2px;
        background: #e2e8f0;
        z-index: 0;
      }

      .timeline-step.completed:not(:last-child)::after {
        background: linear-gradient(90deg, var(--success), var(--accent));
      }

      .timeline-dot {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 3px solid #e2e8f0;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 700;
        position: relative;
        z-index: 1;
        transition: all 0.3s ease;
        color: #94a3b8;
      }

      .timeline-step.completed .timeline-dot {
        background: linear-gradient(135deg, var(--success), var(--accent));
        border-color: transparent;
        color: white;
        box-shadow: 0 4px 12px rgba(34,197,94,0.4);
      }

      .timeline-step.current .timeline-dot {
        background: linear-gradient(135deg, var(--accent), #818cf8);
        border-color: transparent;
        color: white;
        box-shadow: 0 4px 16px rgba(37,99,235,0.5);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%, 100% { box-shadow: 0 0 0 0 rgba(37,99,235,0.4); }
        50% { box-shadow: 0 0 0 8px rgba(37,99,235,0); }
      }

      @keyframes incompletePulse {
        0%, 100% { box-shadow: 0 0 0 0 rgba(217,119,6,0.5); }
        50% { box-shadow: 0 0 0 4px rgba(217,119,6,0); }
      }

      .timeline-label {
        margin-top: 8px;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-align: center;
        max-width: 80px;
      }

      .timeline-step.completed .timeline-label { color: var(--success); }
      .timeline-step.current .timeline-label { color: var(--accent); }

      /* ---- Special Case Star Toggle ---- */
      .special-case-toggle {
        background: transparent;
        border: 1.5px solid #cbd5e1;
        border-radius: 99px;
        padding: 3px 10px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        color: #94a3b8;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        font-family: 'Inter', sans-serif;
      }
      .special-case-toggle:hover {
        border-color: #d4af37;
        color: #b8930a;
        background: #fef9e7;
      }
      .special-case-toggle.active {
        background: linear-gradient(135deg, #fef8e6, #fdf4d8);
        border-color: #d4af37;
        color: #8b7300;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
      }
      .special-case-toggle.active:hover {
        background: linear-gradient(135deg, #fdf4d8, #fcefc5);
        box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
      }

      /* ---- Special Case Semester Card ---- */
      .semester-card.special-case-active {
        border-left-color: #d4af37 !important;
        background: linear-gradient(135deg, #fef9e7, #fdf5dc) !important;
        box-shadow: 0 4px 12px rgba(212, 175, 55, 0.15) !important;
      }
      .summer-semester.special-case-active {
        background: linear-gradient(135deg, #fef8e6, #fdf4d8) !important;
      }
      
      /* Special case hours badge */
      .special-case-active .semester-hours {
        background: linear-gradient(135deg, #d4af37, #c19a2e) !important;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
      }
      .course-remove-btn {
        background: transparent;
        border: none;
        color: #cbd5e1;
        cursor: pointer;
        font-size: 14px;
        font-weight: 700;
        padding: 2px 6px;
        border-radius: 4px;
        line-height: 1;
        transition: all 0.15s ease;
        margin-left: auto;
        flex-shrink: 0;
      }
      .course-remove-btn:hover {
        background: #fee2e2;
        color: var(--danger);
      }

      /* ---- Semester Footer (Gained / Remaining) ---- */
      .semester-footer {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        padding: 8px 12px;
        background: rgba(37,99,235,0.05);
        border-radius: var(--radius-sm);
        border: 1px solid rgba(37,99,235,0.12);
        font-size: 13px;
        color: var(--text-secondary);
      }
      .summer-semester .semester-footer {
        background: rgba(249,115,22,0.06);
        border-color: rgba(249,115,22,0.15);
      }
      .footer-gained strong { color: #16a34a; }
      .footer-remaining strong { color: var(--accent); }
      .footer-sep { color: var(--border); }

      /* ---- Toast Notification ---- */
      #toastContainer {
        position: fixed;
        bottom: 90px;
        right: 28px;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-end;
        pointer-events: none;
      }
      .toast-msg {
        padding: 12px 18px;
        border-radius: var(--radius-sm);
        font-size: 13px;
        font-weight: 600;
        max-width: 380px;
        box-shadow: var(--shadow-lg);
        animation: toastIn 0.3s ease forwards;
        pointer-events: auto;
      }
      .toast-msg.error   { background: var(--danger-bg); border-left: 4px solid var(--danger); color: #991b1b; }
      .toast-msg.success { background: var(--success-bg); border-left: 4px solid var(--success); color: #166534; }
      .toast-msg.info    { background: #eff6ff; border-left: 4px solid var(--accent); color: #1e40af; }
      .toast-msg.warning { background: var(--warning-bg); border-left: 4px solid var(--warning); color: #92400e; }
      @keyframes toastIn {
        from { opacity: 0; transform: translateX(20px); }
        to   { opacity: 1; transform: translateX(0); }
      }

      /* ---- Graduate Earlier Button ---- */
      .shortcut-btn {
        padding: 10px 18px;
        border-radius: 99px;
        border: none;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        background: linear-gradient(135deg, #f97316, #ef4444);
        color: white;
        box-shadow: 0 4px 14px rgba(249,115,22,0.40);
        transition: all 0.25s ease;
        letter-spacing: -0.2px;
        display: none; /* hidden until shortcut is available */
        animation: shortcutPulse 2.2s ease-in-out infinite;
      }
      .shortcut-btn.visible { display: inline-flex; align-items: center; gap: 6px; }
      .shortcut-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 22px rgba(249,115,22,0.55);
        animation: none;
      }
      @keyframes shortcutPulse {
        0%,100% { box-shadow: 0 4px 14px rgba(249,115,22,0.40); }
        50%      { box-shadow: 0 4px 22px rgba(249,115,22,0.70); }
      }

      /* ---- Shortcut Options Modal ---- */
      #shortcut-modal {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.55);
        backdrop-filter: blur(5px);
        z-index: 10002;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
        animation: fadeIn 0.25s ease;
      }
      #shortcut-modal.show { display: flex; }

      .shortcut-modal-panel {
        background: white;
        border-radius: 24px;
        padding: 32px 28px 28px;
        max-width: 860px;
        width: 100%;
        max-height: 88vh;
        overflow-y: auto;
        box-shadow: 0 24px 64px rgba(0,0,0,0.32);
        animation: slideUp 0.35s cubic-bezier(0.68,-0.55,0.265,1.55);
        position: relative;
      }

      .shortcut-modal-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        margin-bottom: 8px;
        gap: 16px;
      }
      .shortcut-modal-title {
        font-family: 'Poppins', sans-serif;
        font-size: 20px;
        font-weight: 700;
        color: #0f172a;
        margin: 0;
      }
      .shortcut-modal-subtitle {
        font-size: 14px;
        color: #64748b;
        margin: 6px 0 24px;
        line-height: 1.6;
      }
      .shortcut-modal-close {
        background: #f1f5f9;
        border: none;
        border-radius: 50%;
        width: 34px;
        height: 34px;
        font-size: 16px;
        cursor: pointer;
        flex-shrink: 0;
        transition: background 0.2s;
        display: flex; align-items: center; justify-content: center;
      }
      .shortcut-modal-close:hover { background: #e2e8f0; }

      .shortcut-options-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 16px;
      }

      .shortcut-option-card {
        border: 2px solid #e2e8f0;
        border-radius: 16px;
        padding: 0;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        background: #ffffff;
        overflow: hidden;
      }
      .shortcut-option-card:hover {
        border-color: #d97706;
        background: #fffbf5;
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(217,119,6,0.2);
      }
      .shortcut-option-card.selected-option {
        border-color: #d97706;
        background: #fffbf5;
        box-shadow: 0 0 0 3px rgba(217,119,6,0.2);
      }

      .shortcut-card-ribbon {
        background: linear-gradient(135deg, #92400e 0%, #b45309 50%, #d97706 100%);
        color: white;
        font-size: 12px;
        font-weight: 700;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        letter-spacing: 0.2px;
        line-height: 1.4;
        box-shadow: 0 2px 8px rgba(146, 64, 14, 0.3);
        position: relative;
      }
      .shortcut-card-ribbon::after {
        content: '';
        position: absolute;
        bottom: -6px;
        left: 0;
        right: 0;
        height: 6px;
        background: linear-gradient(135deg, rgba(146, 64, 14, 0.3) 0%, rgba(217, 119, 6, 0.1) 100%);
        clip-path: polygon(0 0, 100% 0, 100% 100%, 50% 70%, 0 100%);
      }

      .shortcut-card-body {
        padding: 18px;
      }

      .shortcut-option-badge {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
        font-size: 11px;
        font-weight: 700;
        padding: 4px 12px;
        border-radius: 99px;
        margin-bottom: 12px;
        letter-spacing: 0.3px;
      }

      .shortcut-move-list {
        margin: 0 0 14px 0;
        padding: 0;
        list-style: none;
      }
      .shortcut-move-list li {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 13px;
        padding: 5px 0;
        border-bottom: 1px solid #f1f5f9;
        color: #374151;
      }
      .shortcut-move-list li:last-child { border-bottom: none; }
      .shortcut-move-code {
        font-family: monospace;
        background: #f3f4f6;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 11px;
        color: #374151;
        flex-shrink: 0;
      }
      .shortcut-move-hours {
        margin-left: auto;
        font-weight: 700;
        color: #f97316;
        flex-shrink: 0;
      }

      .shortcut-result-preview {
        background: #f8faff;
        border: 1px solid #e2e8f0;
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 12px;
        margin-bottom: 14px;
      }
      .shortcut-result-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 3px 0;
        gap: 8px;
      }
      .shortcut-result-label {
        color: #64748b;
        font-weight: 500;
        flex-shrink: 0;
        max-width: 130px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .shortcut-result-hours {
        font-weight: 700;
        color: #0f172a;
        white-space: nowrap;
      }
      .shortcut-result-hours .old { color: #94a3b8; text-decoration: line-through; margin-right: 4px; font-weight: 400; }
      .shortcut-result-hours .new { color: #16a34a; }
      .shortcut-result-hours .summer-new { color: #f97316; }

      .shortcut-apply-btn {
        width: 100%;
        padding: 10px;
        border: none;
        border-radius: 10px;
        background: linear-gradient(135deg, #d97706, #b45309);
        color: white;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
        letter-spacing: -0.1px;
      }
      .shortcut-apply-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(217,119,6,0.4);
      }

      /* ---- Semester Reduction Badge ---- */
      .sem-reduction-tag {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 5px;
        width: 100%;
        box-sizing: border-box;
        background: linear-gradient(135deg, #0f172a 0%, #1e3a5f 100%);
        color: #fff;
        font-size: 11.5px;
        font-weight: 700;
        letter-spacing: 0.3px;
        padding: 6px 12px;
        border-radius: 10px;
        margin-bottom: 8px;
      }
      .sem-reduction-tag .from { color: #94a3b8; text-decoration: line-through; }
      .sem-reduction-tag .arrow { color: #38bdf8; font-size: 14px; }
      .sem-reduction-tag .to   { color: #4ade80; font-size: 12px; }
      .sem-reduction-tag .grad-from { color: #fca5a5; font-size: 11px; font-weight: 500; }
      .sem-reduction-tag .grad-to   { color: #86efac; font-size: 11px; font-weight: 700; }
      .sem-reduction-tag.same  { background: linear-gradient(135deg, #1e3a5f 0%, #1e4d6b 100%); }
      .sem-reduction-tag.same .to { color: #7dd3fc; }
      .sem-reduction-tag.earlier { background: linear-gradient(135deg, #064e3b 0%, #065f46 100%); }
      .sem-reduction-tag.earlier .to { color: #6ee7b7; }

      /* ---- Summer Bridge Button ---- */
      .bridge-btn {
        padding: 10px 18px;
        border-radius: 99px;
        border: none;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        background: linear-gradient(135deg, #0ea5e9, #0284c7);
        color: white;
        box-shadow: 0 4px 14px rgba(14,165,233,0.40);
        transition: all 0.25s ease;
        letter-spacing: -0.2px;
        display: none;
        animation: bridgePulse 2.4s ease-in-out infinite;
      }
      .bridge-btn.visible { display: inline-flex; align-items: center; gap: 6px; }
      .bridge-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 22px rgba(14,165,233,0.55);
        animation: none;
      }
      @keyframes bridgePulse {
        0%,100% { box-shadow: 0 4px 14px rgba(14,165,233,0.40); }
        50%      { box-shadow: 0 4px 22px rgba(14,165,233,0.70); }
      }

      /* Bridge modal reuses .shortcut-modal-panel and .shortcut-options-grid CSS */
      .bridge-option-card {
        border: 2px solid #e2e8f0;
        border-radius: 16px;
        padding: 0;
        cursor: pointer;
        transition: all 0.2s ease;
        background: #ffffff;
        overflow: hidden;
      }
      .bridge-option-card:hover {
        border-color: #d97706;
        background: #fffbf5;
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(217,119,6,0.2);
      }
      
      .bridge-card-ribbon {
        background: linear-gradient(135deg, #92400e 0%, #b45309 50%, #d97706 100%);
        color: white;
        font-size: 12px;
        font-weight: 700;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        letter-spacing: 0.2px;
        line-height: 1.4;
        box-shadow: 0 2px 8px rgba(146, 64, 14, 0.3);
        position: relative;
      }
      .bridge-card-ribbon::after {
        content: '';
        position: absolute;
        bottom: -6px;
        left: 0;
        right: 0;
        height: 6px;
        background: linear-gradient(135deg, rgba(146, 64, 14, 0.3) 0%, rgba(217, 119, 6, 0.1) 100%);
        clip-path: polygon(0 0, 100% 0, 100% 100%, 50% 70%, 0 100%);
      }
      
      .bridge-card-body {
        padding: 18px;
      }
      
      .bridge-option-badge {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
        font-size: 11px;
        font-weight: 700;
        padding: 4px 12px;
        border-radius: 99px;
        margin-bottom: 12px;
        letter-spacing: 0.3px;
      }
      .bridge-unlock-list {
        margin: 10px 0;
        padding: 10px 12px;
        background: #f0f9ff;
        border: 1px solid #bae6fd;
        border-radius: 10px;
        font-size: 12px;
        color: #0c4a6e;
      }
      .bridge-unlock-list strong { color: #0284c7; }
      .bridge-apply-btn {
        width: 100%;
        padding: 10px;
        border: none;
        border-radius: 10px;
        background: linear-gradient(135deg, #d97706, #b45309);
        color: white;
        font-weight: 700;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-top: 12px;
      }
      .bridge-apply-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(217,119,6,0.4);
      }

      /* ---- Print / PDF Styles ---- */
      @media print {
        body {
          background: white !important;
          padding: 0 !important;
          font-family: 'Inter', sans-serif;
        }
        h2, .courses-section, .fab-container, .upload-box, 
        .semester-actions, .add-summer-after-btn, .delete-semester-btn,
        .course-drag-handle, #statsContainer, #remainingCourses,
        #planSelectorDiv, .generate-plan-btn, .study-plan-header button {
          display: none !important;
        }
        .study-plan-container {
          box-shadow: none !important;
          border: none !important;
          padding: 0 !important;
          margin: 0 !important;
        }
        .upload-container {
          box-shadow: none !important;
          background: white !important;
          backdrop-filter: none !important;
          padding: 20px !important;
          margin: 0 !important;
        }
        .student-info { background: #f8fafc !important; }
        .semester-card { break-inside: avoid; margin-bottom: 12px !important; }
        .plan-summary { break-inside: avoid; }
        .semester-course-item { box-shadow: none !important; }
        #studyPlanDisplay::before {
          content: '🎓 Personalized Study Plan';
          display: block;
          font-size: 24px;
          font-weight: 700;
          font-family: 'Poppins', sans-serif;
          color: #0f172a;
          margin-bottom: 20px;
          padding-bottom: 12px;
          border-bottom: 2px solid #e2e8f0;
        }
      }
    </style>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
      // Configure PDF.js worker - use workerSrc with a fallback
      if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
      // Polyfill: if worker fails, fall back to fake worker (slower but works)
      window.addEventListener('error', function(e) {
        if (e.filename && e.filename.includes('pdf.worker')) {
          console.warn('PDF worker failed to load, using fake worker');
          if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = '';
          }
        }
      });
    </script>
    <script>
      $(function () {
        let courses = null;

        // ============================================================
        // COURSE TYPE CLASSIFICATION SYSTEM
        // ============================================================
        const ELECTIVE_COURSES = [
          'HU402',  // Fundamental of Management
          'HU427',  // Entrepreneurship
          'HU101',  // Micro Economics
          'HU112',  // Creative and Scientific Thinking
          'HU113',  // Human Rights (HU113)
          'HU413',  // Human Rights (HU413 - alternate code)
          'HU111'   // Technical Report Writing
        ];

        const PROJECT_COURSES = ['PC401', 'PC402'];
        const SUMMER_TRAINING = 'TR';

        // Helper functions to classify courses
        function isElectiveCourse(courseCode) {
          return ELECTIVE_COURSES.includes(courseCode);
        }

        function isProjectCourse(courseCode) {
          return PROJECT_COURSES.includes(courseCode);
        }

        function isSummerTraining(courseCode) {
          return courseCode === SUMMER_TRAINING;
        }
       
        const ai_courses = {
          //Sem1
          IT111: {
            name: "Electronics",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          MA111: {
            name: "Mathematics1",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          HU111: {
            name: "Technical Report Writing",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          HU113: {
            name: "Human Rights",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA112: {
            name: "Discrete Math",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          IT110: {
            name: "Introduction to Computers",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          //Sem2
          ST121: {
            name: "Probability and Statistics-1",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU112: {
            name: "Creative and Scientific Thinking",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA113: {
            name: "Mathematics-2",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU101: {
            name: "Micro Economics",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          IT113: {
            name: "Logic Design",
            semester: 2,
            prerequisites: ["IT111"],
            hours: 3,
            isTheoretical: true,
          },
          IT114: {
            name: "Programming Techniques",
            semester: 2,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },

          // Second Year
          //Sem3
          IT215: {
            name: "Object Oriented Programing",
            semester: 3,
            prerequisites: ["IT114"],
            hours: 3,
            isTheoretical: true,
          },
          DS211: {
            name: "Introduction to Database systems",
            semester: 3,
            prerequisites: ["IT114"],
            hours: 3,
            isTheoretical: true,
          },
          MA214: {
            name: "Mathematics-3 ",
            semester: 3,
            prerequisites: ["MA113"],
            hours: 3,
            isTheoretical: true,
          },
          IT231: {
            name: "Computer Networks Technology",
            semester: 3,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },
          ST222: {
            name: "Probability and Statistics-2",
            semester: 3,
            prerequisites: ["ST121"],
            hours: 3,
            isTheoretical: true,
          },
          CS240: {
            name: "Introduction to Software Engineering",
            semester: 3,
            prerequisites: ["IT114"],
            hours: 3,
            isTheoretical: true,
          },

          //Sem 4
          IT217: {
            name: "Introduction to Operation Research",
            semester: 4,
            prerequisites: ["ST121", "IT114"],
            hours: 3,
            isTheoretical: true,
          },
          IT216: {
            name: "Data Structure",
            semester: 4,
            prerequisites: ["IT215"],
            hours: 3,
            isTheoretical: true,
          },
          AI321: {
            name: "Machine Learning Fundamentals",
            semester: 4,
            prerequisites: ["MA214", "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT230: {
            name: "Web Technology",
            semester: 4,
            prerequisites: ["IT215"],
            hours: 3,
            isTheoretical: true,
          },
          HU427: {
            name: "Entrepreneurship",
            semester: 4,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },

          LB211: {
            name: "Networking Fundamentals lab",
            semester: 4,
            prerequisites: ["IT231"],
            hours: 2,
            isTheoretical: false,
          },

          //Third year

          AI341: {
            name: "Computer Vision",
            semester: 5,
            prerequisites: ["IT215"],
            hours: 3,
            isTheoretical: true,
          },
          AI311: {
            name: "Artificial intelligence",
            semester: 5,
            prerequisites: ["IT216"],
            hours: 3,
            isTheoretical: true,
          },
          CS319: {
            name: "Operating Systems",
            semester: 5,
            prerequisites: ["IT216"],
            hours: 3,
            isTheoretical: true,
          },
          AI213: {
            name: "Computational mathematics for learning and data analysis",
            semester: 5,
            prerequisites: ["MA214", "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT318: {
            name: "Computer Organization",
            semester: 5,
            prerequisites: ["IT113", "IT216"],
            hours: 3,
            isTheoretical: true,
          },
          IT341: {
            name: "Algorithms analysis and Design",
            semester: 5,
            prerequisites: ["IT216"],
            hours: 3,
            isTheoretical: true,
          },

          //Sem 6

          AI331: {
            name: "Reinforcement and Deep Learning",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          AI342: {
            name: "Natural Languages Processing",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          AI343: {
            name: "AI Systems Design and Implementation",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          AI351: {
            name: "Intelligent Autonomous Robotics",
            semester: 6,
            prerequisites: ["IT113"],
            hours: 3,
            isTheoretical: true,
          },
          AI361: {
            name: "Big Data",
            semester: 6,
            prerequisites: ["AI213"],
            hours: 3,
            isTheoretical: true,
          },

          // Fourth year

          AI41X: {
            name: "Image Processing",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI48X: {
            name: "Bioinformatics Systems",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI4X1: {
            name: "Artificial intelligence for Cybersecurity",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI212: {
            name: "Reasoning and Knowledge Representation",
            semester: 7,
            prerequisites: ["MA214", "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          LB496: {
            name: "Advanced Machine Learning lab",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          PC401: {
            name: "Graduation Project",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },

          // Sem 8

          AI43X: {
            name: "Elective 4",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          AI46X: {
            name: "Elective 5",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          LB497: {
            name: "AI Cloud Services lab",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          HU402: {
            name: "Fundamental of Management",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          LB431: {
            name: "Selected labs in AI ",
            semester: 8,
            prerequisites: ["AI311"],
            hours: 3,
            isTheoretical: false,
          },
          PC402: {
            name: "Graduation Project",
            semester: 8,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          // Additional courses
          TR: {
            name: "Summer Training",
            semester: 0,
            prerequisites: [],
            hours: 2,
            isTheoretical: false,
          },
          BMA001: {
            name: "Mathematics-0",
            semester: 0,
            prerequisites: [],
            hours: 0,
            isTheoretical: true,
          },
        };

        const it_courses = {
          //Sem1
          IT111: {
            name: "Electronics",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          MA111: {
            name: "Mathematics1",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          HU111: {
            name: "Technical Report Writing",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          HU413: {
            name: "Human Rights",
            semester: 1,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA112: {
            name: "Discrete Math",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          IT110: {
            name: "Introduction to Computers",
            semester: 1,
            prerequisites: [],
            hours: 3,
            isTheoretical: true,
          },
          //Sem2
          ST121: {
            name: "Probability and Statistics-1",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU112: {
            name: "Creative and Scientific Thinking",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          MA113: {
            name: "Mathematics-2",
            semester: 2,
            prerequisites: ["MA111"],
            hours: 3,
            isTheoretical: true,
          },
          HU101: {
            name: "Micro Economics",
            semester: 2,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          IT113: {
            name: "Logic Design",
            semester: 2,
            prerequisites: ["IT111"],
            hours: 3,
            isTheoretical: true,
          },
          CS112: {
            name: "Programming Language",
            semester: 2,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },

          // Second Year
          //Sem3
          CS215: {
            name: "Object Oriented Programing",
            semester: 3,
            prerequisites: ["CS112"],
            hours: 3,
            isTheoretical: true,
          },
          DS211: {
            name: "Introduction to Database systems",
            semester: 3,
            prerequisites: ["CS112"],
            hours: 3,
            isTheoretical: true,
          },
          MA214: {
            name: "Mathematics-3 ",
            semester: 3,
            prerequisites: ["MA113"],
            hours: 3,
            isTheoretical: true,
          },
          IT231: {
            name: "Computer Networks Technology",
            semester: 3,
            prerequisites: ["IT110"],
            hours: 3,
            isTheoretical: true,
          },
          ST222: {
            name: "Probability and Statistics-2",
            semester: 3,
            prerequisites: ["ST121"],
            hours: 3,
            isTheoretical: true,
          },
          CS240: {
            name: "Introduction to Software Engineering",
            semester: 3,
            prerequisites: ["CS112"],
            hours: 3,
            isTheoretical: true,
          },
          //Sem4
          IT217: {
            name: "Introduction to Operation Research",
            semester: 4,
            prerequisites: ["ST121", "CS112"],
            hours: 3,
            isTheoretical: true,
          },
          CS216: {
            name: "Data Structure",
            semester: 4,
            prerequisites: ["CS215"],
            hours: 3,
            isTheoretical: true,
          },
          AI321: {
            name: "Machine Learning Fundamentals",
            semester: 4,
            prerequisites: ["MA214" , "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT230: {
            name: "Web Technology",
            semester: 4,
            prerequisites: ["CS215"],
            hours: 3,
            isTheoretical: true,
          },
          HU427: {
            name: "Entrepreneurship",
            semester: 4,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          LB211: {
            name: "Networking Fundamentals lab",
            semester: 4,
            prerequisites: ["IT231"],
            hours: 2,
            isTheoretical: false,
          },

          // Third year
          //Sem  5
          LB312: {
            name: "Network Routing and Switching-Lab",
            semester: 5,
            prerequisites: ["LB211"],
            hours: 2,
            isTheoretical: false,
          },
          AI311: {
            name: "Artificial intelligence",
            semester: 5,
            prerequisites: ["CS216"],
            hours: 3,
            isTheoretical: true,
          },
          CS319: {
            name: "Operating Systems",
            semester: 5,
            prerequisites: ["CS216"],
            hours: 3,
            isTheoretical: true,
          },
          IT212: {
            name: "Digital Signal Processing",
            semester: 5,
            prerequisites: ["MA214"],
            hours: 3,
            isTheoretical: true,
          },
          CS318: {
            name: "Computer Organization",
            semester: 5,
            prerequisites: ["IT113", "CS216"],
            hours: 3,
            isTheoretical: true,
          },
          CS341: {
            name: "Algorithms analysis and Design",
            semester: 5,
            prerequisites: ["CS216"],
            hours: 3,
            isTheoretical: true,
          },

          // Sem 6
          IT322: {
            name: "Pattern Recognition",
            semester: 6,
            prerequisites: ["IT212" , "ST222"],
            hours: 3,
            isTheoretical: true,
          },
          IT333: {
            name: "Information Computer Networks Security",
            semester: 6,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          AI448: {
            name: "op-Natural Language Processing",
            semester: 6,
            prerequisites: ["AI321"],
            hours: 3,
            isTheoretical: true,
          },
          CS344: {
            name: "Advanced Software Engineering",
            semester: 6,
            prerequisites: ["CS240"],
            hours: 3,
            isTheoretical: true,
          },
          IT343: {
            name: "Microcontroller",
            semester: 6,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          LB313: {
            name: "Ethical Hacking-lab",
            semester: 6,
            prerequisites: ["IT231"],
            hours: 2,
            isTheoretical: false,
          },

          //Fourth year
          // Sem 7

          LB421: {
            name: "Selected labs in Software Engineering",
            semester: 7,
            prerequisites: ["CS341", "CS344"],
            hours: 2,
            isTheoretical: false,
          },
          IT423: {
            name: "Embedded Systems",
            semester: 7,
            prerequisites: ["IT343"],
            hours: 3,
            isTheoretical: true,
          },
          IT221: {
            name: "Computer Graphics",
            semester: 7,
            prerequisites: ["CS215"],
            hours: 3,
            isTheoretical: true,
          },
          IT434: {
            name: "Advanced Computer Networks",
            semester: 7,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          PC401: {
            name: "Project (1)",
            semester: 7,
            prerequisites: [],
            hours: 3,
            isTheoretical: false,
          },
          IT438: {
            name: "Communication Technology",
            semester: 7,
            prerequisites: ["IT231"],
            hours: 3,
            isTheoretical: true,
          },
          // Sem 8
          IT436:{
            name: "Cloud Computing Networking",
            semester: 8,
            prerequisites: ["IT434"],
            hours: 3,
            isTheoretical: true,
          },
          AI435: {
            name: "Semantic Web and ontology",
            semester: 8,
            prerequisites: ["AI311", "IT230"],
            hours: 3,
            isTheoretical: true,
          },
          IT439: {
            name: "Wireless and Mobile Networks",
            semester: 8,
            prerequisites: ["IT434"],
            hours: 3,
            isTheoretical: true,
          },
          HU402: {
            name: "Fundamental of Management",
            semester: 8,
            prerequisites: [],
            hours: 2,
            isTheoretical: true,
          },
          PC402: {
            name: "Project (2)",
            semester: 8,
            prerequisites: ["PC401"],
            hours: 3,
            isTheoretical: false,
          },
          LB431: {
            name: "Selected labs in AI",
            semester: 8,
            prerequisites: ["AI311"],
            hours: 2,
            isTheoretical: false,
          },
          // Additional courses
          TR: {
            name: "Summer Training",
            semester: 0,
            prerequisites: [],
            hours: 2,
            isTheoretical: false,
          },
          BMA001: {
            name: "Mathematics-0",
            semester: 0,
            prerequisites: [],
            hours: 0,
            isTheoretical: true,
          },
        };

        function populateCourses(cs) {
          let coursesTable = document.querySelector("#courses_table");
          coursesTable.innerHTML = "";
          courses = cs;
          window._currentCourses = cs; // expose for CourseConstraints.calculateCompletedCredits
          Object.keys(courses).forEach(function (c) {
            let key = c;
            let course = courses[c];
            addCourse(key, course);
            var prerequisites = courses[c].prerequisites;
            for (var pre of prerequisites) {
              if (!courses[pre].nextCourses) {
                courses[pre].nextCourses = [];
              }
              courses[pre].nextCourses.push(c);
            }
          });
          selected = [];
          $(".course").click(function () {
            var code = this.id;
            if (!document.querySelector("#selectMulti").checked) {
              //multiple course selection is disabled
              selected = [code];
              $(".course").removeClass("prev");
              $(".course").removeClass("direct");
              $(".course").removeClass("selected");
              $(".course").removeClass("next");
              markDependency(code, 0);
            } else {
              if (selected.indexOf(code) > -1) {
                //selected course; remove it
                unselect(code);
              } else {
                select(code);
              }
            }
            markNextCourses();
            showSelected();
            
            // Auto-scroll to show the selected course and related courses
            autoScrollToCourse(code);

            // ── Live update: when multi-select is on, treat clicks as marking
            //    courses completed → refresh stats, remaining courses, and study plan
            if (document.querySelector("#selectMulti").checked) {
              // Show + update stats container
              const statsContainer = document.getElementById('statsContainer');
              if (statsContainer) {
                statsContainer.style.display = 'grid';
                calculateStatistics();
              }
              // Show + refresh remaining courses
              const remainingDiv = document.getElementById('remainingCourses');
              if (remainingDiv) {
                remainingDiv.style.display = 'block';
                showRemainingCourses();
              }
              // Show study plan generator button if hidden
              const planContainer = document.getElementById('studyPlanContainer');
              if (planContainer) {
                planContainer.style.display = 'block';
              }
              // If a plan has already been generated, re-display it so the
              // newly completed/uncompleted course is reflected immediately.
              if (generatedPlans.length > 0) {
                displayStudyPlan(currentPlanIndex);
              }
            }
          });
        }
        populateCourses(it_courses);

        var selected = [];
        var courseGrades = {}; // Store grades for each course
        var courseAttempts = {}; // Store number of attempts for each course
        var incompleteCourseCodes = new Set(); // Track courses with grade "I" (Incomplete)

        $("#selectMulti").click(function () {
          selected = [];
          courseGrades = {}; // Clear grades
          courseAttempts = {}; // Clear attempts
          incompleteCourseCodes.clear(); // Clear incomplete courses
          $(".course").removeClass("prev");
          $(".course").removeClass("direct");
          $(".course").removeClass("selected");
          $(".course").removeClass("next");
          $(".grade-badge").remove(); // Remove all grade badges
          $(".attempts-badge").remove(); // Remove all attempts badges
          $(".incomplete-badge").remove(); // Remove incomplete badges
          showSelected();
          if (this.checked) {
            $("#legend tr:nth-child(2), #legend tr:nth-child(3)").hide();
          } else {
            $("#legend tr:nth-child(2), #legend tr:nth-child(3)").show();
          }
        });

        function select(code, grade, attempts) {
          selected.push(code);
          $("#" + code).addClass("selected");
          
          console.log(`=== SELECT FUNCTION ===`);
          console.log(`Code: ${code}, Grade: ${grade}, Attempts: ${attempts}`);
          
          // Store and display grade if provided
          if (grade) {
            courseGrades[code] = grade;
            courseAttempts[code] = attempts || 1;
            addBadgesToCourse(code, grade, attempts);
          }
        }
        
        // Helper function to add badges to a course (without selecting it)
        function addBadgesToCourse(code, grade, attempts) {
          const gradeColor = getGradeColor(grade);
          console.log(`Grade color: ${gradeColor}`);
          
          // Build the badge HTML — "I" gets a special amber incomplete badge
          const isIncomplete = grade === 'I';
          const badgeClass = isIncomplete ? 'grade-badge incomplete-badge' : 'grade-badge';
          const badgeLabel = isIncomplete ? '⏳ I' : grade;
          const badgeExtra = isIncomplete
            ? 'border: 1.5px solid #d97706; animation: incompletePulse 2s ease-in-out infinite;'
            : '';
          let badgeHTML = `<span class="${badgeClass}" style="background-color: ${gradeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-left: 5px; font-weight: bold; ${badgeExtra}">${badgeLabel}</span>`;
          
          // Add attempts badge if more than 1
          if (attempts > 1) {
            console.log(`Adding attempts badge: ×${attempts}`);
            badgeHTML += `<span class="attempts-badge" style="background-color: #dc2626; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 3px; font-weight: bold;">×${attempts}</span>`;
          }
          
          console.log(`Badge HTML: ${badgeHTML}`);
          console.log(`Element #${code} exists: ${$("#" + code).length > 0}`);
          console.log(`Element current text: "${$("#" + code).text()}"`);
          
          // Remove existing badges if any
          $("#" + code + " .grade-badge").remove();
          $("#" + code + " .attempts-badge").remove();
          $("#" + code + " .incomplete-badge").remove();
          
          // Add new badges
          $("#" + code).append(badgeHTML);
          
          console.log(`After append, element text: "${$("#" + code).text()}"`);
          console.log(`After append, element HTML: "${$("#" + code).html()}"`);
        }
        
        function getGradeColor(grade) {
          const gradeColors = {
            'A+': '#10b981', 'A': '#34d399',
            'B+': '#3b82f6', 'B': '#60a5fa',
            'C+': '#f59e0b', 'C': '#fbbf24',
            'D+': '#ef4444', 'D': '#f87171',
            'P': '#8b5cf6', 'contd': '#6b7280',
            'I': '#d97706',  // Amber — Incomplete
            'F': '#991b1b', 'Fr': '#991b1b', 'Abs': '#991b1b', 'NP': '#991b1b'
          };
          return gradeColors[grade] || '#6b7280';
        }

        function unselect(code) {
          selected.splice(selected.indexOf(code), 1);
          $("#" + code).removeClass("selected");
          
          // Remove grade and attempts badges
          $("#" + code + " .grade-badge").remove();
          $("#" + code + " .attempts-badge").remove();
          delete courseGrades[code];
          delete courseAttempts[code];

          if (!courses[code].nextCourses) return;

          for (var i = 0; i < courses[code].nextCourses.length; i++) {
            var nxt = courses[code].nextCourses[i];
            if (selected.indexOf(nxt) > -1) {
              unselect(nxt);
            }
          }
        }

        function showSelected() {
          var credits = 0;
          for (var c of selected) {
            credits += courses[c].hours;
          }

          //$("#div_sel").html("Selected credit hours: " + credits);
        }

        function markDependency(start, level) {
          switch (level) {
            case 0:
              $("#" + start).addClass("selected");
              break;
            case 1:
              $("#" + start).addClass("direct");
              break;
            default:
              $("#" + start).addClass("prev");
              break;
          }

          for (var dep of courses[start].prerequisites) {
            markDependency(dep, level + 1);
          }
        }

        function markNextCourses() {
          $(".course").removeClass("next");
          for (var s of selected) {
            if (!courses[s].nextCourses) continue;
            for (var next of courses[s].nextCourses) {
              if (selected.indexOf(next) == -1) $("#" + next).addClass("next");
            }
          }
        }

        function autoScrollToCourse(courseCode) {
          const courseElement = document.getElementById(courseCode);
          if (!courseElement) return;
          
          // Get all highlighted courses (selected, direct, prev, next)
          const highlightedCourses = document.querySelectorAll('.course.selected, .course.direct, .course.prev, .course.next');
          
          if (highlightedCourses.length === 0) return;
          
          // Find the topmost and bottommost highlighted courses
          let topMostElement = courseElement;
          let bottomMostElement = courseElement;
          let topMostPosition = courseElement.getBoundingClientRect().top;
          let bottomMostPosition = courseElement.getBoundingClientRect().bottom;
          
          highlightedCourses.forEach(course => {
            const rect = course.getBoundingClientRect();
            if (rect.top < topMostPosition) {
              topMostPosition = rect.top;
              topMostElement = course;
            }
            if (rect.bottom > bottomMostPosition) {
              bottomMostPosition = rect.bottom;
              bottomMostElement = course;
            }
          });
          
          // Calculate if we need to scroll
          const viewportHeight = window.innerHeight;
          const headerHeight = 80; // Height of fixed header
          const scrollPadding = 20; // Extra padding for comfort
          
          // Check if all highlighted courses are visible
          const topVisible = topMostPosition >= headerHeight + scrollPadding;
          const bottomVisible = bottomMostPosition <= viewportHeight - scrollPadding;
          
          if (!topVisible || !bottomVisible) {
            // Calculate the center point between topmost and bottommost courses
            const centerY = (topMostElement.getBoundingClientRect().top + bottomMostElement.getBoundingClientRect().bottom) / 2;
            const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
            const targetScroll = currentScroll + centerY - (viewportHeight / 2);
            
            // Smooth scroll to center the highlighted courses
            window.scrollTo({
              top: Math.max(0, targetScroll),
              behavior: 'smooth'
            });
          }
        }

        // Sequential auto-scroll after upload completion
        function autoScrollAfterUpload() {
          // Helper function to scroll to an element smoothly
          function scrollToElement(elementId, duration = 1500) {
            return new Promise((resolve) => {
              const element = document.getElementById(elementId);
              if (!element) {
                resolve();
                return;
              }
              
              const targetPosition = element.getBoundingClientRect().top + window.pageYOffset - 100;
              const startPosition = window.pageYOffset;
              const distance = targetPosition - startPosition;
              let startTime = null;

              function animation(currentTime) {
                if (startTime === null) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const run = ease(timeElapsed, startPosition, distance, duration);
                window.scrollTo(0, run);
                if (timeElapsed < duration) {
                  requestAnimationFrame(animation);
                } else {
                  resolve();
                }
              }

              // Easing function for smooth animation
              function ease(t, b, c, d) {
                t /= d / 2;
                if (t < 1) return c / 2 * t * t + b;
                t--;
                return -c / 2 * (t * (t - 2) - 1) + b;
              }

              requestAnimationFrame(animation);
            });
          }

          // Execute scroll sequence
          async function scrollSequence() {
            // Wait a bit for DOM to update
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // 1. Scroll up to show courses table
            await scrollToElement('courses_table', 1200);
            await new Promise(resolve => setTimeout(resolve, 800));
            
            // 2. Scroll down to show statistics
            await scrollToElement('statsContainer', 1000);
            await new Promise(resolve => setTimeout(resolve, 600));
            
            // 3. Scroll to show remaining courses
            await scrollToElement('remainingCourses', 1000);
            await new Promise(resolve => setTimeout(resolve, 600));
            
            // 4. Scroll to show study plan generator button
            await scrollToElement('studyPlanContainer', 1000);
          }

          scrollSequence();
        }

        // Auto-scroll when study plan is generated (once only)
        function autoScrollToStudyPlan() {
          if (!window._planJustGenerated) return; // Only scroll on fresh generation
          window._planJustGenerated = false;       // Clear flag immediately
          setTimeout(() => {
            const planDisplay = document.getElementById('studyPlanDisplay');
            if (planDisplay && planDisplay.children.length > 0) {
              planDisplay.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start'
              });
            }
          }, 300);
        }

        function addCourse(id, course) {
          const rowId = course.semester === 0 ? "additional-courses" : `semester-${course.semester}`;
          let semesterRow = document.querySelector(`#${rowId}`);
          if (semesterRow == null) {
            let coursesTable = document.querySelector("#courses_table");
            semesterRow = document.createElement("tr");
            semesterRow.id = rowId;
            let td = document.createElement("td");
            td.className = "header";
            td.textContent = course.semester === 0 ? "Additional Courses" : `Semester ${course.semester}`;
            semesterRow.appendChild(td);
            coursesTable.appendChild(semesterRow);
          }
          course_td = document.createElement("td");
          course_td.setAttribute("id", id);
          course_td.className = "course";
          course_td.textContent = course.name;
          // Make draggable for study plan
          course_td.draggable = true;
          course_td.dataset.courseCode = id;
          course_td.addEventListener('dragstart', function(e) {
            draggedElement = e.target;
            draggedCourseCode = id;
            draggedFromSemester = -1;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', id);
            e.target.style.opacity = '0.6';
          });
          course_td.addEventListener('dragend', function(e) {
            e.target.style.opacity = '';
            draggedCourseCode = null;
            draggedFromSemester = null;
            draggedElement = null;
          });
          semesterRow.appendChild(course_td);
        }

        $(".program").click((ev) => {
          let it = document.querySelector("#it");
          let ai = document.querySelector("#ai");
        
          it.classList.remove("active");
          ai.classList.remove("active");
         

          ev.target.classList.add("active");

          if (ev.target.id === "it") {
            console.log("it selected");
            populateCourses(it_courses);
          } else if (ev.target.id === "ai") {
            console.log("ai selected");
            populateCourses(ai_courses);
          } 
        });

        // ========================================
        // PDF AUTO-SELECTION FUNCTIONALITY
        // ========================================

        function addDebugLog(message, type = 'info') {
          const timestamp = new Date().toLocaleTimeString();
          const prefix = type === 'success' ? '✅' : 
                        type === 'error' ? '❌' : 
                        type === 'warning' ? '⚠️' : 'ℹ️';
          console.log(`[${timestamp}] ${prefix} ${message}`);
        }

        // Course name normalization for matching
        function normalizeName(name) {
          if (!name) return '';
          return name.toLowerCase()
            .replace(/[^a-z0-9\s]/g, ' ')  // Remove special chars
            .replace(/\s+/g, ' ')          // Normalize spaces
            .trim();
        }

        // Remove filler words
        function removeFillers(name) {
          const fillers = ['and', 'the', 'of', 'to', 'in', 'systems', 'system', 'a', 'an'];
          return name.split(' ').filter(word => !fillers.includes(word)).join(' ');
        }

        // Calculate similarity between two strings
        function similarity(s1, s2) {
          const longer = s1.length > s2.length ? s1 : s2;
          const shorter = s1.length > s2.length ? s2 : s1;
          if (longer.length === 0) return 1.0;
          const editDistance = levenshteinDistance(longer, shorter);
          return (longer.length - editDistance) / longer.length;
        }

        function levenshteinDistance(s1, s2) {
          const costs = [];
          for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
              if (i === 0) {
                costs[j] = j;
              } else if (j > 0) {
                let newValue = costs[j - 1];
                if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                  newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                }
                costs[j - 1] = lastValue;
                lastValue = newValue;
              }
            }
            if (i > 0) costs[s2.length] = lastValue;
          }
          return costs[s2.length];
        }

        // Smart course matching
        function matchCourse(pdfCourseName, pdfCourseCode) {
                  // ═══ SPECIAL CASES - HIGH PRIORITY ═══
                  if (pdfCourseName) {
                    const name = pdfCourseName.toLowerCase();
                    
                    // Computer Graphics → IT221
                    if ((name.includes('computer graphics') || name.includes('graphics') || 
                         name.includes('رسومات') || name.includes('جرافيك')) && courses['IT221']) {
                      addDebugLog(`🎨 Special: Computer Graphics → IT221`, 'success');
                      return { code: 'IT221', name: courses['IT221'].name, score: 1.0 };
                    }
                    
                    // Data Structure → CS216
                    if ((name.includes('data structure') || name.includes('هياكل البيانات') || 
                         name.includes('هيكل بيانات')) && courses['CS216']) {
                      addDebugLog(`📊 Special: Data Structure → CS216`, 'success');
                      return { code: 'CS216', name: courses['CS216'].name, score: 1.0 };
                    }
                    
                    // Algorithms → CS341
                    if ((name.includes('algorithm') || name.includes('خوارزميات')) && courses['CS341']) {
                      addDebugLog(`🔢 Special: Algorithms → CS341`, 'success');
                      return { code: 'CS341', name: courses['CS341'].name, score: 1.0 };
                    }
                    
                    // Operating Systems → CS319
                    if ((name.includes('operating system') || name.includes('نظم تشغيل')) && courses['CS319']) {
                      addDebugLog(`💻 Special: OS → CS319`, 'success');
                      return { code: 'CS319', name: courses['CS319'].name, score: 1.0 };
                    }
                  }
                  
                  // ═══ CONTINUE WITH NORMAL MATCHING ═══
                  // Step 1: Normalize - remove ALL whitespace AND convert Arabic presentation forms
                  const normalizedCode = normalizeArabicChars(
                    pdfCourseCode.replace(/\s+/g, '').trim()
                  );
          
                  addDebugLog(`🔍 Matching: Original="${pdfCourseCode}" → Normalized="${normalizedCode}"`, 'info');
          
                  // Known code aliases
                  const codeAliases = {
                    'HU113': 'HU413',
                    'IT240': 'CS240',
                    'CS240': 'IT240',
                  };
          
                  // Try alias first
                  const aliasCode = codeAliases[normalizedCode];
                  if (aliasCode && courses[aliasCode]) {
                    addDebugLog(`✅ Alias match: "${normalizedCode}" → "${aliasCode}"`, 'success');
                    return { code: aliasCode, name: courses[aliasCode].name, score: 1.0 };
                  }
          
                  // Try normalized code directly
                  if (courses[normalizedCode]) {
                    addDebugLog(`✅ Direct match: "${normalizedCode}"`, 'success');
                    return { code: normalizedCode, name: courses[normalizedCode].name, score: 1.0 };
                  }
          
                  // Try original code
                  if (courses[pdfCourseCode]) {
                    addDebugLog(`✅ Original match: "${pdfCourseCode}"`, 'success');
                    return { code: pdfCourseCode, name: courses[pdfCourseCode].name, score: 1.0 };
                  }

                  // ── COMPREHENSIVE Arabic Department Prefix Mapping ──
                  const arabicPrefixMap = {
                    // CS (Computer Science - علوم حاسب)
                    'علح': 'CS', 'حلع': 'CS', 'لحع': 'CS', 'عحل': 'CS',
                    'ﺢﻠﻋ': 'CS', 'ﻠﻋﺢ': 'CS', 'ﻋﻠﺣ': 'CS', 'ﻊﻠﺣ': 'CS',
            
                    // IT (Information Technology - تكنولوجيا المعلومات)
                    'تمع': 'IT', 'عمت': 'IT', 'معت': 'IT', 'تعم': 'IT',
                    'ﺘﻤﻋ': 'IT', 'ﻤﻋﺘ': 'IT', 'ﻌﻤﺗ': 'IT', 'ﻋﻤﺗ': 'IT',
            
                    // AI (Artificial Intelligence - ذكاء اصطناعي)
                    'ذكا': 'AI', 'اكذ': 'AI', 'كاذ': 'AI', 'ذاك': 'AI',
                    'ﺬﻛﺎ': 'AI', 'ﻛﺎﺫ': 'AI', 'ﺎﻛﺫ': 'AI',
                    
                    // MA (Mathematics - رياضيات)
                    'رضي': 'MA', 'يضر': 'MA', 'ضري': 'MA', 'رضم': 'MA', 'مضر': 'MA',
                    
                    // ST (Statistics - إحصاء)
                    'حصإ': 'ST', 'إحص': 'ST', 'صإح': 'ST',
                    
                    // HU (Humanities - إنسانيات)
                    'سنإ': 'HU', 'إنس': 'HU', 'نسإ': 'HU', 'نإس': 'HU',
                    
                    // LB (Laboratory - معمل)
                    'عم': 'LB', 'مع': 'LB', 'ﻌﻣ': 'LB', 'ﻣﻋ': 'LB',
                    
                    // PC (Project - مشروع)
                    'رشم': 'PC', 'مشر': 'PC', 'شمر': 'PC', 'رمش': 'PC'
                  };

                  addDebugLog(`🔤 Trying Arabic prefix matching for: "${normalizedCode}"`, 'info');

                  for (const [arabicKey, engPrefix] of Object.entries(arabicPrefixMap)) {
                    // ── Case 1: Arabic BEFORE digits ("علح216", "حلع216") ──
                    if (normalizedCode.startsWith(arabicKey)) {
                      const numbers = normalizedCode.slice(arabicKey.length).replace(/\D/g, '');
                      if (/^\d{3,4}$/.test(numbers)) {
                        const converted = engPrefix + numbers;
                        if (courses[converted]) {
                          addDebugLog(`✅ Arabic-first: "${pdfCourseCode}" → "${converted}" (${arabicKey}→${engPrefix})`, 'success');
                          return { code: converted, name: courses[converted].name, score: 1.0 };
                        } else {
                          addDebugLog(`⚠️ Tried ${converted} but not in courses`, 'warning');
                        }
                      }
                    }
            
                    // ── Case 2: Digits BEFORE Arabic ("221تمع", "221عمت") ──
                    if (normalizedCode.endsWith(arabicKey)) {
                      const numbers = normalizedCode.slice(0, -arabicKey.length).replace(/\D/g, '');
                      if (/^\d{3,4}$/.test(numbers)) {
                        const converted = engPrefix + numbers;
                        if (courses[converted]) {
                          addDebugLog(`✅ Number-first: "${pdfCourseCode}" → "${converted}" (${arabicKey}→${engPrefix})`, 'success');
                          return { code: converted, name: courses[converted].name, score: 1.0 };
                        } else {
                          addDebugLog(`⚠️ Tried ${converted} but not in courses`, 'warning');
                        }
                      }
                    }
                  }

                  // ── Number-Only Fallback with Name Similarity ──
                  const digits = normalizedCode.replace(/[^0-9]/g, '');
                  if (digits.length >= 3) {
                    addDebugLog(`🔢 Trying number fallback with digits: "${digits}"`, 'info');
                    let bestMatch = null;
                    let bestScore = 0;
            
                    for (const [code, course] of Object.entries(courses)) {
                      const codeDigits = code.replace(/[^0-9]/g, '');
                      if (codeDigits === digits) {
                        let score = 0.5; // base score for numeric match
                        if (pdfCourseName) {
                          score = similarity(
                            pdfCourseName.toLowerCase().trim(),
                            course.name.toLowerCase().trim()
                          );
                        }
                        if (score > bestScore) {
                          bestScore = score;
                          bestMatch = { code, name: course.name, score };
                        }
                      }
                    }
            
                    if (bestMatch && bestMatch.score >= 0.3) {
                      addDebugLog(`✅ Number fallback: "${normalizedCode}" → "${bestMatch.code}" (score: ${bestMatch.score.toFixed(2)})`, 'success');
                      return bestMatch;
                    }
                  }
          
                  // No match found
                  addDebugLog(`❌ No match found for: "${pdfCourseCode}"`, 'error');
                  return null;
                }

        // Check if grade is passing - EXPLICIT LIST ONLY
        function isPassingGrade(grade) {
          // ONLY these grades are passing - everything else is FAILING
          const passingGrades = ['A+', 'A', 'B+', 'B', 'C+', 'C', 'D+', 'D', 'P', 'contd'];
          const isPassing = passingGrades.includes(grade);
          
          // Explicit check for common failing grades to catch errors
          const failingGrades = ['F', 'Fr', 'Abs', 'NP', 'W', 'I'];
          if (failingGrades.includes(grade)) {
            return false; // Explicitly return false for known failing grades
          }
          
          return isPassing;
        }

        // Parse PDF and extract courses
        async function parsePDF(file) {
          try {
            addDebugLog('📄 Loading PDF file...', 'info');
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              const pageText = textContent.items.map(item => item.str).join(' ');
              fullText += pageText + '\n';
            }

            addDebugLog('✅ PDF loaded successfully', 'success');
            return extractCoursesFromText(fullText);
          } catch (error) {
            addDebugLog(`❌ Error parsing PDF: ${error.message}`, 'error');
            return null;
          }
        }

        // ── Arabic Presentation-Form Normalizer ────────────────────────────
        // PDF.js often returns Arabic letters as Unicode Presentation Forms
        // (range U+FE70–U+FEFF) rather than base Arabic (U+0600–U+06FF).
        // This function maps every relevant presentation-form codepoint back
        // to its base character so later string comparisons work correctly.
        //
        // Additionally, PDF.js reads RTL columns visually left-to-right, so a
        // 3-letter Arabic prefix like علح arrives character-by-character in
        // REVERSED order: ح ل ع  (HAH LAM AIN instead of AIN LAM HAH).
        // We therefore store BOTH orderings in arabicPrefixMap.
        function normalizeArabicChars(text) {
          // Map every Presentation-Form-B glyph we care about to its base char.
          // Keyed by the exact codepoints that appeared in this student's PDF
          // (confirmed via Unicode inspection of the PDF.js output).
          const presFormMap = {
            // HAH (ح  U+062D) ─ all four contextual forms
            '\uFEA1':'\u062D','\uFEA2':'\u062D','\uFEA3':'\u062D','\uFEA4':'\u062D',
            // TEH (ت  U+062A) ─ all four contextual forms
            '\uFE95':'\u062A','\uFE96':'\u062A','\uFE97':'\u062A','\uFE98':'\u062A',
            // AIN (ع  U+0639) ─ all four contextual forms
            '\uFEC9':'\u0639','\uFECA':'\u0639','\uFECB':'\u0639','\uFECC':'\u0639',
            // LAM (ل  U+0644) ─ all four contextual forms (FEE0 = medial, confirmed)
            '\uFEDB':'\u0644','\uFEDC':'\u0644','\uFEDD':'\u0644','\uFEDE':'\u0644',
            '\uFEDF':'\u0644','\uFEE0':'\u0644',
            // MEEM (م U+0645) ─ all four contextual forms
            '\uFEE1':'\u0645','\uFEE2':'\u0645','\uFEE3':'\u0645','\uFEE4':'\u0645',
          };
          return text.replace(/[\uFE70-\uFEFF]/g, ch => presFormMap[ch] || ch);
        }

        // Extract courses from text
        function extractCoursesFromText(rawText) {
          // ── STEP 0: Normalize Arabic Presentation Forms → base chars ─────────
          // Must happen BEFORE any regex so that Arabic codes like
          // "216ﺢﻠﻋ" become "216حلع" and can then be matched.
          const text = normalizeArabicChars(rawText);
          addDebugLog('🔤 Arabic presentation-form normalization applied', 'info');

          const courses = [];
          
          // VALID GRADES - removed "0" as it's النقاط not التقدير!
          const gradePattern = 'A\\+|B\\+|C\\+|D\\+|Abs|Fr|NP|contd|A|B|C|D|F|P|I';
          
          // ── Combined course-code capture group ────────────────────────────────
          // After normalizeArabicChars() above, presentation-form chars have been
          // converted to base Arabic (U+0600-U+06FF).  We ALSO include the
          // presentation-form range (U+FE70-U+FEFF) as a safety net in case any
          // stray glyphs were not in our normalisation map.
          //
          // PDF.js reads RTL columns LTR, so a 3-letter Arabic prefix arrives
          // REVERSED: "علح" (AIN-LAM-HAH) is extracted as "حلع" (HAH-LAM-AIN).
          // The matchCourse function handles this via reversed keys in arabicPrefixMap.
          const arabicChars = '[\\u0600-\\u06FF\\uFE70-\\uFEFF]';
          const codeCapture = 
            '[A-Z]{2,4}\\s?\\d{3,4}' +                        // English  e.g. IT111
            `|${arabicChars}{2,4}\\s?\\d{3,4}` +              // Arabic-first e.g. علح216 or حلع216
            `|\\d{3,4}\\s?${arabicChars}{2,4}` +              // Number-first e.g. 216علح or 216حلع ← RTL PDF
            '|TR|BMA\\d{3}';
          
          // Pattern 1: CODE NAME CREDITS MAX POINTS GRADE (normal order)
          // Example: MA112 Discrete Mathematics 3 100 2.2000 D+
          const pattern1 = new RegExp(`(${codeCapture})\\s+(.+?)\\s+\\d+\\s+[\\d.]+\\s+[\\d.]+\\s+(${gradePattern})(?=\\s|$)`, 'g');
          
          // Pattern 2: GRADE POINTS MAX CREDITS NAME CODE (reversed order)
          // Example: D+ 2.2000 100 3 Discrete Mathematics MA112
          // Also: D 2.0000 100 3 Data Structures 216 علح  (Arabic summer entry)
          const pattern2 = new RegExp(`(${gradePattern})(?=\\s)\\s+[\\d.]+\\s+[\\d.]+\\s+\\d+\\s+(.+?)\\s+(${codeCapture})`, 'g');
          
          // Pattern 3: NO GRADE - for currently registered courses
          // When التقدير is blank, the extracted text skips it entirely
          // Order becomes: POINTS MAX CREDITS NAME CODE
          // Example: 0 100 3 Pattern Recognition IT322
          // NOTE: MAX can be non-100 (e.g. 80 for projects, 120 for special courses)
          //       No ^ or $ anchors - PDF text is joined with spaces per page.
          //       Use (?:^|\s) to match standalone 0 (not part of a decimal like 2.0000)
          const pattern3 = new RegExp(`(?:^|\\s)(0)\\s+\\d+\\s+(\\d+)\\s+(.+?)\\s+(${codeCapture})(?=\\s|$)`, 'g');
          
          // Also handle reverse: CODE NAME CREDITS MAX POINTS (no grade)
          // Example: IT322 Pattern Recognition 3 100 0
          // MAX can vary (100, 80, 120) depending on course type
          const pattern4 = new RegExp(`(${codeCapture})\\s+(.+?)\\s+\\d+\\s+\\d+\\s+0(?:\\s|$)`, 'gm');
          
          let match;
          
          // Try pattern 1 (normal order WITH grade)
          while ((match = pattern1.exec(text)) !== null) {
            const [, code, name, grade] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: grade.trim()
            });
            console.log(`📄 Extracted (P1-WithGrade): ${code.trim()} - ${name.trim()} - Grade: "${grade.trim()}"`);
          }
          
          // Try pattern 2 (reversed order WITH grade)
          while ((match = pattern2.exec(text)) !== null) {
            const [, grade, name, code] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: grade.trim()
            });
            console.log(`📄 Extracted (P2-WithGrade): ${code.trim()} - ${name.trim()} - Grade: "${grade.trim()}"`);
          }
          
          // Try pattern 3 (NO grade - reversed order, التقدير missing)
          // Groups: [fullMatch, '0'(points), credits, name, code]
          while ((match = pattern3.exec(text)) !== null) {
            const [, , credits, name, code] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: '' // No grade = empty string
            });
            console.log(`📄 Extracted (P3-NoGrade): ${code.trim()} - ${name.trim()} - Grade: "" (registered, no grade yet)`);
          }
          
          // Try pattern 4 (NO grade - normal order)
          while ((match = pattern4.exec(text)) !== null) {
            const [, code, name] = match;
            courses.push({
              code: code.trim(),
              name: name.trim(),
              grade: '' // No grade = empty string
            });
            console.log(`📄 Extracted (P4-NoGrade): ${code.trim()} - ${name.trim()} - Grade: "" (registered, no grade yet)`);
          }

          addDebugLog(`📊 Found ${courses.length} course entries in document (including duplicates and retakes)`, 'info');
          
          // Don't deduplicate here - return ALL courses including retakes
          // The autoSelectCourses function will handle deduplication and count attempts

          // Extract student info
          const studentInfo = {
            name: text.match(/اسم الطالب\s*:\s*([^\n]+)/)?.[1]?.trim(),
            id: text.match(/رقم الطالب\s*:\s*(\d+)/)?.[1]?.trim(),
            level: text.match(/المستوى\s*:\s*([^\n]+)/)?.[1]?.trim(),
            gpa: text.match(/المعدل التراكمي\s*:\s*(\d+\.\d+)/)?.[1]
          };
          
          return { courses: courses, studentInfo }; // Return ALL courses, not deduplicated
        }

        // Auto-select courses from PDF/Excel
        function autoSelectCourses(pdfCourses) {
          document.querySelector("#selectMulti").checked = true;
          selected = [];
          courseGrades = {}; // Clear grades
          courseAttempts = {}; // Clear attempts - will store ALL attempts (passing AND failing)
          incompleteCourseCodes.clear(); // Clear incomplete courses
          $(".course").removeClass("prev direct selected next");
          $(".grade-badge").remove(); // Remove all existing grade badges
          $(".attempts-badge").remove(); // Remove all existing attempts badges
          $(".incomplete-badge").remove(); // Remove all incomplete badges

          const coursesByCode = {};
          
          // Separate completed courses from currently registered (no grade)
          const completedCourses = pdfCourses.filter(c => c.grade && c.grade.trim() !== '');
          
          // Deduplication guard: pattern3 can produce false-positive "no-grade" entries
          // for courses like IT438 (grade=F, points=0) because "F 0 100 3 name IT438"
          // also contains the sub-pattern "0 100 3 name IT438".
          // Discard any no-grade entry whose code also appears with a real grade.
          const completedCodes = new Set(completedCourses.map(c => c.code.replace(/\s+/g, '')));
          const rawRegistered = pdfCourses.filter(c => !c.grade || c.grade.trim() === '');
          const registeredCourses = rawRegistered.filter(c => 
            !completedCodes.has(c.code.replace(/\s+/g, ''))
          );
          
          if (registeredCourses.length > 0) {
            addDebugLog(`\n📌 CURRENTLY REGISTERED COURSES (${registeredCourses.length} courses - NO GRADES YET):`, 'warning');
            addDebugLog(`   ⚠️ These courses will NOT be marked as completed`, 'warning');
            addDebugLog(`   ✅ They will be treated as REMAINING courses in the study plan`, 'info');
            addDebugLog(`   📝 The study plan will start FROM the current semester`, 'info');
            registeredCourses.forEach(c => {
              addDebugLog(`   ⏳ ${c.code} - ${c.name}`, 'info');
            });
          }
          
          addDebugLog(`\n✅ PROCESSING ${completedCourses.length} COMPLETED COURSES:`, 'info');
          
          completedCourses.forEach(pdfCourse => {
            const code = pdfCourse.code;
            if (!coursesByCode[code]) {
              coursesByCode[code] = [];
            }
            coursesByCode[code].push(pdfCourse);
          });

          let matched = 0;
          let notMatched = 0;

          for (const [code, attempts] of Object.entries(coursesByCode)) {
            const gradeValue = {
              'A+': 10, 'A': 9, 'B+': 8, 'B': 7, 'C+': 6, 'C': 5,
              'D+': 4, 'D': 3, 'P': 2, 'contd': 1,
              'I': 0,  // Incomplete - special case, between passing and failing
              'F': -1, 'Fr': -1, 'Abs': -1, 'NP': -1
            };
            
            attempts.sort((a, b) => (gradeValue[b.grade] || -99) - (gradeValue[a.grade] || -99));
            const bestAttempt = attempts[0];
            const attemptCount = attempts.length; // Count how many times

            if (attemptCount > 1) {
              const allGrades = attempts.map(a => a.grade).join(', ');
              addDebugLog(`🔄 ${code} has ${attemptCount} attempts (${allGrades}) → Using best: ${bestAttempt.grade}`, 'info');
            }

            const passing = isPassingGrade(bestAttempt.grade);
            
            // Match the course to get the actual course code from our system
            const match = matchCourse(bestAttempt.name, bestAttempt.code);
            
            if (match) {
              // ALWAYS store attempt count and grade for matched courses (whether passing or not)
              courseAttempts[match.code] = attemptCount;
              courseGrades[match.code] = bestAttempt.grade;
              
              if (!passing) {
                // ── INCOMPLETE GRADE SPECIAL CASE ─────────────────────────────
                if (bestAttempt.grade === 'I') {
                  // Grade "I" = Incomplete: student must retake, BUT gets a special
                  // exception to exceed the 12h summer / 21h regular semester caps.
                  incompleteCourseCodes.add(match.code);
                  courseAttempts[match.code] = attemptCount;
                  courseGrades[match.code] = 'I';
                  // Show a distinctive amber "I" badge on the course grid cell
                  addBadgesToCourse(match.code, 'I', attemptCount);
                  addDebugLog(`⏳ INCOMPLETE ${code} → ${match.code} (Grade: I) — will appear in plan with hour-cap exception`, 'warning');
                  continue;
                }
                // Course failed (F / Fr / Abs / NP) - DON'T select, just show badges
                addBadgesToCourse(match.code, bestAttempt.grade, attemptCount);
                addDebugLog(`⏭️ Skipped ${code} - ${bestAttempt.name} (Grade: ${bestAttempt.grade} - NOT PASSING) - ${attemptCount} attempt(s) tracked`, 'warning');
                continue;
              }
              
              // Course passed - select it (which will also add badges)
              if (!selected.includes(match.code)) {
                select(match.code, bestAttempt.grade, attemptCount); // Pass attempt count
                matched++;
                addDebugLog(`✅ ${bestAttempt.code} → ${match.code} (Grade: ${bestAttempt.grade}, Attempts: ${attemptCount})`, 'success');
              }
            } else {
              notMatched++;
              addDebugLog(`❌ No match: ${bestAttempt.code} - ${bestAttempt.name}`, 'error');
            }
          }

          markNextCourses();
          showSelected();

          addDebugLog(`\n📈 ${matched} matched, ${notMatched} not matched`, 'info');
          
          const uniqueSelected = [...new Set(selected)];
          addDebugLog(`\n📋 SELECTED COURSES (${uniqueSelected.length}):`, 'success');
          uniqueSelected.sort().forEach(code => {
            addDebugLog(`   ✓ ${code}`, 'success');
          });
          
          return { matched, notMatched };
        }

        // Calculate statistics
        // ============ ACADEMIC METRICS CALCULATION ============
        // Calculate proper semester counts distinguishing regular vs summer terms
        function calculateAcademicMetrics(semesters) {
          let firstTermCount = 0;
          let secondTermCount = 0;
          let summerTermCount = 0;
          let lastRegularSemesterIndex = -1;
          
          semesters.forEach((semester, index) => {
            const semName = semester.name || '';
            const isSummer = semester.isSummer || semName.toLowerCase().includes('summer');
            
            if (isSummer) {
              summerTermCount++;
            } else if (semName.includes('First')) {
              firstTermCount++;
              lastRegularSemesterIndex = index;
            } else if (semName.includes('Second')) {
              secondTermCount++;
              lastRegularSemesterIndex = index;
            }
          });
          
          // Regular semesters = first terms + second terms
          const regularSemesters = firstTermCount + secondTermCount;
          
          // Academic years = number of complete year pairs (first + second)
          const completeYears = Math.min(firstTermCount, secondTermCount);
          
          // If there's an unpaired first/second term, add one more year
          const hasUnpairedTerm = firstTermCount !== secondTermCount;
          const totalYears = completeYears + (hasUnpairedTerm ? 1 : 0);
          
          // Count summer terms that come AFTER the last regular semester
          let summerInFinalYear = 0;
          let summerInMiddleYears = 0;
          
          semesters.forEach((semester, index) => {
            const semName = semester.name || '';
            const isSummer = semester.isSummer || semName.toLowerCase().includes('summer');
            
            if (isSummer) {
              if (index > lastRegularSemesterIndex) {
                summerInFinalYear++;
              } else {
                summerInMiddleYears++;
              }
            }
          });
          
          return {
            regularSemesters,      // Total first + second terms
            totalYears,            // Academic years (pairs of semesters)
            summerTerms: summerTermCount,
            summerInFinalYear,     // Summer terms after last regular semester
            summerInMiddleYears,   // Summer terms between regular semesters
            firstTermCount,
            secondTermCount
          };
        }

        function calculateStatistics() {
          // Get unique courses only (in case of duplicates in selected array)
          const uniqueSelected = [...new Set(selected)];
          
          addDebugLog(`\n💯 CALCULATING STATISTICS FOR ${uniqueSelected.length} UNIQUE COURSES:`, 'info');
          
          let totalCredits = 0;
          let completedCount = 0; // Only count courses that exist in the current program
          let skippedCourses = []; // Track courses not found
          
          // Special course tracking
          let specialCourses = {
            TR: false,
            BMA001: false,
            PC401: false,
            PC402: false
          };
          
          let courseBreakdown = [];
          
          uniqueSelected.forEach(code => {
            // ===== CRITICAL VALIDATION: Check if course exists in current program =====
            if (!courses[code]) {
              skippedCourses.push(code);
              addDebugLog(`⚠️ WARNING: Course ${code} not found in current program - SKIPPED`, 'error');
              return; // Skip this course
            }
            
            completedCount++; // Only count if course exists
            const hours = courses[code].hours;
            const name = courses[code].name;
            
            // BMA001 has 0 hours, don't count in 135 total
            if (code === 'BMA001') {
              courseBreakdown.push(`   ${code}: ${name} - ${hours}h (NOT counted in 135h total)`);
            } else {
              totalCredits += hours;
              courseBreakdown.push(`   ${code}: ${name} - ${hours}h ✓`);
            }
            
            // Track special courses
            if (specialCourses.hasOwnProperty(code)) {
              specialCourses[code] = true;
            }
          });
          
          // Log skipped courses summary
          if (skippedCourses.length > 0) {
            addDebugLog(`\n⚠️ SKIPPED ${skippedCourses.length} COURSES NOT IN CURRENT PROGRAM:`, 'error');
            addDebugLog(`   ${skippedCourses.join(', ')}`, 'error');
            addDebugLog(`   💡 Tip: Make sure you selected the correct program (IT vs AI) at the top`, 'warning');
          }
          
          // Log detailed breakdown
          addDebugLog(`\n📊 CREDIT HOURS BREAKDOWN (${completedCount} courses):`, 'info');
          courseBreakdown.forEach(line => addDebugLog(line, 'info'));
          addDebugLog(`\n   TOTAL: ${totalCredits} credit hours`, 'success');

          const percentage = Math.min(Math.round((totalCredits / 135) * 100), 100); // Cap at 100%
          
          // Update UI
          document.getElementById('creditHours').textContent = `${totalCredits}/135`;
          document.getElementById('creditProgress').style.width = `${percentage}%`;
          document.getElementById('creditPercentage').textContent = `${percentage}% Complete`;
          document.getElementById('completedCount').textContent = completedCount;
          
          const totalCourses = Object.keys(courses).length;
          const remaining = totalCourses - completedCount;
          document.getElementById('remainingCount').textContent = `${remaining} Remaining`;

          // Log special course status
          addDebugLog(`\n📋 Special Requirements:`, 'info');
          addDebugLog(`   Summer Training (TR): ${specialCourses.TR ? '✅ Completed' : '❌ Not completed'}`, specialCourses.TR ? 'success' : 'warning');
          addDebugLog(`   Mathematics-0 (BMA001): ${specialCourses.BMA001 ? '✅ Completed' : '❌ Not completed'} (0h - not counted)`, specialCourses.BMA001 ? 'success' : 'warning');
          addDebugLog(`   Project 1 (PC401): ${specialCourses.PC401 ? '✅ Completed' : '❌ Not completed'}`, specialCourses.PC401 ? 'success' : 'warning');
          addDebugLog(`   Project 2 (PC402): ${specialCourses.PC402 ? '✅ Completed' : '❌ Not completed'}`, specialCourses.PC402 ? 'success' : 'warning');
          
          addDebugLog(`\n💯 FINAL TOTAL: ${totalCredits}/135 credit hours (${percentage}%)`, totalCredits >= 135 ? 'success' : 'info');

          return { totalCredits, completedCount, percentage };
        }

        // Show remaining courses
        function showRemainingCourses() {
          const courseListEl = document.getElementById('courseList');
          courseListEl.innerHTML = '';

          // Get unique selected courses
          const uniqueSelected = [...new Set(selected)];
          const remaining = [];
          
          for (const [code, course] of Object.entries(courses)) {
            if (!uniqueSelected.includes(code)) {
              const prereqsMet = course.prerequisites.every(prereq => uniqueSelected.includes(prereq));
              // Get attempt count from courseAttempts if it exists
              const attempts = courseAttempts[code] || 0;
              remaining.push({ code, course, prereqsMet, attempts });
            }
          }

          remaining.sort((a, b) => {
            if (a.prereqsMet !== b.prereqsMet) return b.prereqsMet ? 1 : -1;
            return a.course.semester - b.course.semester;
          });

          remaining.forEach(({ code, course, prereqsMet, attempts }) => {
            const item = document.createElement('div');
            item.className = `course-item ${prereqsMet ? 'available' : 'locked'}`;
            // Make draggable for study plan
            item.draggable = true;
            item.dataset.courseCode = code;
            item.addEventListener('dragstart', function(e) {
              draggedElement = e.target;
              draggedCourseCode = code;
              draggedFromSemester = -1;
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', code);
              e.target.style.opacity = '0.6';
            });
            item.addEventListener('dragend', function(e) {
              e.target.style.opacity = '';
              draggedCourseCode = null;
              draggedFromSemester = null;
              draggedElement = null;
            });
            
            // Build the course info HTML
            let attemptBadge = '';
            if (attempts > 0) {
              attemptBadge = `<span class="course-attempts-badge" style="background-color: #dc2626; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px; font-weight: bold;">×${attempts} attempt${attempts > 1 ? 's' : ''}</span>`;
            }
            
            item.innerHTML = `
              <div>
                <span class="course-item-name">${course.name}</span>
                <span class="course-item-code">(${code})</span>
                ${attemptBadge}
              </div>
              <span class="course-item-hours">${course.hours}h</span>
            `;
            courseListEl.appendChild(item);
          });
        }

        // ============ STUDY PLAN GENERATOR ============
        
        let generatedPlans = [];
        let currentPlanIndex = 0;

        // ============ ACADEMIC RULE ENGINE ============

        // Convert course's semester number (1-8) to semester type (1 or 2)
        // Semester 1,3,5,7 → Type 1 (can be taken in student terms 1,3,5,7)
        // Semester 2,4,6,8 → Type 2 (can be taken in student terms 2,4,6,8)
        function getSemesterType(courseSemester) {
          return (courseSemester % 2 === 1) ? 1 : 2;
        }

        // Detect student's current term from transcript
        // MODIFIED LOGIC:
        // 1. Find last registered semester (highest semester with registered courses)
        // 2. Check if that semester has grades:
        //    - If YES → start plan from NEXT semester
        //    - If NO → ignore that registration, start from previous completed semester + 1
        function detectCurrentTerm(pdfCourses) {
          let currentTerm = {
            termNumber: null,
            registeredCourses: [],
            isDetected: false,
            hasGrades: false
          };
          
          // Separate courses into completed and registered
          // c.grade holds التقدير (letter grade like D, F, Fr, etc.)
          // It is NEVER '0' — '0' is النقاط (points), not التقدير
          const coursesWithGrades = pdfCourses.filter(c => 
            c.grade && c.grade.trim() !== ''
          );
          
          const coursesWithoutGrades = pdfCourses.filter(c => 
            !c.grade || c.grade.trim() === ''
          );
          
          // Deduplication guard: pattern3 (no-grade pattern) can produce false positives
          // for courses like IT438 (grade=F, points=0) because "F 0 100 3 name IT438"
          // contains "0 100 3 name IT438" which pattern3 also matches.
          // Solution: discard any "no-grade" entry whose code also appears WITH a grade.
          const codesWithGrades = new Set(
            coursesWithGrades.map(c => c.code.replace(/\s+/g, ''))
          );
          const trulyUngraded = coursesWithoutGrades.filter(c => {
            const norm = c.code.replace(/\s+/g, '');
            return !codesWithGrades.has(norm);
          });
          
          // Find the highest semester number from registered courses (without grades)
          let lastRegisteredSemester = 0;
          const lastRegisteredCourses = [];
          
          if (trulyUngraded.length > 0) {
            addDebugLog(`📋 Found ${trulyUngraded.length} registered courses (no grades):`, 'info');
            
            trulyUngraded.forEach(pdfCourse => {
              const match = matchCourse(pdfCourse.name, pdfCourse.code);
              if (match && courses[match.code]) {
                // BMA001 (Mathematics-0) has no real semester, exclude it from comparisons
                if (match.code === 'BMA001') return;
                
                const semesterNum = courses[match.code].semester;
                addDebugLog(`   📌 ${match.code} (Sem ${semesterNum}) - ${pdfCourse.name}`, 'info');
                
                if (semesterNum > lastRegisteredSemester) {
                  lastRegisteredSemester = semesterNum;
                  lastRegisteredCourses.length = 0;
                  lastRegisteredCourses.push(pdfCourse);
                } else if (semesterNum === lastRegisteredSemester) {
                  lastRegisteredCourses.push(pdfCourse);
                }
              }
            });
            
            if (lastRegisteredSemester > 0) {
              addDebugLog(`\n🔍 Last Registered Semester: ${lastRegisteredSemester}`, 'warning');
              addDebugLog(`   Courses in this semester: ${lastRegisteredCourses.length}`, 'info');
              
              // Check if ANY course in this semester has a grade
              let semesterHasGrades = false;
              lastRegisteredCourses.forEach(c => {
                if (c.grade && c.grade.trim() !== '') {
                  semesterHasGrades = true;
                }
              });
              
              if (semesterHasGrades) {
                // Last registered semester HAS grades → start from NEXT semester
                addDebugLog(`   ✅ Last registered semester HAS grades`, 'success');
                addDebugLog(`   → Plan will start from Semester ${lastRegisteredSemester + 1}`, 'success');
                
                currentTerm.termNumber = lastRegisteredSemester + 1;
                currentTerm.hasGrades = true;
              } else {
                // Last registered semester has NO grades → Plan should start FROM this semester
                // Treat these registered courses as remaining courses (not completed)
                addDebugLog(`   ⚠️ Last registered semester has NO grades - TREATING AS CURRENT SEMESTER`, 'warning');
                addDebugLog(`   → Registered courses will be treated as REMAINING (not completed)`, 'info');
                addDebugLog(`   → Plan will start FROM Semester ${lastRegisteredSemester} (CURRENT SEMESTER)`, 'success');
                
                // Set the plan to start FROM the current registered semester
                // This way, the registered courses (which weren't marked as completed) 
                // will be included in the study plan
                currentTerm.termNumber = lastRegisteredSemester;
                currentTerm.hasGrades = false;
              }
              
              currentTerm.registeredCourses = lastRegisteredCourses;
              currentTerm.isDetected = true;
            }
          } else {
            // No courses without grades - student has completed all courses in transcript
            // Need to determine what semester they just finished
            
            // Get all courses with grades
            const completedCourses = pdfCourses.filter(c => 
              c.grade && c.grade.trim() !== ''
            );
            
            // Match them to our course database and find their semester types
            const semesterNumbers = [];
            
            completedCourses.forEach(pdfCourse => {
              const match = matchCourse(pdfCourse.name, pdfCourse.code);
              if (match && courses[match.code]) {
                // BMA001 (Mathematics-0) has no real semester, exclude it
                if (match.code === 'BMA001') return;
                semesterNumbers.push(courses[match.code].semester);
              }
            });
            
            if (semesterNumbers.length > 0) {
              // Find the most recent semester completed
              const maxSemester = Math.max(...semesterNumbers);
              
              // Determine what the NEXT term should be
              // If they finished semester 1 → next is semester 2 (term 2)
              // If they finished semester 2 → next is semester 3 (term 3)
              // etc.
              const nextSemester = maxSemester + 1;
              
              // Convert next semester to term number
              // Semester 1 → Term 1, Semester 2 → Term 2, etc.
              currentTerm.termNumber = nextSemester;
              
              if (currentTerm.termNumber > 8) {
                currentTerm.termNumber = 8; // Cap at term 8
              }
              
              currentTerm.isDetected = true;
              
              const passedCourses = pdfCourses.filter(c => 
                c.grade && isPassingGrade(c.grade)
              ).length;
              
              addDebugLog(`🎯 Last completed semester: ${maxSemester}, Next term: ${currentTerm.termNumber} (${passedCourses} passed courses)`, 'success');
            } else {
              // Fallback: estimate based on passed courses count
              const passedCourses = pdfCourses.filter(c => 
                c.grade && c.grade.trim() !== '' && isPassingGrade(c.grade)
              ).length;
              
              let estimatedYear = Math.ceil(passedCourses / 14);
              if (estimatedYear < 1) estimatedYear = 1;
              if (estimatedYear > 4) estimatedYear = 4;
              
              // Start from next term
              const baseTermForYear = (estimatedYear - 1) * 2;
              currentTerm.termNumber = baseTermForYear + 1; // Start from odd term of current year
              currentTerm.isDetected = true;
              
              addDebugLog(`🎯 No current registration, estimated next term: ${currentTerm.termNumber} (${passedCourses} passed courses)`, 'info');
            }
          }
          
          return currentTerm;
        }

        // Validate current term registration
        function validateCurrentRegistration(currentTerm, completedCourses) {
          const violations = [];
          
          if (!currentTerm.isDetected) return { isValid: true, violations: [] };
          
          const termType = (currentTerm.termNumber % 2 === 1) ? 1 : 2;
          
          currentTerm.registeredCourses.forEach(pdfCourse => {
            const match = matchCourse(pdfCourse.name, pdfCourse.code);
            if (!match) return;
            
            const course = courses[match.code];
            if (!course) return;
            
            // Check 1: Semester type matching
            const courseSemesterType = getSemesterType(course.semester);
            if (courseSemesterType !== termType) {
              violations.push({
                code: match.code,
                reason: `Wrong term type - ${match.code} is semester ${courseSemesterType} course, but registered in term ${currentTerm.termNumber} (type ${termType})`
              });
            }
            
            // Check 2: Prerequisites
            const unmetPrereqs = course.prerequisites.filter(prereq => !completedCourses.includes(prereq));
            if (unmetPrereqs.length > 0) {
              violations.push({
                code: match.code,
                reason: `Missing prerequisites: ${unmetPrereqs.join(', ')}`
              });
            }
          });
          
          return {
            isValid: violations.length === 0,
            violations: violations
          };
        }

        // Get available courses (prerequisites met)
        function getAvailableCourses(completedCourses, remainingCourses) {
          // Calculate current credit hours
          const currentHours = completedCourses.reduce((sum, code) => {
            // Don't count BMA001 (Math-0) toward credit hours
            if (code === 'BMA001') return sum;
            return sum + (courses[code]?.hours || 0);
          }, 0);

          return remainingCourses.filter(code => {
            const course = courses[code];
            
            // Check regular prerequisites
            const prereqsMet = course.prerequisites.every(prereq => completedCourses.includes(prereq));
            if (!prereqsMet) return false;
            
            // Special rule: TR (Summer Training) requires 60+ credit hours
            if (code === 'TR' && currentHours < 60) {
              return false;
            }
            
            // Special rule: PC401 (Project 1) requires 85+ credit hours
            if (code === 'PC401' && currentHours < 85) {
              return false;
            }
            
            return true;
          });
        }

        // Generate a study plan
        function generateStudyPlan(strategy = 'balanced', startTerm = 3) {
          const uniqueSelected = [...new Set(selected)];
          const remaining = Object.keys(courses).filter(code => {
            // Exclude completed courses and special courses
            if (uniqueSelected.includes(code)) return false;
            if (code === 'BMA001') return false; // Math-0 doesn't count
            return true;
          });

          const plan = [];
          let completed = [...uniqueSelected];
          let toSchedule = [...remaining];
          
          // Calculate current credit hours
          const calculateHours = (courseList) => {
            return courseList.reduce((sum, code) => {
              if (code === 'BMA001') return sum;
              return sum + (courses[code]?.hours || 0);
            }, 0);
          };
          
          let currentHours = calculateHours(completed);
          
          // Start from detected or provided term
          let currentTermNumber = startTerm;
          let semesterCount = 0;
          const maxSemesters = 12; // Safety limit

          // ==========================================
          // CALCULATE BASE YEAR FROM CURRENT DATE
          // ==========================================
          const now = new Date();
          const currentCalendarYear = now.getFullYear(); // e.g., 2026
          const currentMonth = now.getMonth() + 1; // e.g., 2 for February
          
          // Current academic year (Sep-Aug cycle)
          // If month >= 9 (Sep-Dec), use current year as base
          // If month < 9 (Jan-Aug), use previous year as base
          const currentAcademicYear = (currentMonth >= 9) ? currentCalendarYear : currentCalendarYear - 1;
          
          // Calculate which "year of study" the startTerm is in (0-indexed)
          // Terms 1-2 = year 0, Terms 3-4 = year 1, Terms 5-6 = year 2, etc.
          const startTermYearIndex = Math.floor((startTerm - 1) / 2);
          
          // Calculate base year for terms 1-2 (year 0)
          // If we're starting at term 6 (year index 2) in Feb 2026 (academic year 2025-2026)
          // then term 1-2 would have been in 2023-2024
          const term1BaseYear = currentAcademicYear - startTermYearIndex;
          
          addDebugLog(`\n📅 DATE-BASED YEAR CALCULATION:`, 'info');
          addDebugLog(`   Current date: ${now.toLocaleDateString()}`, 'info');
          addDebugLog(`   Current academic year: ${currentAcademicYear}-${currentAcademicYear + 1}`, 'info');
          addDebugLog(`   Starting from term ${startTerm} (year index ${startTermYearIndex})`, 'info');
          addDebugLog(`   Calculated base year for terms 1-2: ${term1BaseYear}-${term1BaseYear + 1}`, 'info');

          addDebugLog(`\n🎯 Planning starts from Term ${currentTermNumber} (${toSchedule.length} courses remaining, ${currentHours}h completed)`, 'info');
          
          // Log what courses need to be scheduled
          const failedCourses = toSchedule.filter(code => {
            return completed.includes(code) === false && 
                   Object.keys(courses).includes(code);
          });
          
          addDebugLog(`📝 Courses to schedule: ${toSchedule.join(', ')}`, 'info');

          while (toSchedule.length > 0 && semesterCount < maxSemesters) {
            // Track if we just added a summer term to prevent consecutive summers
            let justAddedSummer = false;
            
            // Determine term type (1 = odd/First, 2 = even/Second)
            const termType = (currentTermNumber % 2 === 1) ? 1 : 2;
            
            addDebugLog(`\n--- Planning Term ${currentTermNumber} (Type ${termType}) ---`, 'info');
            
            // Calculate remaining hours
            const remainingHours = calculateHours(toSchedule);
            addDebugLog(`   Remaining to schedule: ${toSchedule.length} courses, ${remainingHours} hours`, 'info');
            
            // Determine semester limits
            let maxHours = 18; // Default max
            let minHours = 9;
            
            // FILTER: Get courses available for this term
            let available = toSchedule.filter(code => {
              const course = courses[code];
              if (!course) {
                addDebugLog(`   ❌ ${code}: Course not found in database`, 'error');
                return false;
              }
              
              // Rule 1: Semester type must match term type
              const courseSemesterType = getSemesterType(course.semester);
              if (courseSemesterType !== termType) {
                addDebugLog(`   ⏭️ ${code} (Sem ${course.semester}): Wrong type (need type ${termType}, has type ${courseSemesterType})`, 'info');
                return false;
              }
              
              // Rule 2: Prerequisites must be met
              const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
              if (!prereqsMet) {
                const missing = course.prerequisites.filter(p => !completed.includes(p));
                addDebugLog(`   ⏭️ ${code}: Missing prerequisites: ${missing.join(', ')}`, 'info');
                return false;
              }
              
              // Rule 3: TR requires 60+ hours (but TR can only be in summer, so skip in normal terms)
              if (code === 'TR') {
                addDebugLog(`   ⏭️ TR: Can only be taken in summer`, 'info');
                return false;
              }
              
              // Rule 4: PC401 requires 85+ hours
              if (code === 'PC401' && currentHours < 85) {
                addDebugLog(`   ⏭️ PC401: Not enough hours (${currentHours}/85)`, 'info');
                return false;
              }
              
              addDebugLog(`   ✅ ${code} (Sem ${course.semester}): Available`, 'success');
              return true;
            });
            
            addDebugLog(`   → ${available.length} courses available for this term`, 'info');
            
            // PRIORITIZE: Smart dependency management + fill to max
            available = available.map(code => {
              const unlocks = Object.keys(courses).filter(c => 
                courses[c].prerequisites.includes(code) && toSchedule.includes(c)
              ).length;
              
              // SPECIAL PRIORITY: Projects get highest priority when eligible
              let priority = unlocks;
              if (code === 'PC401' && currentHours >= 85) {
                priority = 1000;
              } else if (code === 'PC402' && completed.includes('PC401')) {
                priority = 999;
              } else if (incompleteCourseCodes.has(code)) {
                // Incomplete courses get high priority — they must appear in the plan
                priority = 998;
              }
              
              return { code, unlocks, priority, hours: courses[code].hours };
            });
            
            // Sort by priority first, then by hours (to fill to max)
            available.sort((a, b) => {
              if (b.priority !== a.priority) return b.priority - a.priority;
              return b.hours - a.hours;
            });
            
            const availableCodes = available.map(item => item.code);
            if (availableCodes.includes('PC401')) {
              addDebugLog(`   🎯 PC401 prioritized (current hours: ${currentHours})`, 'success');
            }
            if (availableCodes.includes('PC402')) {
              addDebugLog(`   🎯 PC402 prioritized`, 'success');
            }
            
            available = available.map(item => item.code);
            
            // SELECT: Fill semester to max hours (18 or special limits)
            // Incomplete-grade courses bypass the cap — they MUST be scheduled.
            const termCourses = [];
            let termHours = 0;
            let semHasIncomplete = false;
            
            for (const code of available) {
              const courseHours = courses[code].hours;
              const isIncomplete = incompleteCourseCodes.has(code);
              if (isIncomplete || termHours + courseHours <= maxHours) {
                termCourses.push(code);
                termHours += courseHours;
                if (isIncomplete) {
                  semHasIncomplete = true;
                  addDebugLog(`   ⏳ ${code}: Incomplete course — added ABOVE normal cap (${termHours}h total)`, 'warning');
                }
              }
            }
            
            // If no courses can be added, break
            if (termCourses.length === 0) {
              addDebugLog(`   ⚠️ No courses available to schedule`, 'warning');
              break;
            }
            
            // Add term to plan
            // Calculate year based on the term number and base year
            const termYearIndex = Math.floor((currentTermNumber - 1) / 2);
            const year = term1BaseYear + termYearIndex;
            const termName = termType === 1 ? 'First' : 'Second';
            
            plan.push({
              name: `${termName} Term ${year}-${year + 1}`,
              courses: termCourses,
              hours: termHours,
              isSummer: false,
              isSpecialCase: false,
              hasIncomplete: semHasIncomplete
            });
            
            // Mark courses as completed
            completed.push(...termCourses);
            toSchedule = toSchedule.filter(code => !termCourses.includes(code));
            currentHours = calculateHours(completed);
            
            addDebugLog(`   ✅ Added ${termCourses.length} courses (${termHours}h). Total hours: ${currentHours}`, 'success');
            
            // ==========================================
            // POST-SEMESTER CHECKS (IN SEQUENCE)
            // ==========================================
            
            // CHECK 1: TR SUMMER (after even semesters with 60+ hours)
            if (termType === 2 && toSchedule.includes('TR') && currentHours >= 60) {
              addDebugLog(`\n   🌞 CHECK 1: TR CONDITION MET`, 'success');
              addDebugLog(`      → Current semester is EVEN (Second Term)`, 'info');
              addDebugLog(`      → Gained hours: ${currentHours} >= 60`, 'info');
              addDebugLog(`      → TR not added yet`, 'info');
              addDebugLog(`      → AUTO-ADDING TR Summer`, 'success');
              
              const trPrereqsMet = courses['TR'].prerequisites.every(prereq => completed.includes(prereq));
              if (trPrereqsMet) {
                plan.push({
                  name: `Summer Term ${year}-${year + 1}`,
                  courses: ['TR'],
                  hours: 2,
                  isSummer: true,
                  isSpecialCase: false
                });
                
                completed.push('TR');
                toSchedule = toSchedule.filter(code => code !== 'TR');
                currentHours = calculateHours(completed);
                
                addDebugLog(`      ✅ Added TR summer. Total hours: ${currentHours}`, 'success');
                justAddedSummer = true; // Mark that we just added a summer term
              }
            }
            
            // Recalculate remaining after potential TR addition
            const newRemainingHours = calculateHours(toSchedule);
            // For threshold checks: exclude incomplete courses (they bypass caps)
            const newRemainingHoursExclInc = calculateHours(toSchedule.filter(c => !incompleteCourseCodes.has(c)));
            
            // CHECK 3: SPECIAL SUMMER (after even, ≤12 hours remaining - REGARDLESS of type mix)
            // Incomplete courses are excluded from the 12h threshold — they bypass the cap.
            // This check must come BEFORE CHECK 2 because it's more specific
            if (!justAddedSummer && termType === 2 && newRemainingHours > 0 && newRemainingHoursExclInc <= 12 && toSchedule.length > 0) {
              // After even semester with ≤12h remaining (excl. incomplete), always use summer special case
              addDebugLog(`\n   ⭐ CHECK 3: SPECIAL SUMMER CASE`, 'success');
              addDebugLog(`      → Current semester is EVEN (Second Term)`, 'info');
              addDebugLog(`      → Next would be ODD (First Term)`, 'info');
              addDebugLog(`      → Remaining hours (excl. incomplete): ${newRemainingHoursExclInc} (0 < hours <= 12)`, 'info');
              addDebugLog(`      → Adding special summer with NO semester restrictions`, 'success');
              
              // Filter courses (can take ANY semester type, except PC401/PC402)
              const summerCourses = toSchedule.filter(code => {
                const course = courses[code];
                if (!course) return false;
                
                // Check prerequisites
                const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                if (!prereqsMet) return false;
                
                // TR special requirement
                if (code === 'TR' && currentHours < 60) return false;
                
                // PC401 and PC402 CANNOT be in summer
                if (code === 'PC401' || code === 'PC402') {
                  addDebugLog(`      ⏭️ ${code}: Cannot be taken in summer (projects restricted)`, 'warning');
                  return false;
                }
                
                return true;
              });
                
              if (summerCourses.length > 0) {
                let summerHours = 0;
                const selectedSummer = [];
                
                // Prioritize and fill to max 12 hours
                const prioritizedSummer = summerCourses.map(code => {
                  const unlocks = Object.keys(courses).filter(c => 
                    courses[c].prerequisites.includes(code) && toSchedule.includes(c)
                  ).length;
                  return { code, unlocks, hours: courses[code].hours };
                }).sort((a, b) => {
                  if (b.unlocks !== a.unlocks) return b.unlocks - a.unlocks;
                  return b.hours - a.hours;
                });
                
                for (const item of prioritizedSummer) {
                  const hours = item.hours;
                  const isInc = incompleteCourseCodes.has(item.code);
                  // Incomplete courses bypass the 12h cap
                  if (isInc || summerHours + hours <= 12) {
                    selectedSummer.push(item.code);
                    summerHours += hours;
                    if (isInc) addDebugLog(`      ⏳ ${item.code}: Incomplete — added ABOVE 12h cap`, 'warning');
                  }
                }
                
                if (selectedSummer.length > 0) {
                  const hasIncInSummer = selectedSummer.some(c => incompleteCourseCodes.has(c));
                  plan.push({
                    name: `Summer Term ${year}-${year + 1} ⭐ Special Case`,
                    courses: selectedSummer,
                    hours: summerHours,
                    isSummer: true,
                    isSpecialCase: true,
                    hasIncomplete: hasIncInSummer
                  });
                  
                  completed.push(...selectedSummer);
                  toSchedule = toSchedule.filter(code => !selectedSummer.includes(code));
                  currentHours = calculateHours(completed);
                  
                  addDebugLog(`      ✅ Added special summer: ${selectedSummer.length} courses, ${summerHours}h`, 'success');
                  addDebugLog(`      → Courses: ${selectedSummer.join(', ')}`, 'info');
                  justAddedSummer = true; // Mark that we just added a summer term
                }
              }
            }
            
            // Recalculate remaining again after potential summer addition
            const finalRemainingHours = calculateHours(toSchedule);
            const finalRemainingHoursExclInc = calculateHours(toSchedule.filter(c => !incompleteCourseCodes.has(c)));
            
            // CHECK 2: SPECIAL CASE 21-HOUR SEMESTER (same semester type, 0-21 hours)
            // Incomplete courses are excluded from the 21h threshold — they bypass the cap.
            // This check comes AFTER CHECK 3 (more general fallback)
            if (finalRemainingHours > 0 && finalRemainingHoursExclInc <= 21 && toSchedule.length > 0) {
              // Check if all remaining NON-INCOMPLETE courses are from same semester type
              const nonIncComplete = toSchedule.filter(c => !incompleteCourseCodes.has(c));
              const remainingSemesterTypes = nonIncComplete.map(code => {
                const course = courses[code];
                return course ? getSemesterType(course.semester) : null;
              }).filter(t => t !== null);
              
              const allType1 = remainingSemesterTypes.length === 0 || remainingSemesterTypes.every(t => t === 1);
              const allType2 = remainingSemesterTypes.length === 0 || remainingSemesterTypes.every(t => t === 2);
              
              if (allType1 || allType2) {
                const sameSemesterType = allType2 ? 2 : 1;
                addDebugLog(`\n   ⭐ CHECK 2: SPECIAL CASE 21-HOUR SEMESTER`, 'success');
                addDebugLog(`      → Remaining hours (excl. incomplete): ${finalRemainingHoursExclInc} (0 < hours <= 21)`, 'info');
                addDebugLog(`      → All courses are from ${allType1 ? 'ODD (First)' : 'EVEN (Second)'} semesters`, 'info');
                addDebugLog(`      → Adding all as special 21-hour semester (incomplete courses bypass cap)`, 'success');
                
                // Filter courses that meet prerequisites
                // Incomplete courses of matching type are included (with cap bypass)
                const finalCourses = toSchedule.filter(code => {
                  const course = courses[code];
                  if (!course) return false;
                  if (code === 'TR') return false; // TR only in summer
                  
                  const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                  if (!prereqsMet) return false;
                  
                  if (code === 'PC401' && currentHours < 85) return false;
                  
                  return true;
                });
                
                if (finalCourses.length > 0) {
                  const finalHours = calculateHours(finalCourses);
                  const hasIncInFinal = finalCourses.some(c => incompleteCourseCodes.has(c));
                  const nextTermNumber = currentTermNumber + 1;
                  const nextTermType = (nextTermNumber % 2 === 1) ? 1 : 2;
                  const nextTermYearIndex = Math.floor((nextTermNumber - 1) / 2);
                  const nextYear = term1BaseYear + nextTermYearIndex;
                  const nextTermName = nextTermType === 1 ? 'First' : 'Second';
                  
                  plan.push({
                    name: `${nextTermName} Term ${nextYear}-${nextYear + 1}`,
                    courses: finalCourses,
                    hours: finalHours,
                    isSummer: false,
                    isSpecialCase: true,
                    hasIncomplete: hasIncInFinal
                  });
                  
                  completed.push(...finalCourses);
                  toSchedule = toSchedule.filter(code => !finalCourses.includes(code));
                  currentHours = calculateHours(completed);
                  
                  addDebugLog(`      ✅ Added special 21-hour semester: ${finalCourses.length} courses, ${finalHours}h`, 'success');
                }
              }
            }
            
            // Recalculate one more time
            const veryFinalRemainingHours = calculateHours(toSchedule);
            const veryFinalRemainingHoursExclInc = calculateHours(toSchedule.filter(c => !incompleteCourseCodes.has(c)));
            
            // CHECK 4: FINAL SUMMER TERM (≤12h after First Term - allows incomplete courses)
            // If we just finished a First (odd) semester and have ≤12h remaining,
            // create a summer term instead of requiring a full Second Term.
            // This is especially useful for incomplete courses in the final semester.
            // CRITICAL: Don't trigger if the last semester added is already summer (prevents consecutive summers)
            const lastAddedSemester = plan.length > 0 ? plan[plan.length - 1] : null;
            const lastIsNotSummer = !lastAddedSemester || !lastAddedSemester.isSummer;
            
            if (lastIsNotSummer && termType === 1 && veryFinalRemainingHours > 0 && veryFinalRemainingHoursExclInc <= 12 && toSchedule.length > 0) {
              addDebugLog(`\n   🌞 CHECK 4: FINAL SUMMER TERM`, 'success');
              addDebugLog(`      → Just completed FIRST (odd) semester`, 'info');
              addDebugLog(`      → Remaining hours (excl. incomplete): ${veryFinalRemainingHoursExclInc} (0 < hours <= 12)`, 'info');
              addDebugLog(`      → Creating final summer term (incomplete courses allowed)`, 'success');
              
              // Filter courses - allow ANY course type, including incomplete courses
              const finalSummerCourses = toSchedule.filter(code => {
                const course = courses[code];
                if (!course) return false;
                
                const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                if (!prereqsMet) return false;
                
                // TR special requirement
                if (code === 'TR' && currentHours < 60) return false;
                
                // PC401 and PC402 CANNOT be in summer
                if (code === 'PC401' || code === 'PC402') {
                  addDebugLog(`      ⏭️ ${code}: Cannot be taken in summer (projects restricted)`, 'warning');
                  return false;
                }
                
                return true;
              });
              
              if (finalSummerCourses.length > 0) {
                let finalSummerHours = 0;
                const selectedFinalSummer = [];
                
                // Prioritize courses
                const prioritizedFinalSummer = finalSummerCourses.map(code => {
                  const unlocks = Object.keys(courses).filter(c => 
                    courses[c].prerequisites.includes(code) && toSchedule.includes(c)
                  ).length;
                  return { code, unlocks, hours: courses[code].hours };
                }).sort((a, b) => {
                  if (b.unlocks !== a.unlocks) return b.unlocks - a.unlocks;
                  return b.hours - a.hours;
                });
                
                // Select all courses - incomplete courses bypass the cap
                for (const item of prioritizedFinalSummer) {
                  const isInc = incompleteCourseCodes.has(item.code);
                  if (isInc || finalSummerHours + item.hours <= 12) {
                    selectedFinalSummer.push(item.code);
                    finalSummerHours += item.hours;
                    if (isInc) addDebugLog(`      ⏳ ${item.code}: Incomplete — added to final summer`, 'warning');
                  }
                }
                
                if (selectedFinalSummer.length > 0) {
                  const hasIncInFinalSummer = selectedFinalSummer.some(c => incompleteCourseCodes.has(c));
                  // Calculate year for this summer term (comes after current First Term)
                  const currentYearIndex = Math.floor((currentTermNumber - 1) / 2);
                  const summerYear = term1BaseYear + currentYearIndex;
                  
                  plan.push({
                    name: `Summer Term ${summerYear}-${summerYear + 1} ⭐ Special Case`,
                    courses: selectedFinalSummer,
                    hours: finalSummerHours,
                    isSummer: true,
                    isSpecialCase: true,
                    hasIncomplete: hasIncInFinalSummer
                  });
                  
                  completed.push(...selectedFinalSummer);
                  toSchedule = toSchedule.filter(code => !selectedFinalSummer.includes(code));
                  currentHours = calculateHours(completed);
                  
                  addDebugLog(`      ✅ Added final summer: ${selectedFinalSummer.length} courses, ${finalSummerHours}h`, 'success');
                  addDebugLog(`      → Courses: ${selectedFinalSummer.join(', ')}`, 'info');
                }
              }
            }
            
            // Move to next term
            currentTermNumber++;
            if (currentTermNumber > 12) {
              addDebugLog(`⚠️ Reached maximum term (12), stopping`, 'warning');
              break;
            }
            
            semesterCount++;
          }
          
          // Add warning if not all courses could be scheduled
          if (toSchedule.length > 0) {
            addDebugLog(`\n⚠️ Warning: ${toSchedule.length} courses could not be scheduled:`, 'warning');
            toSchedule.forEach(code => {
              addDebugLog(`   - ${code}: ${courses[code]?.name}`, 'warning');
            });
          }
          
          return plan;
        }

        // Display study plan with drag-and-drop
        // ============================================================
        // AUTO-CONVERT LAST ODD SEMESTER → SUMMER SPECIAL CASE
        // Trigger: last plan semester is a First (odd) semester AND
        // its credit hours are ≤ 12 (user dragged enough courses out).
        // Note: If lab courses remain the user will see a warning but
        // the conversion still happens — they can drag labs out manually.
        // ============================================================
        function checkAndConvertLastOddSemester(plan) {
          if (!plan || plan.semesters.length === 0) return false;

          const lastIdx = plan.semesters.length - 1;
          const lastSem  = plan.semesters[lastIdx];

          // Must be a non-summer First Term (odd) semester
          const isFirstTerm = !lastSem.isSummer &&
            (lastSem.name.includes('First') || lastSem.name.includes('Odd'));

          if (!isFirstTerm) return false;
          // FIXED: Only convert to special case if non-incomplete hours are between 1-12
          // Incomplete courses (grade "I") bypass the hour cap — exclude them from the threshold
          const nonIncompleteHours = lastSem.courses.reduce((sum, code) => {
            if (incompleteCourseCodes.has(code)) return sum;
            return sum + (courses[code]?.hours || 0);
          }, 0);
          if (nonIncompleteHours <= 0 || nonIncompleteHours > 12) return false;

          // ══ CRITICAL FIX: Only convert if this is truly an "odd" unpaired semester ══
          // Check if the previous semester is a Second Term or Summer
          // If previous is a First Term, then this is a paired Second-to-First sequence (normal)
          if (lastIdx > 0) {
            const prevSem = plan.semesters[lastIdx - 1];
            const prevIsFirst = !prevSem.isSummer && prevSem.name.includes('First');
            
            // If previous semester is ALSO a First Term, this current First Term is paired
            // and should NOT be converted to Summer Special Case
            if (prevIsFirst) {
              return false; // Don't convert paired First Terms
            }
          }

          // ── Detect projects that can't be taken in summer ──────
          const projectCourses = lastSem.courses.filter(code => {
            return isProjectCourse(code);
          });

          // ── Convert ──────────────────────────────────────────────
          const yearMatch = lastSem.name.match(/(\d{4})/);
          const baseYear  = yearMatch ? parseInt(yearMatch[1]) : new Date().getFullYear();

          // Only convert once (avoid re-converting already-converted)
          if (lastSem.isSummer) return false;

          lastSem.isSummer      = true;
          // Use non-incomplete hours to determine if special case (>9h non-incomplete = special)
          lastSem.isSpecialCase = (nonIncompleteHours > 9);
          if (lastSem.hasIncomplete) lastSem.isSpecialCase = true; // always special if has incomplete
          const specialCaseLabel = lastSem.isSpecialCase ? ' ⭐ Special Case' : '';
          lastSem.name          = `Summer Term ${baseYear}-${baseYear + 1}${specialCaseLabel}`;

          if (projectCourses.length > 0) {
            const projectNames = projectCourses.map(c => courses[c]?.name || c).join(', ');
            TechBot.warning(
              `⭐ Last semester converted to Summer${lastSem.isSpecialCase ? ' Special Case' : ''} (${lastSem.hours}h). ` +
              `⚠️ Note: Project courses cannot be taken in summer — please drag out: ${projectNames}`
            );
          } else {
            const scMsg = lastSem.isSpecialCase 
              ? ` ⭐ Special Case (>9h) — max 12 hours.`
              : ` (≤9h) — max 9 hours.`;
            TechBot.success(
              `Last semester converted to Summer!${scMsg}`
            );
          }
          return true;
        }

        // ============================================================
        // GRADUATION SHORTCUT — MULTI-OPTION ENGINE
        // Finds every viable way to shed excess hours from the last
        // First Term into the preceding Second Term so the last
        // semester drops to ≤ 12 h and converts to a Summer.
        // ============================================================

        // Stored options (array) for the currently displayed plan
        let _shortcutOptions = [];

        // ── Helper: generate all combinations of `size` from `arr` ──
        function getCombinations(arr, size) {
          if (size === 1) return arr.map(x => [x]);
          const result = [];
          for (let i = 0; i <= arr.length - size; i++) {
            getCombinations(arr.slice(i + 1), size - 1).forEach(rest =>
              result.push([arr[i], ...rest])
            );
          }
          return result;
        }

        // ── Compute all valid shortcut options for the current plan ──
        // Returns [] when no shortcut is possible.
        function computeShortcutOptions() {
          const plan = generatedPlans[currentPlanIndex];
          if (!plan || plan.semesters.length < 2) return [];

          const allOptions = [];

          // ════════════════════════════════════════════════════════════════════
          // SCENARIO A  (existing logic)
          // Last semester is a First Term with excess hours that can be shed
          // into the preceding Second Term so it auto-converts to Summer.
          // ════════════════════════════════════════════════════════════════════
          (() => {
            const lastIdx = plan.semesters.length - 1;
            const prevIdx = plan.semesters.length - 2;
            const lastSem = plan.semesters[lastIdx];
            const prevSem = plan.semesters[prevIdx];

            const lastSemIncH = lastSem.courses.reduce((s, c) =>
              incompleteCourseCodes.has(c) ? s + (courses[c]?.hours || 0) : s, 0);
            const lastSemNonIncH = lastSem.hours - lastSemIncH;

            const prevSemIncH = prevSem.courses.reduce((s, c) =>
              incompleteCourseCodes.has(c) ? s + (courses[c]?.hours || 0) : s, 0);

            if (lastSem.isSummer)               return;
            if (!lastSem.name.includes('First')) return;
            const SUMMER_MAX  = 12;
            if (lastSemNonIncH <= SUMMER_MAX)    return; // already auto-converts
            if (prevSem.isSummer)                return;
            if (!prevSem.name.includes('Second'))return;

            const PREV_MAX      = prevSem.isSpecialCase ? 21 : 18;
            const prevAvailable = PREV_MAX - (prevSem.hours - prevSemIncH);
            if (prevAvailable <= 0) return;

            const excessHours = lastSemNonIncH - SUMMER_MAX;
            if (excessHours > prevAvailable) return;

            const completedBeforePrev = new Set(selected);
            for (let i = 0; i < prevIdx; i++)
              plan.semesters[i].courses.forEach(c => completedBeforePrev.add(c));

            const moveable = lastSem.courses.filter(code => {
              if (code === 'PC401' || code === 'PC402') return false;
              if (incompleteCourseCodes.has(code)) return false;
              const c = courses[code];
              return c && c.prerequisites.every(p => completedBeforePrev.has(p));
            });

            if (moveable.length === 0) return;

            const seen = new Set();
            for (let size = 1; size <= Math.min(3, moveable.length); size++) {
              for (const combo of getCombinations(moveable, size)) {
                const moveHours = combo.reduce((s, c) => s + (courses[c]?.hours || 0), 0);
                if (moveHours < excessHours) continue;
                if (moveHours > prevAvailable) continue;
                const key = [...combo].sort().join(',');
                if (seen.has(key)) continue;
                seen.add(key);
                allOptions.push({
                  type: 'scenario-a',
                  toMove:       combo,
                  moveHours,
                  newPrevHours: prevSem.hours   + moveHours,
                  newLastHours: lastSem.hours   - moveHours,
                  prevSemName:  prevSem.name,
                  lastSemName:  lastSem.name,
                  currentSemCount: plan.semesters.length,
                  resultSemCount:  plan.semesters.length - 1,
                });
              }
              if (allOptions.length >= 8) break;
            }

            // Annotate
            allOptions.forEach(o => {
              o.currentSemCount = plan.semesters.length;
              o.resultSemCount  = plan.semesters.length - 1;
            });
          })();

          // ════════════════════════════════════════════════════════════════════
          // SCENARIO B  (new)
          // Detect [ SecTerm_anchor ][ Summer_anchor ][ tail… 2+ semesters ]
          // and offer to collapse the entire tail into:
          //   • SecTerm_anchor upgraded to Special Case (max 21h + Incomplete bypass)
          //   • Summer_anchor upgraded to Special Case (max 12h + Incomplete bypass)
          //
          // KEY RULES:
          //   1. Incomplete (grade "I") courses → always to anchor, bypass BOTH type AND hour cap
          //   2. Regular courses whose semester TYPE matches the anchor → prefer anchor
          //   3. Regular courses whose semester TYPE differs from anchor → prefer summer
          //      (summer accepts all types; only hour cap applies)
          //   4. usedAnchorRegH tracks only regular (non-Incomplete) hours against the 21h cap
          //      Incomplete hours are tracked separately (totalAnchorAdded) for display only
          // ════════════════════════════════════════════════════════════════════
          for (let anchorIdx = 0; anchorIdx <= plan.semesters.length - 4; anchorIdx++) {
            const anchor = plan.semesters[anchorIdx];
            if (anchor.isSummer || !anchor.name.includes('Second')) continue;

            const summer = plan.semesters[anchorIdx + 1];
            if (!summer || !summer.isSummer) continue;

            const tailStart = anchorIdx + 2;
            if (tailStart >= plan.semesters.length) continue;

            // ─ Tail courses to collapse ─
            const tailCourses = [];
            for (let i = tailStart; i < plan.semesters.length; i++)
              tailCourses.push(...plan.semesters[i].courses);
            if (tailCourses.length === 0) continue;

            // ─ Available REGULAR capacity after Special Case upgrade ─
            // (Incomplete courses already in the anchor don't consume regular capacity)
            const anchorIncH = anchor.courses.reduce((s, c) =>
              incompleteCourseCodes.has(c) ? s + (courses[c]?.hours || 0) : s, 0);
            const anchorUsedRegular = anchor.hours - anchorIncH;
            const anchorRegCap = 21 - anchorUsedRegular; // max 21h regular for Special Case

            const summerIncH = summer.courses.reduce((s, c) =>
              incompleteCourseCodes.has(c) ? s + (courses[c]?.hours || 0) : s, 0);
            const summerUsedRegular = summer.hours - summerIncH;
            const summerRegCap = 12 - summerUsedRegular; // max 12h total for Special Case summer

            if (anchorRegCap <= 0 && summerRegCap <= 0) continue;

            // ─ Determine anchor semester type (1=odd/First, 2=even/Second) ─
            const anchorType = 2; // anchor always "Second Term" = even = type 2

            // ─ completed sets ─
            const completedBeforeAnchor = new Set(selected);
            for (let i = 0; i < anchorIdx; i++)
              plan.semesters[i].courses.forEach(c => completedBeforeAnchor.add(c));

            const completedThroughAnchor = new Set(completedBeforeAnchor);
            anchor.courses.forEach(c => completedThroughAnchor.add(c));
            summer.courses.forEach(c => completedThroughAnchor.add(c));

            // ─ Separate: Incomplete vs same-type regular vs diff-type regular ─
            const incTail = tailCourses.filter(c =>
              incompleteCourseCodes.has(c) && c !== 'PC401' && c !== 'PC402' && c !== 'TR');
            const sameTypeTail = tailCourses.filter(c => {
              if (incompleteCourseCodes.has(c) || c === 'PC401' || c === 'PC402' || c === 'TR') return false;
              const cData = courses[c];
              if (!cData) return false;
              return getSemesterType(cData.semester) === anchorType;
            });
            const diffTypeTail = tailCourses.filter(c => {
              if (incompleteCourseCodes.has(c) || c === 'PC401' || c === 'PC402' || c === 'TR') return false;
              const cData = courses[c];
              if (!cData) return false;
              return getSemesterType(cData.semester) !== anchorType;
            });

            // ════════════════════════════════════════════════════════════════
            // MULTI-ASSIGNMENT ENGINE
            // Incomplete (grade "I") courses can go to EITHER the anchor OR the
            // summer — both bypass their respective hour caps. We enumerate all
            // 2^N placements (N = number of incomplete tail courses, usually 0–1)
            // so every valid option is surfaced, not just the anchor-first default.
            //
            // Regular courses follow the original priority rules:
            //   • Same-type → anchor first, summer as fallback
            //   • Diff-type → summer first, anchor as fallback
            //
            // Hours tracked:
            //   _usedAnchorRegH   – regular hours added to anchor  (vs 21h cap)
            //   _totalAnchorDisp  – ALL hours added to anchor       (for display)
            //   _usedSummerRegH   – regular hours added to summer   (vs 12h cap)
            //   _summerDisplayH   – ALL hours added to summer       (for display, incl Incomplete)
            // ════════════════════════════════════════════════════════════════

            function tryCollapse(incForAnchor, incForSummer) {
              const _anchorAdd = [];
              const _summerAdd = [];
              let _usedAnchorRegH  = 0;
              let _totalAnchorDisp = 0;
              let _usedSummerRegH  = 0;
              let _summerDisplayH  = 0;
              // Work on a local copy so repeated calls don't mutate the outer set
              const completedThrough = new Set(completedThroughAnchor);
              let ok = true;

              // ── Incomplete → anchor (bypass anchor type AND hour cap) ────
              for (const code of incForAnchor) {
                const c = courses[code];
                if (!c) { ok = false; break; }
                if (!c.prerequisites.every(p => completedBeforeAnchor.has(p))) { ok = false; break; }
                _anchorAdd.push(code);
                _totalAnchorDisp += c.hours;
                completedThrough.add(code);
              }
              if (!ok) return null;

              // ── Incomplete → summer (bypass summer hour cap) ─────────────
              for (const code of incForSummer) {
                const c = courses[code];
                if (!c) { ok = false; break; }
                if (!c.prerequisites.every(p => completedBeforeAnchor.has(p))) { ok = false; break; }
                _summerAdd.push(code);
                _summerDisplayH += c.hours;
                // DO NOT add to _usedSummerRegH — incomplete bypasses the cap
                completedThrough.add(code);
              }
              if (!ok) return null;

              // ── Same-type regular → anchor first, summer as fallback ─────
              for (const code of sameTypeTail) {
                const c = courses[code];
                if (!c) { ok = false; break; }
                const prereqAnchor = c.prerequisites.every(p => completedBeforeAnchor.has(p));
                if (!prereqAnchor) {
                  const prereqSummer = c.prerequisites.every(p => completedThrough.has(p));
                  if (prereqSummer && _usedSummerRegH + c.hours <= summerRegCap) {
                    _summerAdd.push(code);
                    _usedSummerRegH  += c.hours;
                    _summerDisplayH  += c.hours;
                    completedThrough.add(code);
                  } else { ok = false; break; }
                  continue;
                }
                if (_usedAnchorRegH + c.hours <= anchorRegCap) {
                  _anchorAdd.push(code);
                  _usedAnchorRegH  += c.hours;
                  _totalAnchorDisp += c.hours;
                  completedThrough.add(code);
                } else {
                  const prereqSummer = c.prerequisites.every(p => completedThrough.has(p));
                  if (prereqSummer && _usedSummerRegH + c.hours <= summerRegCap) {
                    _summerAdd.push(code);
                    _usedSummerRegH  += c.hours;
                    _summerDisplayH  += c.hours;
                    completedThrough.add(code);
                  } else { ok = false; break; }
                }
              }
              if (!ok) return null;

              // ── Diff-type regular → summer first, anchor as fallback ─────
              for (const code of diffTypeTail) {
                const c = courses[code];
                if (!c) { ok = false; break; }
                const prereqSummer = c.prerequisites.every(p => completedThrough.has(p));
                if (prereqSummer && _usedSummerRegH + c.hours <= summerRegCap) {
                  _summerAdd.push(code);
                  _usedSummerRegH  += c.hours;
                  _summerDisplayH  += c.hours;
                  completedThrough.add(code);
                } else {
                  const prereqAnchor = c.prerequisites.every(p => completedBeforeAnchor.has(p));
                  if (prereqAnchor && _usedAnchorRegH + c.hours <= anchorRegCap) {
                    _anchorAdd.push(code);
                    _usedAnchorRegH  += c.hours;
                    _totalAnchorDisp += c.hours;
                    completedThrough.add(code);
                  } else { ok = false; break; }
                }
              }
              if (!ok) return null;

              return {
                anchorAdditions: _anchorAdd,
                summerAdditions: _summerAdd,
                toMove: [..._anchorAdd, ..._summerAdd],
                totalAnchorDisp: _totalAnchorDisp,
                summerDisplayH:  _summerDisplayH,
              };
            }

            // ── Build all 2^N incomplete-course assignments ──────────────────
            // Each incomplete course can independently go to anchor or summer.
            // For N=0 → 1 variant; N=1 → 2 variants; N=2 → 4 variants (rare).
            let incAssignments = [{ forAnchor: [], forSummer: [] }];
            for (const code of incTail) {
              const expanded = [];
              for (const asgn of incAssignments) {
                expanded.push({ forAnchor: [...asgn.forAnchor, code], forSummer: [...asgn.forSummer] });
                expanded.push({ forAnchor: [...asgn.forAnchor],       forSummer: [...asgn.forSummer, code] });
              }
              incAssignments = expanded;
            }

            // ── Try each assignment and collect valid options ─────────────────
            for (const asgn of incAssignments) {
              const result = tryCollapse(asgn.forAnchor, asgn.forSummer);
              if (!result) continue;

              const { anchorAdditions, summerAdditions, toMove, totalAnchorDisp, summerDisplayH } = result;
              if (toMove.length === 0) continue;

              const savedSems = plan.semesters.length - (anchorIdx + 2);
              if (savedSems <= 0) continue;

              // ── VALIDATION: no consecutive summers ────────────────────────
              const allTailCourses = [];
              for (let i = tailStart; i < plan.semesters.length; i++)
                allTailCourses.push(...plan.semesters[i].courses);
              const tailNotMoved = allTailCourses.filter(c => !toMove.includes(c));
              if (tailNotMoved.length > 0) {
                const summerIsTROnly = summer.courses.length === 1 && summer.courses[0] === 'TR';
                if (summerIsTROnly) {
                  console.log(`⚠️ Skipping multi-collapse variant: would leave ${tailNotMoved.length} courses after TR summer`);
                  continue;
                }
              }

              // ── DEDUP: skip if identical anchor+summer assignment already recorded ─
              // Key encodes the split, not just the course set, so options that move
              // the same courses but assign them differently are both kept.
              const moveKey =
                'A:' + [...anchorAdditions].sort().join(',') + '|' +
                'S:' + [...summerAdditions].sort().join(',');
              if (allOptions.some(o =>
                o.type === 'multi-collapse' &&
                ('A:' + [...o.anchorAdditions].sort().join(',') + '|' +
                 'S:' + [...o.summerAdditions].sort().join(',')) === moveKey
              )) continue;

              allOptions.push({
                type: 'multi-collapse',
                anchorIdx,
                summerIdx: anchorIdx + 1,
                tailStart,
                anchorAdditions,
                summerAdditions,
                toMove,
                moveHours:      toMove.reduce((s, c) => s + (courses[c]?.hours || 0), 0),
                newAnchorHours: anchor.hours + totalAnchorDisp,
                newSummerHours: summer.hours + summerDisplayH,
                prevSemName:    anchor.name,
                lastSemName:    summer.name,
                anchorName:     anchor.name,
                summerName:     summer.name,
                currentSemCount: plan.semesters.length,
                resultSemCount:  anchorIdx + 2,
                semsSaved:       savedSems,
              });
            } // end assignment loop
          } // end anchorIdx loop

          // Sort: fewest courses to move first, then smallest move hours
          allOptions.sort((a, b) =>
            a.toMove.length - b.toMove.length || a.moveHours - b.moveHours
          );

          return allOptions.slice(0, 8);
        }

        // ── Refresh the shortcut button visibility after any plan change ──
        function refreshShortcutButton() {
          _shortcutOptions = computeShortcutOptions();
          const btn = document.getElementById('shortcutBtn');
          if (!btn) return;
          if (_shortcutOptions.length > 0) {
            btn.classList.add('visible');
          } else {
            btn.classList.remove('visible');
          }
        }

        // ── Open the multi-option modal ──
        function openShortcutModal() {
          _shortcutOptions = computeShortcutOptions();
          if (_shortcutOptions.length === 0) {
            TechBot.notify('No graduation shortcut available for the current plan.');
            return;
          }

          const plan    = generatedPlans[currentPlanIndex];
          const currentSemN = plan.semesters.length;

          // Build subtitle — mention multi-collapse if any Scenario B exists
          const hasMulti = _shortcutOptions.some(o => o.type === 'multi-collapse');
          if (hasMulti) {
            const bestMulti = _shortcutOptions.find(o => o.type === 'multi-collapse');
            document.getElementById('shortcut-modal-subtitle').textContent =
              `Your plan has ${currentSemN} semesters. ` +
              `A graduation shortcut was detected: by moving ${bestMulti.toMove.length} course(s) into ` +
              `"${bestMulti.anchorName}" (as Special Case) and "${bestMulti.summerName}" (as Special Case), ` +
              `the last ${bestMulti.semsSaved} semester(s) can be eliminated — ` +
              `reducing your plan to ${bestMulti.resultSemCount} semesters!`;
          } else {
            const lastSem = plan.semesters[plan.semesters.length - 1];
            const scYearM2 = lastSem.name.match(/(\d{4})/);
            const scYear2  = scYearM2 ? parseInt(scYearM2[1]) : (plan.term1BaseYear || 2025);
            document.getElementById('shortcut-modal-subtitle').textContent =
              `Your plan currently has ${currentSemN} semesters, ending with "${lastSem.name}" (${lastSem.hours}h — a full heavy term). ` +
              `Move some courses into the previous semester so the last term drops to ≤12h and converts to ` +
              `"Summer Special Case ${scYear2}-${scYear2+1}" — a lighter finish that ends earlier in the calendar year.`;
          }

          const grid = document.getElementById('shortcut-options-grid');
          grid.innerHTML = '';

          _shortcutOptions.forEach((opt, idx) => {
            const card = document.createElement('div');
            card.className = 'shortcut-option-card';

            let ribbonText, badge, listItems, prevPreview, summerPreview;

            if (opt.type === 'multi-collapse') {
              // ── Multi-collapse card ──
              const savedLabel = `${opt.semsSaved} semester${opt.semsSaved > 1 ? 's' : ''}`;
              ribbonText = `🎓 <span style="text-decoration:line-through;opacity:0.85;">${opt.currentSemCount} semesters</span> → ${opt.resultSemCount} semesters  🏆 Saves ${savedLabel}!`;

              badge = `<div class="shortcut-option-badge">Option ${idx + 1} — Collapse ${opt.toMove.length} course${opt.toMove.length > 1 ? 's' : ''} (${opt.moveHours}h)</div>`;

              listItems = opt.toMove.map(code => {
                const c = courses[code];
                const isInc = incompleteCourseCodes.has(code);
                return `<li>
                  <span class="shortcut-move-code">${code}</span>
                  <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${c?.name || code}${isInc ? ' ⏳' : ''}</span>
                  <span style="font-size:10px;color:#64748b;margin-right:4px;">${opt.anchorAdditions.includes(code) ? '→ ' + (opt.anchorName.replace(/\d{4}-\d{4}/,'').trim()) : '→ Summer ☀️'}</span>
                  <span class="shortcut-move-hours">${c?.hours || 0}h</span>
                </li>`;
              }).join('');

              const anchorShort = opt.anchorName.replace('Term ', '').replace(/\d{4}-\d{4}/, '').trim();
              const summerShort = opt.summerName.replace('Term ', '').replace(/\d{4}-\d{4}/, '').trim();
              prevPreview = `
                <div class="shortcut-result-row">
                  <span class="shortcut-result-label">📅 ${anchorShort} → ⭐ SC</span>
                  <span class="shortcut-result-hours">
                    <span class="old">${plan.semesters[opt.anchorIdx].hours}h</span>
                    <span class="new">${opt.newAnchorHours}h</span>
                  </span>
                </div>`;
              summerPreview = `
                <div class="shortcut-result-row">
                  <span class="shortcut-result-label">☀️ ${summerShort} → ⭐ SC</span>
                  <span class="shortcut-result-hours">
                    <span class="old">${plan.semesters[opt.summerIdx].hours}h</span>
                    <span class="summer-new">${opt.newSummerHours}h</span>
                  </span>
                </div>`;

            } else {
              // ── Scenario A card (original logic) ──
              const currentRegularCount = plan.semesters.filter(s => !s.isSummer).length;
              const simulatedRegularCount = currentRegularCount - 1;
              ribbonText = `📅 <span style="text-decoration:line-through;opacity:0.85;">${currentRegularCount} semesters</span> → ${simulatedRegularCount} + ☀️ Summer ⭐ Saves ${currentRegularCount - simulatedRegularCount} semester${(currentRegularCount - simulatedRegularCount) > 1 ? 's' : ''}!`;

              badge = `<div class="shortcut-option-badge">Option ${idx + 1} — Move ${opt.toMove.length} course${opt.toMove.length > 1 ? 's' : ''} (${opt.moveHours}h)</div>`;

              listItems = opt.toMove.map(code => {
                const c = courses[code];
                return `<li>
                  <span class="shortcut-move-code">${code}</span>
                  <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${c?.name || code}</span>
                  <span class="shortcut-move-hours">${c?.hours || 0}h</span>
                </li>`;
              }).join('');

              const prevShort  = opt.prevSemName.replace('Term ', '').replace(/\d{4}-\d{4}/, '').trim();
              const lastShort  = opt.lastSemName.replace('Term ', '').replace(/\d{4}-\d{4}/, '').trim();
              prevPreview = `
                <div class="shortcut-result-row">
                  <span class="shortcut-result-label">📅 ${prevShort}</span>
                  <span class="shortcut-result-hours">
                    <span class="old">${plan.semesters[plan.semesters.length - 2].hours}h</span>
                    <span class="new">${opt.newPrevHours}h</span>
                  </span>
                </div>`;
              summerPreview = `
                <div class="shortcut-result-row">
                  <span class="shortcut-result-label">☀️ ${lastShort} → Summer ⭐</span>
                  <span class="shortcut-result-hours">
                    <span class="old">${opt.lastSemName.includes('First') ? plan.semesters[plan.semesters.length - 1].hours + 'h' : ''}</span>
                    <span class="summer-new">${opt.newLastHours}h</span>
                  </span>
                </div>`;
            }

            card.innerHTML = `
              <div class="shortcut-card-ribbon">${ribbonText}</div>
              <div class="shortcut-card-body">
                ${badge}
                <ul class="shortcut-move-list">${listItems}</ul>
                <div class="shortcut-result-preview">${prevPreview}${summerPreview}</div>
                <button class="shortcut-apply-btn" onclick="applyShortcutOption(${idx})">
                  ✅ Apply This Option
                </button>
              </div>`;

            grid.appendChild(card);
          });

          document.getElementById('shortcut-modal').classList.add('show');
        }

        // ── Apply the chosen option ──
        function applyShortcutOption(idx) {
          const opt  = _shortcutOptions[idx];
          const plan = generatedPlans[currentPlanIndex];
          if (!opt || !plan) return;

          // ── SCENARIO B: multi-collapse ──────────────────────────────────────
          if (opt.type === 'multi-collapse') {
            const anchor = plan.semesters[opt.anchorIdx];
            const summer = plan.semesters[opt.summerIdx];

            UndoRedoManager.saveState(
              `Multi-collapse shortcut: moved ${opt.toMove.join(', ')} into ${anchor.name} + ${summer.name}`
            );

            // ── Upgrade anchor to Special Case ──────────────────────────────
            anchor.isSpecialCase = true;

            // Add anchor courses (Incomplete bypass cap, regular within 21h)
            opt.anchorAdditions.forEach(code => {
              if (!anchor.courses.includes(code)) {
                anchor.courses.push(code);
                anchor.hours += courses[code]?.hours || 0;
              }
            });

            // Update incomplete flag for anchor
            anchor.hasIncomplete = anchor.courses.some(c => incompleteCourseCodes.has(c));

            // ── Upgrade summer to Special Case ──────────────────────────────
            summer.isSpecialCase = true;

            // Update summer name to reflect Special Case
            if (!summer.name.includes('Special')) {
              const yrMatch = summer.name.match(/(\d{4})/);
              if (yrMatch) {
                const y = parseInt(yrMatch[1]);
                summer.name = `Summer Term ${y}-${y + 1} ⭐ Special Case`;
              } else {
                summer.name = summer.name + ' ⭐ Special Case';
              }
            }

            // Add summer courses
            opt.summerAdditions.forEach(code => {
              if (!summer.courses.includes(code)) {
                summer.courses.push(code);
                summer.hours += courses[code]?.hours || 0;
              }
            });

            // Update summer incomplete flag
            summer.hasIncomplete = summer.courses.some(c => incompleteCourseCodes.has(c));

            // ── Remove all tail semesters (everything after summerIdx) ──────
            plan.semesters = plan.semesters.slice(0, opt.summerIdx + 1);

            closeShortcutModal();
            displayStudyPlan(currentPlanIndex);
            TechBot.success(
              `🎓 Graduation shortcut applied! Collapsed ${opt.semsSaved} semester(s). ` +
              `${anchor.name} → Special Case (${anchor.hours}h). ` +
              `${summer.name} (${summer.hours}h).`
            );
            return;
          }

          // ── SCENARIO A (original logic) ─────────────────────────────────────
          const lastIdx = plan.semesters.length - 1;
          const prevIdx = plan.semesters.length - 2;
          const lastSem = plan.semesters[lastIdx];
          const prevSem = plan.semesters[prevIdx];

          UndoRedoManager.saveState(
            `Summer shortcut: moved ${opt.toMove.join(', ')} → ${prevSem.name}`
          );

          opt.toMove.forEach(code => {
            const i = lastSem.courses.indexOf(code);
            if (i > -1) {
              lastSem.courses.splice(i, 1);
              lastSem.hours -= courses[code]?.hours || 0;
            }
            prevSem.courses.push(code);
            prevSem.hours += courses[code]?.hours || 0;
          });

          closeShortcutModal();
          // checkAndConvertLastOddSemester inside displayStudyPlan will
          // automatically convert the now-≤12h First Term to Summer.
          displayStudyPlan(currentPlanIndex);
          TechBot.success(`⭐ Graduation shortcut applied! Last semester → Summer Special Case.`);
        }

        function closeShortcutModal() {
          document.getElementById('shortcut-modal').classList.remove('show');
        }

        // Close on backdrop click
        document.addEventListener('click', function(e) {
          const modal = document.getElementById('shortcut-modal');
          if (e.target === modal) closeShortcutModal();
        });

        // Expose globally (called via onclick= in static + dynamic HTML)
        window.openShortcutModal   = openShortcutModal;
        window.closeShortcutModal  = closeShortcutModal;
        window.applyShortcutOption = applyShortcutOption;

        // ============================================================
        // SUMMER BRIDGE ENGINE
        // Detect courses currently scheduled in a First Term that
        // could be moved to a preceding summer semester (because their
        // prerequisites are already met by then). Moving them earlier
        // unlocks their dependents one full term sooner, often
        // collapsing the tail of the plan by 1–2 semesters.
        // ============================================================
        let _bridgeOptions = [];

        // Returns array of bridge options, each describing one
        // (summerSemIdx, courseCode) pair worth suggesting.
        // Also detects "virtual" summer slots — positions after a Second Term
        // that have no existing summer — and offers to insert a new one there.
        function computeBridgeOptions() {
          const plan = generatedPlans[currentPlanIndex];
          if (!plan || plan.semesters.length < 2) return [];

          const options = [];

          // ── Helper: collect bridge candidates for a given summer slot ────────
          // sumIdx        = real index in plan.semesters (-1 for virtual slots)
          // insertAfterIdx = index to splice after when creating a new summer
          // isNewSummer   = true when no real summer exists at that position yet
          // semName / usedH / SUMMER_MAX describe the (real or virtual) summer
          function scanSlot(sumIdx, insertAfterIdx, isNewSummer, semName, usedH, SUMMER_MAX, existingCoursesInSummer) {
            const available = SUMMER_MAX - usedH;

            // Build "completed before this summer" set
            const completedBefore = new Set(selected);
            // For a real summer, include all semesters before it.
            // For a virtual slot, include all semesters up to and including insertAfterIdx.
            const limitIdx = isNewSummer ? insertAfterIdx : sumIdx - 1;
            for (let i = 0; i <= limitIdx; i++)
              plan.semesters[i].courses.forEach(c => completedBefore.add(c));

            // Start of "later" semesters: right after the summer (real) or after insertAfterIdx (virtual).
            // IMPORTANT: Never scan the last semester of the plan — that is exclusively
            // Graduate Earlier's territory (it moves courses from the last First Term
            // into the previous Second Term so the last term converts to a Summer).
            const firstLaterIdx = isNewSummer ? insertAfterIdx + 1 : sumIdx + 1;
            const lastScanIdx   = plan.semesters.length - 2; // stop before the final semester

            for (let laterIdx = firstLaterIdx; laterIdx <= lastScanIdx; laterIdx++) {
              const laterSem = plan.semesters[laterIdx];

              for (const code of [...laterSem.courses]) {
                if (code === 'PC401' || code === 'PC402' || code === 'TR') continue;
                const c = courses[code];
                if (!c) continue;

                if (c.hours > available) continue;

                const prereqsMet = c.prerequisites.every(p => completedBefore.has(p));
                if (!prereqsMet) continue;

                const directDeps = Object.keys(courses).filter(dep =>
                  courses[dep].prerequisites.includes(code) &&
                  plan.semesters.some((s, si) => si >= firstLaterIdx && s.courses.includes(dep))
                );

                const completedAfterBridge = new Set(completedBefore);
                (existingCoursesInSummer || []).forEach(c2 => completedAfterBridge.add(c2));
                completedAfterBridge.add(code);

                const unlockedNow = directDeps.filter(dep =>
                  courses[dep].prerequisites.every(p => completedAfterBridge.has(p))
                );

                // ── Simulate how many semesters remain after applying this bridge ──
                // Collect every course scheduled AFTER the summer slot (excluding the bridged one).
                // Include the last semester here so the simulation counts it correctly.
                const simRemaining = [];
                for (let si = firstLaterIdx; si < plan.semesters.length; si++) {
                  plan.semesters[si].courses.forEach(rc => {
                    if (rc !== code) simRemaining.push(rc);
                  });
                }

                // Compute next term number after this summer
                const simYearM = semName.match(/(\d{4})/);
                const simYear  = simYearM ? parseInt(simYearM[1]) : (plan.term1BaseYear || 2025);
                const simT1b   = plan.term1BaseYear || 2025;
                const simNextTerm = (((simYear + 1) - simT1b) * 2) + 1;

                // Kept semesters count: real=[0..sumIdx], virtual=[0..insertAfterIdx]+newSummer
                const keptCount = isNewSummer ? insertAfterIdx + 2 : sumIdx + 1;

                // Run simulation (generateRemainingPlan is hoisted — available at call time)
                // ── Helper: term order for graduation-date comparison ──────────
                // Lower = earlier graduation. Each unit = ~1 term in calendar.
                // Summer Y-(Y+1) comes AFTER Second Term Y-(Y+1) but BEFORE First Term (Y+1)-(Y+2).
                function _semOrd(s) {
                  if (!s) return 999999;
                  const m = s.name.match(/(\d{4})/);
                  const y = m ? parseInt(m[1]) : 2030;
                  if (s.isSummer || s.name.includes('Summer') || s.name.includes('Special'))
                    return y * 10 + 5;  // Summer after Second Term of same year
                  if (s.name.includes('First'))  return y * 10 + 1;
                  if (s.name.includes('Second')) return y * 10 + 3;
                  return y * 10 + 3;
                }

                let simSemCount, simGradOrd, currentGradOrd, simRegularCount, currentRegularCount;
                try {
                  const simResult = generateRemainingPlan(
                    Array.from(completedAfterBridge),
                    simRemaining,
                    simNextTerm,
                    plan.term1BaseYear
                  );
                  simSemCount = keptCount + simResult.length;

                  // Calculate REGULAR semester counts (excluding summer)
                  const allSimSemesters = [...plan.semesters.slice(0, keptCount), ...simResult];
                  const simMetrics = calculateAcademicMetrics(allSimSemesters);
                  simRegularCount = simMetrics.regularSemesters;
                  
                  const currentMetrics = calculateAcademicMetrics(plan.semesters);
                  currentRegularCount = currentMetrics.regularSemesters;

                  // Fix yearless "Summer Term Special Case" names so _semOrd works correctly
                  simResult.forEach((sem, si) => {
                    if (!sem.name.match(/\d{4}/) && (sem.isSummer || sem.name.includes('Special') || sem.name.includes('Summer'))) {
                      let refYear = null;
                      for (let ri = si - 1; ri >= 0 && !refYear; ri--) {
                        const rm = simResult[ri].name.match(/(\d{4})/);
                        if (rm) refYear = parseInt(rm[1]);
                      }
                      if (!refYear) {
                        // Infer from simNextTerm: term N starts at year t1b + floor((N-1)/2)
                        const tIdx = Math.floor((simNextTerm - 1) / 2) + si;
                        refYear = simT1b + Math.floor(tIdx / 2);
                      }
                      sem.name = `Summer Term ${refYear}-${refYear+1} ⭐ Special Case`;
                    }
                  });

                  // Apply checkAndConvertLastOddSemester equivalent:
                  // if last sim semester is a First Term with ≤12h it would auto-convert to Summer.
                  let lastSim = simResult[simResult.length - 1];
                  if (lastSim && !lastSim.isSummer && lastSim.name.includes('First') && lastSim.hours <= 12) {
                    const prevSim = simResult.length > 1 ? simResult[simResult.length - 2] : null;
                    if (!prevSim || prevSim.name.includes('Second') || prevSim.isSummer) {
                      lastSim = { ...lastSim, isSummer: true }; // mark as summer for ord calc
                    }
                  }

                  // Also check current plan's last semester for the same auto-convert possibility
                  const curLast = plan.semesters[plan.semesters.length - 1];
                  let curLastAdj = curLast;
                  if (curLast && !curLast.isSummer && curLast.name.includes('First') && curLast.hours <= 12) {
                    const curPrev = plan.semesters[plan.semesters.length - 2];
                    if (!curPrev || curPrev.name.includes('Second') || curPrev.isSummer) {
                      curLastAdj = { ...curLast, isSummer: true };
                    }
                  }

                  simGradOrd     = _semOrd(lastSim);
                  currentGradOrd = _semOrd(curLastAdj);

                } catch(e) {
                  simSemCount    = plan.semesters.length;
                  simGradOrd     = 0;
                  currentGradOrd = 0;
                  simRegularCount = plan.semesters.filter(s => !s.isSummer && !s.name.toLowerCase().includes('summer')).length;
                  currentRegularCount = simRegularCount;
                }

                options.push({
                  sumIdx,           // -1 for virtual slots
                  insertAfterIdx,   // index to splice after (used when isNewSummer)
                  isNewSummer,
                  sumName:       semName,
                  sumUsed:       usedH,
                  sumMax:        SUMMER_MAX,
                  laterIdx,
                  laterSemName:  laterSem.name,
                  code,
                  name:          c.name,
                  hours:         c.hours,
                  directDeps,
                  unlockedNow,
                  currentSemCount: plan.semesters.length,
                  simulatedSemCount: simSemCount,
                  currentRegularCount: currentRegularCount,
                  simulatedRegularCount: simRegularCount,
                  currentGradOrd,
                  simGradOrd,
                });
              }
            }
          }

          // ── Pass 1: real existing summer semesters with remaining capacity ──
          plan.semesters.forEach((sem, sumIdx) => {
            if (!sem.isSummer) return;
            const SUMMER_MAX = sem.isSpecialCase ? 12 : 9;
            // Exclude incomplete-course hours from the used-hours count
            // (incomplete courses bypass the cap, so they don't consume capacity)
            const incompleteHoursInSem = sem.courses.reduce((sum, c) =>
              incompleteCourseCodes.has(c) ? sum + (courses[c]?.hours || 0) : sum, 0);
            const effectiveUsedH = sem.hours - incompleteHoursInSem;
            if (effectiveUsedH >= SUMMER_MAX) return;
            scanSlot(sumIdx, sumIdx, false, sem.name, effectiveUsedH, SUMMER_MAX, sem.courses);
          });

          // ── Pass 2: virtual summer slots (after any Second Term with no ──────
          //            summer immediately following it)
          plan.semesters.forEach((sem, idx) => {
            if (sem.isSummer) return;
            if (!sem.name.includes('Second Term')) return;
            // Check the very next semester — if it's already a summer, skip
            const next = plan.semesters[idx + 1];
            if (next && next.isSummer) return;

            // Derive year from the semester name
            const yearMatch = sem.name.match(/(\d{4})/);
            const year = yearMatch ? parseInt(yearMatch[1]) : (plan.term1BaseYear || 2024);
            const virtualName = `Summer ${year}-${year + 1} ☀️ (New)`;

            scanSlot(-1, idx, true, virtualName, 0, 9, []);
          });

          // De-duplicate (same slot+code from multiple laterIdx)
          const seen = new Set();
          const deduped = options.filter(o => {
            const slotKey = o.isNewSummer ? `new:${o.insertAfterIdx}` : `real:${o.sumIdx}`;
            const k = `${slotKey}:${o.code}`;
            if (seen.has(k)) return false;
            seen.add(k);
            return true;
          });

          // Sort: fewest REGULAR semesters first, then earliest graduation order,
          // then most unlocked, then earliest slot position
          deduped.sort((a, b) =>
            a.simulatedRegularCount - b.simulatedRegularCount ||
            a.simGradOrd        - b.simGradOrd        ||
            b.unlockedNow.length - a.unlockedNow.length ||
            (a.isNewSummer ? a.insertAfterIdx : a.sumIdx) - (b.isNewSummer ? b.insertAfterIdx : b.sumIdx) ||
            a.hours - b.hours
          );

          return deduped.slice(0, 8);
        }

        function refreshBridgeButton() {
          _bridgeOptions = computeBridgeOptions();
          const btn = document.getElementById('bridgeBtn');
          if (!btn) return;
          btn.classList.toggle('visible', _bridgeOptions.length > 0);
        }

        function openBridgeModal() {
          _bridgeOptions = computeBridgeOptions();
          if (_bridgeOptions.length === 0) {
            TechBot.notify('No Summer Bridge opportunities found in this plan.');
            return;
          }

          // Group by summer semester for the subtitle
          const summers = [...new Set(_bridgeOptions.map(o => o.sumName))];
          const hasNew = _bridgeOptions.some(o => o.isNewSummer);
          const bestOption = _bridgeOptions[0]; // sorted: fewest semesters / earliest graduation
          const regSemDiffBest = bestOption ? (bestOption.currentRegularCount - bestOption.simulatedRegularCount) : 0;
          const semDiffBest = bestOption ? (bestOption.currentSemCount - bestOption.simulatedSemCount) : 0;
          const gradDiffBest = bestOption ? ((bestOption.currentGradOrd||0) - (bestOption.simGradOrd||0)) : 0;
          let summaryNote = '';
          if (regSemDiffBest > 0) {
            summaryNote = ` Best option saves ${regSemDiffBest} regular semester${regSemDiffBest>1?'s':''}.`;
          } else if (gradDiffBest > 0) {
            summaryNote = ` Best option ends your plan earlier in the calendar.`;
          } else {
            summaryNote = ` Best option unlocks courses earlier.`;
          }
          const subtitleBase = hasNew ? `Some options create a new summer term automatically. ` : ``;
          document.getElementById('bridge-modal-subtitle').textContent =
            subtitleBase +
            `Ranked by graduation date (currently ${bestOption ? bestOption.currentRegularCount : '?'} regular semesters).` +
            summaryNote +
            ` Moving a course into summer unlocks its dependents one full term sooner.`;

          const grid = document.getElementById('bridge-options-grid');
          grid.innerHTML = '';

          _bridgeOptions.forEach((opt, idx) => {
            const card = document.createElement('div');
            card.className = 'bridge-option-card';

            const newSumHours = opt.sumUsed + opt.hours;

            // What gets unlocked now?
            const unlockedHTML = opt.unlockedNow.length > 0
              ? `<div class="bridge-unlock-list">
                   ⚡ Unlocks immediately after summer:<br>
                   <strong>${opt.unlockedNow
                     .map(d => `${d} – ${courses[d]?.name || d}`)
                     .join('<br>')}</strong>
                 </div>`
              : `<div class="bridge-unlock-list" style="background:#fefce8;border-color:#fde68a;color:#92400e;">
                   📦 Frees space in <strong>${opt.laterSemName}</strong>
                 </div>`;

            // Source semester short label
            const srcLabel = opt.laterSemName.replace(/(\d{4}-\d{4})/, '').trim();

            // Badge and optional new-summer note for virtual slots
            const badgeLabel = opt.isNewSummer
              ? `✨ Create ${opt.sumName.replace(' ☀️ (New)','')} + Move`
              : `🌞 Move to ${opt.sumName.replace('Summer Term ', 'Summer ').replace(' ⭐ Special Case','')}`;

            // ══ Compute reduction badge based on REGULAR semesters, not total ══
            const regSemDiff = opt.currentRegularCount - opt.simulatedRegularCount;
            const semDiff  = opt.currentSemCount - opt.simulatedSemCount;
            const gradDiff = (opt.currentGradOrd || 0) - (opt.simGradOrd || 0);

            // Convert graduation order to a short label like "Summer 2027-2028"
            function _ordLabel(ord) {
              if (!ord) return '?';
              const y   = Math.floor(ord / 10);
              const mod = ord % 10;
              if (mod >= 5) return `Summer ${y}-${y+1}`;
              if (mod === 1) return `First Term ${y}-${y+1}`;
              return `Second Term ${y}-${y+1}`;
            }

            let ribbonText, rankLabel;
            if (regSemDiff > 0) {
              // Reduced regular semester count
              ribbonText = `📅 <span style="text-decoration:line-through;opacity:0.85;">${opt.currentRegularCount} semesters</span> → ${opt.simulatedRegularCount} + ☀️ Summer ⭐ Saves ${regSemDiff} semester${regSemDiff>1?'s':''}!`;
              rankLabel = `#${idx + 1} · Saves ${regSemDiff} semester${regSemDiff>1?'s':''}`;
            } else if (gradDiff > 0) {
              // Same count but earlier graduation date
              ribbonText = `📅 ${opt.currentRegularCount} semesters → ${opt.simulatedRegularCount} + ☀️ Summer · Ends ${_ordLabel(opt.simGradOrd)} ✅ Earlier!`;
              rankLabel = `#${idx + 1} · Graduates earlier`;
            } else {
              // No timing improvement - check if summer is at end
              const isAtEnd = opt.insertAfterIdx >= (opt.currentSemCount - 1);
              const yearText = isAtEnd 
                ? 'Still completes in the same year'
                : 'Unlocks courses earlier';
              
              ribbonText = `📅 ${opt.currentRegularCount} semesters (unchanged) · ${yearText}`;
              rankLabel = isAtEnd ? `#${idx + 1} · Extends final year` : `#${idx + 1} · Unlocks earlier`;
            }

            const newSummerNote = opt.isNewSummer
              ? `<div style="font-size:11px;color:#0369a1;background:#e0f2fe;border:1px solid #bae6fd;border-radius:5px;padding:4px 8px;margin-bottom:8px;">
                   🆕 A new summer semester will be automatically added to your plan.
                 </div>`
              : '';

            card.innerHTML = `
              <div class="bridge-card-ribbon">${ribbonText}</div>
              <div class="bridge-card-body">
                <div class="bridge-option-badge">
                  ${badgeLabel} &nbsp;·&nbsp; <span style="opacity:.75;font-weight:500;">${rankLabel}</span>
                </div>
                ${newSummerNote}
                <div style="margin-bottom:10px;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                    <span style="font-family:monospace;background:#f3f4f6;padding:2px 7px;border-radius:5px;font-size:12px;">${opt.code}</span>
                    <span style="font-weight:700;font-size:14px;color:#0f172a;flex:1;">${opt.name}</span>
                    <span style="font-weight:700;color:#d97706;">${opt.hours}h</span>
                  </div>
                  <div style="font-size:12px;color:#64748b;">
                    Currently in: <strong>${srcLabel}</strong>
                  </div>
                </div>
                <div class="shortcut-result-preview" style="border-color:#fde68a;background:#fffbeb;">
                  <div class="shortcut-result-row">
                    <span class="shortcut-result-label" style="color:#92400e;">☀️ ${opt.sumName.replace('Term ','').replace(' ☀️ (New)','').replace(/\d{4}-\d{4}/,'').trim()}</span>
                    <span class="shortcut-result-hours">
                      <span class="old">${opt.isNewSummer ? '0h' : opt.sumUsed+'h'} / ${opt.sumMax}h</span>
                      <span class="new">${newSumHours}h / ${opt.sumMax}h</span>
                    </span>
                  </div>
                </div>
                ${unlockedHTML}
                <button class="bridge-apply-btn" onclick="applyBridgeOption(${idx})">
                  ✅ Apply This Bridge
                </button>
              </div>`;

            grid.appendChild(card);
          });

          const modal = document.getElementById('bridge-modal');
          modal.style.display = 'flex';
        }

        function applyBridgeOption(idx) {
          const opt  = _bridgeOptions[idx];
          const plan = generatedPlans[currentPlanIndex];
          if (!opt || !plan) return;

          UndoRedoManager.saveState(
            `Summer Bridge: moved ${opt.code} to ${opt.sumName}`
          );

          let realSumIdx = opt.sumIdx;

          // ── If this targets a virtual slot, insert a new summer semester ──
          if (opt.isNewSummer) {
            const afterSem = plan.semesters[opt.insertAfterIdx];
            const yearMatch = afterSem.name.match(/(\d{4})/);
            const year = yearMatch ? parseInt(yearMatch[1]) : (plan.term1BaseYear || 2024);

            const newSummer = {
              name: `Summer Term ${year}-${year + 1}`,
              courses: [],
              hours: 0,
              isSummer: true,
              isSpecialCase: false
            };

            // Insert the new summer immediately after the Second Term
            plan.semesters.splice(opt.insertAfterIdx + 1, 0, newSummer);
            realSumIdx = opt.insertAfterIdx + 1;

            // laterIdx has shifted by 1 because of the splice
            opt.laterIdx += 1;
          }

          const sumSem   = plan.semesters[realSumIdx];
          const laterSem = plan.semesters[opt.laterIdx];

          // Move course from its source semester to the summer
          const i = laterSem.courses.indexOf(opt.code);
          if (i > -1) {
            laterSem.courses.splice(i, 1);
            laterSem.hours -= opt.hours;
          }
          sumSem.courses.push(opt.code);
          sumSem.hours += opt.hours;

          closeBridgeModal();

          // Replan everything from the semester AFTER the summer so the
          // newly-unlocked dependents get pulled forward automatically.
          replanAfterMove(realSumIdx);
          TechBot.success(
            `🌞 Bridge applied! ${opt.code} moved to ${sumSem.name}. ` +
            `Plan re-optimized — check if semester count reduced!`
          );
        }

        function closeBridgeModal() {
          document.getElementById('bridge-modal').style.display = 'none';
        }

        // Close bridge modal on backdrop click
        document.addEventListener('click', function(e) {
          const m = document.getElementById('bridge-modal');
          if (e.target === m) closeBridgeModal();
        });

        window.openBridgeModal   = openBridgeModal;
        window.closeBridgeModal  = closeBridgeModal;
        window.applyBridgeOption = applyBridgeOption;

        // ============================================================
        // MERGE CONSECUTIVE SUMMER TERMS
        // After drag-and-drop operations, if the last two semesters
        // are both summer terms with no regular semester between them,
        // merge them into a single summer special case.
        // ============================================================
        function mergeConsecutiveSummerTerms(plan) {
          if (!plan || !plan.semesters || plan.semesters.length < 2) return;
          
          const semesters = plan.semesters;
          const lastIdx = semesters.length - 1;
          const last = semesters[lastIdx];
          const secondLast = semesters[lastIdx - 1];
          
          // Check if last two are both summer terms
          if (!last.isSummer || !secondLast.isSummer) return;
          
          // Calculate hours (excluding incomplete courses for threshold check)
          const calculateNonIncompleteHours = (semester) => {
            return semester.courses.reduce((sum, code) => {
              if (incompleteCourseCodes.has(code)) return sum;
              return sum + (courses[code]?.hours || 0);
            }, 0);
          };
          
          const lastNonIncHours = calculateNonIncompleteHours(last);
          const secondLastNonIncHours = calculateNonIncompleteHours(secondLast);
          const combinedNonIncHours = lastNonIncHours + secondLastNonIncHours;
          
          // Only merge if combined non-incomplete hours ≤ 12
          if (combinedNonIncHours > 12) {
            // Too many hours to merge - convert last summer to regular semester
            console.log(`⚠️ Consecutive summers detected but combined ${combinedNonIncHours}h > 12h - converting last summer to regular semester`);
            
            // Determine what regular semester it should be
            // If second-last is Summer Term YYYY-YYYY+1, next should be First Term YYYY+1-YYYY+2
            const yearMatch = secondLast.name.match(/(\d{4})/);
            if (yearMatch) {
              const baseYear = parseInt(yearMatch[1]) + 1;
              last.isSummer = false;
              last.isSpecialCase = false;
              last.name = `First Term ${baseYear}-${baseYear + 1}`;
              console.log(`   → Converted to: ${last.name}`);
            }
            return;
          }
          
          // Merge is possible - combine courses
          console.log(`🔄 Merging consecutive summer terms: ${secondLast.name} + ${last.name}`);
          console.log(`   Non-incomplete hours: ${secondLastNonIncHours}h + ${lastNonIncHours}h = ${combinedNonIncHours}h ≤ 12h`);
          
          // Combine all courses
          const allCourses = [...secondLast.courses, ...last.courses];
          const totalHours = allCourses.reduce((sum, code) => {
            return sum + (courses[code]?.hours || 0);
          }, 0);
          const hasIncomplete = allCourses.some(c => incompleteCourseCodes.has(c));
          
          // Extract year from second-last summer
          const yearMatch = secondLast.name.match(/(\d{4})/);
          const year = yearMatch ? parseInt(yearMatch[1]) : new Date().getFullYear();
          
          // Update second-last to be the merged summer
          secondLast.courses = allCourses;
          secondLast.hours = totalHours;
          secondLast.isSpecialCase = true; // Always special case when merging
          secondLast.hasIncomplete = hasIncomplete;
          secondLast.name = `Summer Term ${year}-${year + 1} ⭐ Special Case`;
          
          // Remove the last semester
          plan.semesters.splice(lastIdx, 1);
          
          console.log(`   ✅ Merged into: ${secondLast.name} (${totalHours}h, ${allCourses.length} courses)`);
          TechBot.success(`Merged consecutive summer terms into one: ${totalHours}h total`);
        }

        function displayStudyPlan(planIndex) {
          const plan = generatedPlans[planIndex];
          if (!plan) return;

          // Auto-convert last odd semester to summer if hours dropped to ≤ 12
          checkAndConvertLastOddSemester(plan);
          
          // Merge consecutive summer terms if they exist
          mergeConsecutiveSummerTerms(plan);

          // Calculate initial completed hours (before the plan starts)
          const initialCompletedHours = selected.reduce((sum, code) => {
            if (code === 'BMA001') return sum;
            return sum + (courses[code]?.hours || 0);
          }, 0);

          const displayDiv = document.getElementById('studyPlanDisplay');
          displayDiv.innerHTML = '';

          // Add action buttons at top
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'semester-actions';
          actionsDiv.innerHTML = `
            <button class="reset-plan-btn" id="resetPlanBtn">
              🔄 Reset Plan
            </button>
            <button class="export-btn" id="exportTextBtn">
              📄 Export as Text
            </button>
            <button class="export-btn xlsx" id="exportXlsxBtn">
              📊 Export as XLSX
            </button>
            <button class="export-btn pdf-btn" id="exportPdfBtn">
              🖨️ Export as PDF
            </button>
            <button class="shortcut-btn" id="shortcutBtn" onclick="openShortcutModal()">
              ⚡ Graduate Earlier?
            </button>
            <button class="bridge-btn" id="bridgeBtn" onclick="openBridgeModal()">
              🌞 Summer Bridge?
            </button>
            <div id="validationMessage"></div>
          `;
          displayDiv.appendChild(actionsDiv);

          plan.semesters.forEach((semester, semesterIndex) => {
            const semesterCard = document.createElement('div');
            semesterCard.className = `semester-card ${semester.isSummer ? 'summer-semester' : ''} ${semester.isSpecialCase ? 'special-case-active' : ''} ${semester.hasIncomplete ? 'has-incomplete-semester' : ''}`;
            semesterCard.dataset.semesterIndex = semesterIndex;

            // Calculate gained hours up to this semester (including initial completed hours)
            let gainedHours = initialCompletedHours;
            for (let i = 0; i <= semesterIndex; i++) {
              gainedHours += plan.semesters[i].hours;
            }
            
            // Calculate remaining hours
            const totalRequiredHours = 135;
            const remainingHours = totalRequiredHours - gainedHours;
            
            // Count number of courses in this semester
            const courseCount = semester.courses.length;

            // Special case star toggle
            const maxHoursLabel = semester.isSummer
              ? (semester.isSpecialCase ? '12h max' : '9h max')
              : (semester.isSpecialCase ? '21h max' : '18h max');
            const starToggleHTML = `
              <button class="special-case-toggle ${semester.isSpecialCase ? 'active' : ''}" 
                      data-semester-index="${semesterIndex}" 
                      title="${semester.isSpecialCase ? 'Remove special case' : 'Mark as special case (increases hour limit)'}">
                ${semester.isSpecialCase ? '⭐ Special Case' : '☆'}
              </button>`;
            
            // Incomplete semester label
            const incompleteBadgeHTML = semester.hasIncomplete
              ? `<span style="background:linear-gradient(135deg,#d97706,#b45309);color:white;font-size:11px;font-weight:700;padding:3px 10px;border-radius:99px;letter-spacing:0.3px;" title="Contains incomplete course(s) — hour cap bypassed">⏳ +Incomplete</span>`
              : '';
            
            const semesterHeader = document.createElement('div');
            semesterHeader.className = 'semester-header';
            semesterHeader.innerHTML = `
              <span class="semester-title">${semester.name}</span>
              <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                ${incompleteBadgeHTML}
                ${starToggleHTML}
                <span class="semester-hours" id="hours-${semesterIndex}">${semester.hours}h (${courseCount} courses) (${maxHoursLabel.toUpperCase()})</span>
                ${semester.isSummer ? '<button class="delete-semester-btn" data-semester="' + semesterIndex + '">❌ Delete</button>' : ''}
              </div>
            `;

            const coursesDiv = document.createElement('div');
            coursesDiv.className = 'semester-courses';
            coursesDiv.dataset.semesterIndex = semesterIndex;

            // Add placeholder if empty
            if (semester.courses.length === 0) {
              coursesDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">Drop courses here</div>';
            }

            // Make drop zone
            coursesDiv.addEventListener('dragover', handleDragOver);
            coursesDiv.addEventListener('drop', handleDrop);
            coursesDiv.addEventListener('dragleave', handleDragLeave);

            semester.courses.forEach((code, courseIndex) => {
              const course = courses[code];
              if (!course) return;
              
              const isIncomplete = incompleteCourseCodes.has(code);
              const courseItem = document.createElement('div');
              courseItem.className = 'semester-course-item' + (isIncomplete ? ' incomplete-course-item' : '');
              courseItem.draggable = true;
              courseItem.dataset.courseCode = code;
              courseItem.dataset.semesterIndex = semesterIndex;
              courseItem.dataset.courseIndex = courseIndex;
              
              const incBadge = isIncomplete
                ? `<span style="background:#d97706;color:white;font-size:10px;font-weight:700;padding:2px 6px;border-radius:99px;margin-left:6px;letter-spacing:0.3px;flex-shrink:0;animation:incompletePulse 2s ease-in-out infinite;">⏳ INCOMPLETE</span>`
                : '';
              
              courseItem.innerHTML = `
                <span class="course-drag-handle">⋮⋮</span>
                <span class="semester-course-code">${code}</span>
                <span style="flex:1;">${course.name} (${course.hours}h)${incBadge}</span>
                <button class="course-remove-btn" data-code="${code}" data-semester="${semesterIndex}" title="Remove course (cascades dependents)">✕</button>
              `;

              // Drag events
              courseItem.addEventListener('dragstart', handleDragStart);
              courseItem.addEventListener('dragend', handleDragEnd);

              // Remove button
              courseItem.querySelector('.course-remove-btn').addEventListener('click', function(e) {
                e.stopPropagation();
                const code = this.dataset.code;
                const semIdx = parseInt(this.dataset.semester);
                removeCourseFromPlan(code, semIdx);
              });

              coursesDiv.appendChild(courseItem);
            });

            semesterCard.appendChild(semesterHeader);
            semesterCard.appendChild(coursesDiv);

            // Gained/Remaining footer at bottom of card
            const cardFooter = document.createElement('div');
            cardFooter.className = 'semester-footer';
            cardFooter.id = `footer-${semesterIndex}`;
            cardFooter.innerHTML = `
              <span class="footer-gained">📈 Gained: <strong>${gainedHours}h</strong></span>
              <span class="footer-sep">|</span>
              <span class="footer-remaining">🎯 Remaining: <strong>${remainingHours}h</strong></span>
            `;
            semesterCard.appendChild(cardFooter);
            
            // Add "Add Summer After This Semester" button ONLY after Second semesters (Spring)
            // Summer comes after spring, not after fall
            const isSecondSemester = semester.name.includes('Second Term') || semester.isSummer;
            
            if (isSecondSemester || semesterIndex === plan.semesters.length - 1) {
              // Show after second semesters or after the last semester (for flexibility)
              const addSummerDiv = document.createElement('div');
              addSummerDiv.style.textAlign = 'center';
              addSummerDiv.style.margin = '8px 0';
              addSummerDiv.innerHTML = `
                <button class="add-summer-after-btn" data-after-index="${semesterIndex}">
                  ☀️ Add Summer After This
                </button>
              `;
              semesterCard.appendChild(addSummerDiv);
            }
            
            displayDiv.appendChild(semesterCard);
          });

          // Add summary
          updatePlanSummary(plan);

          // Add event listeners for action buttons
          document.getElementById('resetPlanBtn').addEventListener('click', resetPlan);
          document.getElementById('exportTextBtn').addEventListener('click', () => exportAsText(planIndex));
          document.getElementById('exportXlsxBtn').addEventListener('click', () => exportAsXlsx(planIndex));
          document.getElementById('exportPdfBtn').addEventListener('click', () => exportStudyPlanAsPDF());
          
          // Delete semester buttons
          document.querySelectorAll('.delete-semester-btn').forEach(btn => {
            btn.addEventListener('click', function() {
              const semIndex = parseInt(this.dataset.semester);
              deleteSemester(semIndex);
            });
          });

          // Add summer after buttons
          document.querySelectorAll('.add-summer-after-btn').forEach(btn => {
            btn.addEventListener('click', function() {
              const afterIndex = parseInt(this.dataset.afterIndex);
              addSummerSemesterAfter(afterIndex);
            });
          });

          // Special case star toggle buttons
          document.querySelectorAll('.special-case-toggle').forEach(btn => {
            btn.addEventListener('click', function() {
              const semIdx = parseInt(this.dataset.semesterIndex);
              toggleSpecialCase(semIdx);
            });
          });
          
          // Auto-scroll to show the generated plan
          autoScrollToStudyPlan();

          // Update the ⚡ Graduate Earlier? button visibility
          refreshShortcutButton();
          // Update the 🌞 Summer Bridge? button visibility
          refreshBridgeButton();
        }

        // Update plan summary
        function updatePlanSummary(plan) {
          const displayDiv = document.getElementById('studyPlanDisplay');
          
          // Remove old summary if exists
          const oldSummary = displayDiv.querySelector('.plan-summary');
          if (oldSummary) oldSummary.remove();

          const totalHours = plan.semesters.reduce((sum, sem) => sum + sem.hours, 0);
          const totalSemesters = plan.semesters.length;
          const normalSemesters = plan.semesters.filter(s => !s.isSummer).length;
          const summerSemesters = plan.semesters.filter(s => s.isSummer).length;

          const summary = document.createElement('div');
          summary.className = 'plan-summary';
          summary.innerHTML = `
            <div class="plan-summary-title">📊 Plan Summary</div>
            <div class="plan-summary-stats">
              <div><strong>Total Hours:</strong> ${totalHours}h</div>
              <div><strong>Total Semesters:</strong> ${totalSemesters}</div>
              <div><strong>Normal Semesters:</strong> ${normalSemesters}</div>
              <div><strong>Summer Semesters:</strong> ${summerSemesters}</div>
            </div>
          `;
          displayDiv.appendChild(summary);
        }

        // Export as Text
        function exportAsText(planIndex) {
          const plan = generatedPlans[planIndex];
          if (!plan) return;

          let textContent = `Study Plan - ${plan.name}\n`;
          textContent += `=${'='.repeat(60)}\n\n`;
          
          // Student info
          if (studentInfo) {
            textContent += `Student: ${studentInfo.name || 'N/A'}\n`;
            textContent += `ID: ${studentInfo.id || 'N/A'}\n`;
            textContent += `Level: ${studentInfo.level || 'N/A'}\n`;
          }
          
          const totalHours = plan.semesters.reduce((sum, sem) => sum + sem.hours, 0);
          const completedHours = selected.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
          const remainingHours = 135 - completedHours;
          
          textContent += `Total Credits: ${completedHours}/135\n`;
          textContent += `GPA: ${studentInfo?.gpa || '0.00'}\n`;
          textContent += `Generated: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}\n`;
          textContent += `\n${'-'.repeat(60)}\n\n`;

          plan.semesters.forEach((semester, index) => {
            // Calculate gained hours up to this semester (including initial completed hours)
            let gainedHours = completedHours;
            for (let i = 0; i <= index; i++) {
              gainedHours += plan.semesters[i].hours;
            }
            
            // Calculate remaining hours
            const remainingHours = 135 - gainedHours;
            const courseCount = semester.courses.length;
            
            const specialCase = semester.isSpecialCase ? ' ⭐ Special Case' : '';
            textContent += `${semester.name} - ${semester.hours} hours (${courseCount} courses)${specialCase}\n`;
            textContent += `Gained: ${gainedHours}h | Remaining: ${remainingHours}h\n`;
            textContent += `${'-'.repeat(60)}\n`;
            
            semester.courses.forEach(code => {
              const course = courses[code];
              if (course) {
                textContent += `  ${code.padEnd(10)} ${course.name.padEnd(45)} ${course.hours}h\n`;
              }
            });
            textContent += `\n`;
          });

          textContent += `${'-'.repeat(60)}\n`;
          textContent += `TOTAL: ${totalHours}h | ${plan.semesters.length} Semesters\n`;
          textContent += `${'-'.repeat(60)}\n`;
          textContent += `\nStudy Plan generated by Course Planning System\n`;
          textContent += `This plan is subject to course availability and prerequisite validation\n`;

          // Download
          const blob = new Blob([textContent], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Study_Plan_${plan.name.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.txt`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Export as XLSX
        function exportAsXlsx(planIndex) {
          const plan = generatedPlans[planIndex];
          if (!plan) return;

          // Create workbook matching the reference Excel structure
          const wb = XLSX.utils.book_new();
          const data = [];
          
          // Row 1-2: Empty
          data.push([]);
          data.push([]);
          
          // Rows 3-6: Student Information in columns H-I
          const studentName = studentInfo?.name || 'Student Name';
          const studentId = studentInfo?.id || 'N/A';
          const studentCenter = studentInfo?.level || 'Computer Science Program';
          const completedHours = selected.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
          const studentGPA = studentInfo?.gpa || '0.00';
          
          data.push(['', '', '', '', '', '', '', 'Name:', studentName]);
          data.push(['', '', '', '', '', '', '', 'ID:', studentId]);
          data.push(['', '', '', '', '', '', '', 'Center:', studentCenter]);
          data.push(['', '', '', '', '', '', '', 'Gained Hours:', completedHours]);
          data.push(['', '', '', '', '', '', '', 'GPA:', studentGPA]);
          
          // Row 8: Empty
          data.push([]);
          
          // Row 9: Header for completed courses
          data.push(['', '', '', '', '', '', '', 'All Passed Till Now', 'Hours']);
          
          // Add completed courses
          const completedStartRow = data.length + 1; // Excel is 1-indexed
          let math0Row = null;
          
          selected.forEach((code, index) => {
            const course = courses[code];
            if (course) {
              data.push(['', '', '', '', '', '', '', course.name, course.hours]);
              // Track Mathematics - 0 or similar for formula
              if (course.name.includes('Mathematics - 0') || course.name.includes('Mathematics-0')) {
                math0Row = completedStartRow + index;
              }
            }
          });
          
          const completedEndRow = data.length;
          
          // Completed courses total with formula
          const completedTotalFormula = math0Row 
            ? `SUM(I${completedStartRow}:I${completedEndRow})-I${math0Row}`
            : `SUM(I${completedStartRow}:I${completedEndRow})`;
          data.push(['', '', '', '', '', '', '', 'Total Hours', { f: completedTotalFormula }]);
          const completedTotalRow = data.length;
          
          // Empty row
          data.push([]);
          
          // Planned semesters
          const semesterTotalRows = [];
          plan.semesters.forEach((semester) => {
            // Semester header
            const semesterTitle = semester.name || 'Semester';
            data.push(['', '', '', '', '', '', '', semesterTitle, 'Hours']);
            
            const semStartRow = data.length + 1;
            semester.courses.forEach(code => {
              const course = courses[code];
              if (course) {
                data.push(['', '', '', '', '', '', '', course.name, course.hours]);
              }
            });
            const semEndRow = data.length;
            
            // Semester total with formula - only add "دواعي تخرج" if special case
            const totalRow = ['', '', '', '', '', '', '', 'Total Hours', { f: `SUM(I${semStartRow}:I${semEndRow})` }];
            if (semester.isSpecialCase) {
              totalRow.push('دواعي تخرج');
            }
            data.push(totalRow);
            semesterTotalRows.push(data.length);
            
            // Empty row after each semester
            data.push([]);
          });
          
          // Grand total
          const semTotalRefs = semesterTotalRows.map(row => `I${row}`).join(',');
          const grandTotalFormula = semesterTotalRows.length > 0
            ? `SUM(I${completedTotalRow},${semTotalRefs})`
            : `I${completedTotalRow}`;
          data.push(['', '', '', '', '', '', '', 'Total Hours', { f: grandTotalFormula }]);
          
          // Create worksheet from data
          const ws = XLSX.utils.aoa_to_sheet(data);
          
          // Set column widths matching reference structure
          ws['!cols'] = [
            {wch: 3}, {wch: 3}, {wch: 3}, {wch: 3}, {wch: 3}, {wch: 3}, {wch: 3},
            {wch: 45}, {wch: 12}, {wch: 15}
          ];
          
          // Add worksheet to workbook
          XLSX.utils.book_append_sheet(wb, ws, 'Student Plan');
          
          // Generate filename with Arabic support
          const filename = `دواعي_تخرج_-_${studentName.replace(/\s+/g, '_')}_-_${studentId}.xlsx`;
          
          // Download
          XLSX.writeFile(wb, filename);
          
          TechBot.success('Excel file exported successfully! ✅');
        }

        // Drag and Drop Handlers
        let draggedElement = null;
        let draggedCourseCode = null;
        let draggedFromSemester = null;
        let autoScrollInterval = null;
        let scrollSpeed = 0;

        function handleDragStart(e) {
          draggedElement = e.target;
          draggedCourseCode = e.target.dataset.courseCode;
          // -1 means dragging from an external source (courses table or remaining list)
          draggedFromSemester = e.target.dataset.semesterIndex !== undefined 
            ? parseInt(e.target.dataset.semesterIndex) 
            : -1;
          
          e.target.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', draggedCourseCode);
        }

        function handleDragEnd(e) {
          e.target.classList.remove('dragging');
          e.target.style.opacity = '';
          
          // Clear drag state so stale values can never be re-used
          draggedCourseCode = null;
          draggedFromSemester = null;
          draggedElement = null;
          
          // Stop auto-scrolling
          if (autoScrollInterval) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
            scrollSpeed = 0;
          }
          
          // Remove all drag-over effects
          document.querySelectorAll('.semester-courses').forEach(el => {
            el.classList.remove('drag-over');
          });
          document.querySelectorAll('.semester-card').forEach(el => {
            el.classList.remove('invalid-drop');
          });
        }

        function handleDragOver(e) {
          if (e.preventDefault) {
            e.preventDefault();
          }
          
          const dropZone = e.target.closest('.semester-courses');
          if (dropZone) {
            dropZone.classList.add('drag-over');
          }
          
          e.dataTransfer.dropEffect = 'move';
          
          // Auto-scroll when dragging near edges
          const scrollThreshold = 100; // Distance from edge to trigger scroll (pixels)
          const maxScrollSpeed = 20; // Maximum scroll speed (pixels per frame)
          const mouseY = e.clientY;
          const windowHeight = window.innerHeight;
          
          // Calculate scroll speed based on proximity to edge
          let newScrollSpeed = 0;
          
          if (mouseY < scrollThreshold) {
            // Near top edge - scroll up
            const proximity = 1 - (mouseY / scrollThreshold);
            newScrollSpeed = -Math.ceil(proximity * maxScrollSpeed);
          } else if (mouseY > windowHeight - scrollThreshold) {
            // Near bottom edge - scroll down
            const proximity = (mouseY - (windowHeight - scrollThreshold)) / scrollThreshold;
            newScrollSpeed = Math.ceil(proximity * maxScrollSpeed);
          }
          
          // Update scroll speed
          scrollSpeed = newScrollSpeed;
          
          // Start or stop scrolling interval
          if (scrollSpeed !== 0 && !autoScrollInterval) {
            autoScrollInterval = setInterval(() => {
              if (scrollSpeed !== 0) {
                window.scrollBy(0, scrollSpeed);
              }
            }, 16); // ~60fps
          } else if (scrollSpeed === 0 && autoScrollInterval) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
          }
          
          return false;
        }

        function handleDragLeave(e) {
          const dropZone = e.target.closest('.semester-courses');
          if (dropZone && !dropZone.contains(e.relatedTarget)) {
            dropZone.classList.remove('drag-over');
          }
        }

        // Drop guard — prevents double-fire within the same browser tick
        let _dropHandled = false;
        // ============================================================
        // VALIDATE SUMMER/NORMAL SEMESTER PLACEMENT
        // ============================================================
        function validateSummerPlacement(courseCode, toSemester) {
          const course = courses[courseCode];
          if (!course) return { valid: false, message: 'Course not found' };

          // Rule 1: Summer Training (TR) can ONLY be in summer
          if (isSummerTraining(courseCode)) {
            if (!toSemester.isSummer) {
              return { 
                valid: false, 
                message: 'TR (Summer Training) can ONLY be taken in summer semesters' 
              };
            }
            return { valid: true, message: 'Summer Training placed in summer ✓' };
          }

          // Rule 2: Projects CANNOT be in summer
          if (isProjectCourse(courseCode)) {
            if (toSemester.isSummer) {
              return { 
                valid: false, 
                message: `${course.name} (Project) cannot be taken in summer semester` 
              };
            }
            return { valid: true };
          }

          // Rule 3: For summer semesters - all other courses CAN be placed
          if (toSemester.isSummer) {
            // Check hour limits — incomplete courses (grade "I") are exempt
            const maxSummerHours = toSemester.isSpecialCase ? 12 : 9;
            const newHours = toSemester.hours + course.hours;
            
            if (newHours > maxSummerHours) {
              // Exception: incomplete (grade "I") courses bypass the cap
              if (incompleteCourseCodes.has(courseCode)) {
                return {
                  valid: true,
                  message: `⏳ Incomplete course exception — cap bypassed (${newHours}h in summer)`
                };
              }
              return { 
                valid: false, 
                message: `Summer limit is ${maxSummerHours}h — adding this would reach ${newHours}h` 
              };
            }
            
            // Electives get a message that they CAN be in summer
            if (isElectiveCourse(courseCode)) {
              return { 
                valid: true, 
                message: `✓ Elective course placed in summer (can help reduce graduation time)` 
              };
            }
            
            return { valid: true, message: '✓ Course placed in summer' };
          }

          // Rule 4: For normal semesters - TR cannot be placed
          if (isSummerTraining(courseCode)) {
            return { 
              valid: false, 
              message: 'TR (Summer Training) can ONLY be taken in summer semesters' 
            };
          }

          return { valid: true };
        }



        function handleDrop(e) {
          if (e.stopPropagation) e.stopPropagation();
          e.preventDefault();

          // Stop auto-scrolling
          if (autoScrollInterval) {
            clearInterval(autoScrollInterval);
            autoScrollInterval = null;
            scrollSpeed = 0;
          }

          // Guard: ignore if this drop was already handled this tick
          if (_dropHandled) return;
          _dropHandled = true;
          setTimeout(() => { _dropHandled = false; }, 0);

          // Guard: no course being dragged
          if (!draggedCourseCode) return;

          const dropTarget = e.target.closest('.semester-courses');
          if (!dropTarget) return;

          const toSemesterIndex = parseInt(dropTarget.dataset.semesterIndex);
          if (isNaN(toSemesterIndex)) return;

          console.log(`Drop event: from ${draggedFromSemester} to ${toSemesterIndex}`);

          // ── External drag (from courses table or remaining courses list) ──
          if (draggedFromSemester === -1) {
            const plan = generatedPlans[currentPlanIndex];
            if (!plan) return;

            const course = courses[draggedCourseCode];
            if (!course) {
              TechBot.error(`Unknown course "${draggedCourseCode}"`);
              return;
            }

            // 1. Already completed / selected by student
            const uniqueSelected = [...new Set(selected)];
            if (uniqueSelected.includes(draggedCourseCode)) {
              TechBot.warning(`"${course.name}" is already marked as completed`);
              return;
            }

            // 2. Already scheduled in any semester of the plan
            const alreadyScheduled = plan.semesters.some(sem =>
              sem.courses.includes(draggedCourseCode)
            );
            if (alreadyScheduled) {
              TechBot.warning(`"${course.name}" is already in the study plan`);
              return;
            }

            const toSemester = plan.semesters[toSemesterIndex];

            // 🆕 NEW: Validate summer/normal placement
            const semesterValidation = validateSummerPlacement(draggedCourseCode, toSemester);
            if (!semesterValidation.valid) {
              TechBot.error(semesterValidation.message);
              return;
            }

            // 4. Prerequisite validation
            const prereqValidation = validatePrerequisites(draggedCourseCode, toSemesterIndex);
            if (!prereqValidation.valid) {
              TechBot.error(prereqValidation.message);
              return;
            }

            // 5. Course-specific constraints (Summer Training, Project 1, Project 2)
            const allSemesters = plan.semesters;
            const completedCredits = CourseConstraints.calculateCompletedCredits(
              document.querySelectorAll('.semester-card'), 
              toSemesterIndex,
              [...new Set(selected)]   // ← include transcript hours so TR 60h check works
            );
            const completedCourses = CourseConstraints.getCompletedCourses(
              document.querySelectorAll('.semester-card'), 
              toSemesterIndex
            );
            
            const semesterType = toSemester.isSummer ? 'Summer' : 
                                (toSemesterIndex % 2 === 0 ? 'Odd' : 'Even');
            
            const constraintCheck = CourseConstraints.canAddCourse(
              course.name, 
              semesterType, 
              toSemesterIndex,
              completedCredits,
              completedCourses
            );
            
            if (!constraintCheck.allowed) {
              TechBot.error(constraintCheck.reason);
              return;
            }

            // Save state for undo
            UndoRedoManager.saveState(`Added ${draggedCourseCode} to ${toSemester.name}`);

            // Odd/Even type warning for external drop
            if (!toSemester.isSummer) {
              const extSemType = getSemesterType(course.semester);
              const extTermType = toSemester.name.includes('First') ? 1 : 2;
              if (extSemType && extSemType !== extTermType) {
                const fl = extSemType === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
                const tl = extTermType === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
                TechBot.warning(`⚠️ "${course.name}" is a ${fl} course added to a ${tl} semester. Check your plan carefully.`);
              }
            }

            // All checks passed — add the course
            toSemester.courses.push(draggedCourseCode);
            toSemester.hours += course.hours;
            if (incompleteCourseCodes.has(draggedCourseCode)) {
              toSemester.hasIncomplete = true;
            }
            displayStudyPlan(currentPlanIndex);
            // Show appropriate success message
            if (semesterValidation.message) {
              TechBot.success(semesterValidation.message);
            } else {
              TechBot.success(`Added "${course.name}" to ${toSemester.name} ✓`);
            }
            return;
          }

          // ── Internal drag (within the study plan) ──

          // Don't drop on same semester
          if (draggedFromSemester === toSemesterIndex) {
            TechBot.error('Course is already in this semester');
            return;
          }

          // Validate the move
          const validation = validateCourseMove(draggedCourseCode, draggedFromSemester, toSemesterIndex);
          if (!validation.valid) {
            TechBot.error(validation.message);
            return;
          }

          moveCourse(draggedCourseCode, draggedFromSemester, toSemesterIndex);
          if (validation.isWarning) {
            TechBot.warning(validation.message);
          } else {
            TechBot.success(validation.message || 'Course moved successfully! ✓');
          }
        }

        // Validate if a course can be moved
        function validateCourseMove(courseCode, fromIndex, toIndex) {
          const plan = generatedPlans[currentPlanIndex];
          const toSemester = plan.semesters[toIndex];
          const course = courses[courseCode];

          if (!course) {
            return { valid: false, message: 'Course not found' };
          }

          // 🆕 NEW: Validate summer/normal placement
          const semesterValidation = validateSummerPlacement(courseCode, toSemester);
          if (!semesterValidation.valid) {
            return semesterValidation;
          }

          // ── Odd/Even semester type mismatch warning ──
          let semesterTypeWarning = null;
          if (!toSemester.isSummer) {
            const courseSemType = getSemesterType(course.semester);
            const toTermType = toSemester.name.includes('First') ? 1 : 2;
            if (courseSemType && courseSemType !== toTermType) {
              const fromLabel = courseSemType === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
              const toLabel   = toTermType   === 1 ? 'First (Odd/Fall)' : 'Second (Even/Spring)';
              semesterTypeWarning = `⚠️ "${course.name}" is a ${fromLabel} semester course being moved to a ${toLabel} semester. This is an irregular placement — double-check your plan.`;
            }
          }

          // Calculate new hours
          const newHours = toSemester.hours + course.hours;
          
          // Check hour limits
          if (toSemester.isSummer) {
            const maxSummerHours = toSemester.isSpecialCase ? 12 : 9;
            if (newHours > maxSummerHours) {
              // Incomplete courses bypass the summer cap
              if (incompleteCourseCodes.has(courseCode)) {
                return {
                  valid: true,
                  message: `⏳ Incomplete course exception — moved to summer above ${maxSummerHours}h cap (now ${newHours}h)`
                };
              }
              return { 
                valid: false, 
                message: `Summer limit is ${maxSummerHours}h (would be ${newHours}h)` 
              };
            }
          } else {
            const maxHours = toSemester.isSpecialCase ? 21 : 18;
            if (newHours > maxHours) {
              // Incomplete courses bypass the regular semester cap
              if (incompleteCourseCodes.has(courseCode)) {
                return {
                  valid: true,
                  message: `⏳ Incomplete course exception — placed above ${maxHours}h cap (now ${newHours}h)`,
                  isWarning: true
                };
              }
              return { 
                valid: false, 
                message: `Semester limit is ${maxHours}h (would be ${newHours}h)` 
              };
            }
          }

          // Check prerequisites are met
          const validation = validatePrerequisites(courseCode, toIndex);
          if (!validation.valid) {
            return validation;
          }

          if (semesterTypeWarning) {
            return { valid: true, message: semesterTypeWarning, isWarning: true };
          }

          // Return success with message if available
          return { 
            valid: true, 
            message: semesterValidation.message || 'Course moved successfully! ✓' 
          };
        }

        // Validate prerequisites for a course in a specific semester
        function validatePrerequisites(courseCode, semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          const course = courses[courseCode];
          
          // Get all courses completed before this semester
          const completedBefore = new Set(selected); // Already completed
          
          for (let i = 0; i < semesterIndex; i++) {
            plan.semesters[i].courses.forEach(code => completedBefore.add(code));
          }

          // Check if all prerequisites are met
          const unmetPrereqs = course.prerequisites.filter(prereq => !completedBefore.has(prereq));
          
          if (unmetPrereqs.length > 0) {
            return { 
              valid: false, 
              message: `Missing prerequisites: ${unmetPrereqs.join(', ')}. Complete these first or move to a later semester.` 
            };
          }

          return { valid: true };
        }

        // Move course between semesters and re-plan
        function moveCourse(courseCode, fromIndex, toIndex) {
          const plan = generatedPlans[currentPlanIndex];
          
          console.log(`Moving ${courseCode} from semester ${fromIndex} to ${toIndex}`);
          
          // Save state for undo
          UndoRedoManager.saveState(`Moved ${courseCode} from ${plan.semesters[fromIndex].name} to ${plan.semesters[toIndex].name}`);
          
          // Store the course being moved
          const movedCourse = courses[courseCode];
          
          // Remove from source semester
          const fromSemester = plan.semesters[fromIndex];
          const courseIndex = fromSemester.courses.indexOf(courseCode);
          if (courseIndex > -1) {
            fromSemester.courses.splice(courseIndex, 1);
            fromSemester.hours -= movedCourse.hours;
            // Update hasIncomplete flag for source semester
            fromSemester.hasIncomplete = fromSemester.courses.some(c => incompleteCourseCodes.has(c));
            console.log(`Removed from semester ${fromIndex}, new hours: ${fromSemester.hours}`);
          }

          // Add to destination semester
          const toSemester = plan.semesters[toIndex];
          toSemester.courses.push(courseCode);
          toSemester.hours += movedCourse.hours;
          // Update hasIncomplete flag for destination semester
          if (incompleteCourseCodes.has(courseCode)) {
            toSemester.hasIncomplete = true;
          }
          console.log(`Added to semester ${toIndex}, new hours: ${toSemester.hours}`);

          // RE-PLAN: Re-optimize from the earlier affected semester
          // If we moved to an earlier semester (toIndex < fromIndex):
          //   - The destination semester (toIndex) is now locked with the new course
          //   - Re-plan from the semester after it to optimize the rest
          // If we moved to a later semester (toIndex > fromIndex):
          //   - The source semester (fromIndex) now has a gap
          //   - Re-plan from fromIndex to fill the gap and optimize
          
          const replanStartIndex = toIndex < fromIndex ? toIndex : fromIndex;
          console.log(`Triggering re-plan from semester ${replanStartIndex} onwards`);
          replanAfterMove(replanStartIndex);
          
          console.log('Move completed');
        }

        // Re-plan remaining semesters after a course move
        function replanAfterMove(fromIndex) {
          const plan = generatedPlans[currentPlanIndex];
          
          console.log(`Re-planning from semester ${fromIndex} onwards`);
          TechBot.notify('Re-optimizing plan...');

          // ── TR Summer Preservation ──────────────────────────────────────────
          // If the semester at fromIndex is a non-summer Second Term AND the very
          // next semester is an already-scheduled Summer (contains courses),
          // extend the "keep" window to include that Summer.
          // This prevents TR (and any other summer courses) from being re-scheduled
          // to a later date whenever the user moves a course into an earlier semester.
          let keepIndex = fromIndex;
          {
            const lastKept  = plan.semesters[keepIndex];
            const nextAfter = plan.semesters[keepIndex + 1];
            if (
              lastKept && !lastKept.isSummer &&
              (lastKept.name.includes('Second') || lastKept.name.includes('Term')) &&
              nextAfter && nextAfter.isSummer && nextAfter.courses.length > 0
            ) {
              keepIndex = keepIndex + 1; // include the Summer in what we preserve
              console.log(`TR Preservation: extended keepIndex to ${keepIndex} (summer ${nextAfter.name})`);
            }
          }
          
          // Collect all completed courses up to and including the target semester
          const completedCourses = new Set([...selected]); // Already completed from transcript
          
          for (let i = 0; i <= keepIndex; i++) {
            plan.semesters[i].courses.forEach(code => completedCourses.add(code));
          }
          
          console.log('Completed courses:', Array.from(completedCourses));
          
          // Collect all remaining courses from semesters after the keep point
          const remainingCourses = [];
          for (let i = keepIndex + 1; i < plan.semesters.length; i++) {
            remainingCourses.push(...plan.semesters[i].courses);
          }
          
          console.log('Courses to re-schedule:', remainingCourses);
          
          // Keep semesters up to and including the keep point
          const semestersToKeep = plan.semesters.slice(0, keepIndex + 1);
          
          // Determine the starting point for re-planning
          // Calculate based on the semester we just filled
          const lastKeptSemester = semestersToKeep[semestersToKeep.length - 1];
          let nextTermNumber;
          
          if (lastKeptSemester.isSummer) {
            // If last kept was summer, next is the following fall/spring term.
            // "Summer Term YYYY-(YYYY+1)" → next is First Term (YYYY+1)-(YYYY+2).
            // We need the SECOND year in the range, so use year + 1.
            const yearMatch = lastKeptSemester.name.match(/(\d{4})/);
            if (yearMatch) {
              const year = parseInt(yearMatch[1]);     // first year, e.g. 2025
              const t1b = plan.term1BaseYear || 2024;
              // First Term (year+1) = ((year+1 - t1b) * 2) + 1
              nextTermNumber = (((year + 1) - t1b) * 2) + 1;
            } else {
              nextTermNumber = keepIndex + 2; // Default fallback
            }
          } else {
            // Regular semester - just increment
            // Determine current term type from the semester name
            const isFirstTerm = lastKeptSemester.name.includes('First');
            const yearMatch = lastKeptSemester.name.match(/(\d{4})/);
            
            if (yearMatch) {
              const year = parseInt(yearMatch[1]);
              const t1b = plan.term1BaseYear || 2024;
              const baseYear = year - t1b;
              
              if (isFirstTerm) {
                // After first term comes second term of same academic year
                nextTermNumber = (baseYear * 2) + 2;
              } else {
                // After second term comes first term of next academic year
                nextTermNumber = ((baseYear + 1) * 2) + 1;
              }
            } else {
              nextTermNumber = keepIndex + 2; // Default fallback
            }
          }
          
          console.log(`Next term number: ${nextTermNumber}`);
          
          // Re-generate the plan for remaining courses
          const newSemesters = generateRemainingPlan(
            Array.from(completedCourses),
            remainingCourses,
            nextTermNumber,
            plan.term1BaseYear   // ← pass override so year labels stay correct
          );
          
          // Replace the plan
          plan.semesters = [...semestersToKeep, ...newSemesters];
          
          console.log('Re-plan complete, new semester count:', plan.semesters.length);
          
          // Refresh display
          displayStudyPlan(currentPlanIndex);
          TechBot.success('Plan re-optimized successfully!');
        }

        // Generate plan for remaining courses
        function generateRemainingPlan(completedCourses, remainingCourses, startTermNumber, term1BaseYearOverride) {
          const newSemesters = [];
          let completed = [...completedCourses];
          let toSchedule = [...remainingCourses];
          
          // Calculate current credit hours
          const calculateHours = (courseList) => {
            return courseList.reduce((sum, code) => {
              if (code === 'BMA001') return sum;
              return sum + (courses[code]?.hours || 0);
            }, 0);
          };
          
          let currentHours = calculateHours(completed);
          let currentTermNumber = startTermNumber;
          const maxIterations = 12;
          let iterations = 0;
          
          // ==========================================
          // CALCULATE BASE YEAR FROM CURRENT DATE
          // ==========================================
          const now = new Date();
          const currentCalendarYear = now.getFullYear();
          const currentMonth = now.getMonth() + 1;
          const currentAcademicYear = (currentMonth >= 9) ? currentCalendarYear : currentCalendarYear - 1;
          const startTermYearIndex = Math.floor((startTermNumber - 1) / 2);
          // Use override if provided (fixes year labels when replanning mid-plan)
          const term1BaseYear = (term1BaseYearOverride !== undefined)
            ? term1BaseYearOverride
            : (currentAcademicYear - startTermYearIndex);
          
          console.log(`Re-planning from term ${currentTermNumber}, ${toSchedule.length} courses to schedule`);
          
          while (toSchedule.length > 0 && iterations < maxIterations) {
            iterations++;
            
            // Track if we just added a summer term to prevent consecutive summers
            let justAddedSummer = false;
            
            const termType = (currentTermNumber % 2 === 1) ? 1 : 2;
            console.log(`\n--- Re-planning term ${currentTermNumber} (type ${termType}) ---`);
            
            const remainingHours = calculateHours(toSchedule);
            console.log(`   Remaining: ${toSchedule.length} courses, ${remainingHours}h`);
            
            let maxHours = 18;
            
            // FILTER: Get courses available for this term
            let available = toSchedule.filter(code => {
              const course = courses[code];
              if (!course) return false;
              
              // Semester type must match
              const courseSemesterType = getSemesterType(course.semester);
              if (courseSemesterType !== termType) return false;
              
              // Prerequisites must be met
              const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
              if (!prereqsMet) return false;
              
              // TR only in summer
              if (code === 'TR') return false;
              
              // PC401 requires 85+ hours
              if (code === 'PC401' && currentHours < 85) return false;
              
              return true;
            });
            
            console.log(`   ${available.length} courses available`);
            
            // PRIORITIZE
            available = available.map(code => {
              const unlocks = Object.keys(courses).filter(c => 
                courses[c].prerequisites.includes(code) && toSchedule.includes(c)
              ).length;
              
              let priority = unlocks;
              if (code === 'PC401' && currentHours >= 85) priority = 1000;
              else if (code === 'PC402' && completed.includes('PC401')) priority = 999;
              else if (incompleteCourseCodes.has(code)) priority = 998; // Incomplete — must schedule
              
              return { code, priority, hours: courses[code].hours };
            });
            
            available.sort((a, b) => {
              if (b.priority !== a.priority) return b.priority - a.priority;
              return b.hours - a.hours;
            });
            
            available = available.map(item => item.code);
            
            // SELECT courses — incomplete courses bypass the maxHours cap
            const termCourses = [];
            let termHours = 0;
            let semHasIncomplete = false;
            
            for (const code of available) {
              const courseHours = courses[code].hours;
              const isIncomplete = incompleteCourseCodes.has(code);
              if (isIncomplete || termHours + courseHours <= maxHours) {
                termCourses.push(code);
                termHours += courseHours;
                if (isIncomplete) semHasIncomplete = true;
              }
            }
            
            if (termCourses.length === 0) {
              console.log('   No courses available, stopping');
              break;
            }
            
            // Add semester
            const termYearIndex = Math.floor((currentTermNumber - 1) / 2);
            const year = term1BaseYear + termYearIndex;
            const termName = termType === 1 ? 'First' : 'Second';
            
            newSemesters.push({
              name: `${termName} Term ${year}-${year + 1}`,
              courses: termCourses,
              hours: termHours,
              isSummer: false,
              isSpecialCase: false,
              hasIncomplete: semHasIncomplete
            });
            
            completed.push(...termCourses);
            toSchedule = toSchedule.filter(code => !termCourses.includes(code));
            currentHours = calculateHours(completed);
            
            console.log(`   Added ${termCourses.length} courses (${termHours}h). Total: ${currentHours}h`);
            
            // ==========================================
            // POST-SEMESTER CHECKS
            // ==========================================
            
            // CHECK 1: TR Summer
            if (termType === 2 && toSchedule.includes('TR') && currentHours >= 60) {
              console.log(`   🌞 TR condition met, adding TR summer`);
              
              const trPrereqsMet = courses['TR'].prerequisites.every(prereq => completed.includes(prereq));
              if (trPrereqsMet) {
                newSemesters.push({
                  name: `Summer Term ${year}-${year + 1}`,
                  courses: ['TR'],
                  hours: 2,
                  isSummer: true,
                  isSpecialCase: false
                });
                
                completed.push('TR');
                toSchedule = toSchedule.filter(code => code !== 'TR');
                currentHours = calculateHours(completed);
                
                console.log(`   ✅ Added TR summer. Total: ${currentHours}h`);
                justAddedSummer = true; // Mark that we just added a summer term
              }
            }
            
            // Recalculate remaining
            const newRemainingHours = calculateHours(toSchedule);
            const newRemainingHoursExclInc = calculateHours(toSchedule.filter(c => !incompleteCourseCodes.has(c)));
            
            // CHECK 3: Special Summer (≤12h after even semester - REGARDLESS of type mix)
            // Incomplete courses excluded from the 12h threshold; they bypass the cap.
            // This check must come BEFORE CHECK 2 because it's more specific
            if (!justAddedSummer && termType === 2 && newRemainingHours > 0 && newRemainingHoursExclInc <= 12 && toSchedule.length > 0) {
              console.log(`   ⭐ Special summer case: ${newRemainingHoursExclInc}h (excl. incomplete) after even semester`);
              
              const summerCourses = toSchedule.filter(code => {
                const course = courses[code];
                if (!course) return false;
                
                const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                if (!prereqsMet) return false;
                
                if (code === 'TR' && currentHours < 60) return false;
                if (code === 'PC401' || code === 'PC402') return false;
                
                return true;
              });
                
              if (summerCourses.length > 0) {
                let summerHours = 0;
                const selectedSummer = [];
                
                const prioritizedSummer = summerCourses.map(code => {
                  const unlocks = Object.keys(courses).filter(c => 
                    courses[c].prerequisites.includes(code) && toSchedule.includes(c)
                  ).length;
                  return { code, unlocks, hours: courses[code].hours };
                }).sort((a, b) => {
                  if (b.unlocks !== a.unlocks) return b.unlocks - a.unlocks;
                  return b.hours - a.hours;
                });
                
                for (const item of prioritizedSummer) {
                  const isInc = incompleteCourseCodes.has(item.code);
                  // Incomplete courses bypass the 12h cap
                  if (isInc || summerHours + item.hours <= 12) {
                    selectedSummer.push(item.code);
                    summerHours += item.hours;
                  }
                }
                
                if (selectedSummer.length > 0) {
                  const hasIncInSummer = selectedSummer.some(c => incompleteCourseCodes.has(c));
                  newSemesters.push({
                    name: `Summer Term ${year}-${year + 1} ⭐ Special Case`,
                    courses: selectedSummer,
                    hours: summerHours,
                    isSummer: true,
                    isSpecialCase: true,
                    hasIncomplete: hasIncInSummer
                  });
                  
                  completed.push(...selectedSummer);
                  toSchedule = toSchedule.filter(code => !selectedSummer.includes(code));
                  currentHours = calculateHours(completed);
                  
                  console.log(`   ✅ Added special summer: ${selectedSummer.length} courses`);
                  justAddedSummer = true; // Mark that we just added a summer term
                }
              }
            }
            
            // Recalculate again after potential summer addition
            const finalRemainingHours = calculateHours(toSchedule);
            const finalRemainingHoursExclInc = calculateHours(toSchedule.filter(c => !incompleteCourseCodes.has(c)));
            
            // CHECK 2: Special 21-Hour Semester
            // Incomplete courses excluded from the 21h threshold; they bypass the cap.
            // This check comes AFTER CHECK 3 (more general fallback)
            if (finalRemainingHours > 0 && finalRemainingHoursExclInc <= 21 && toSchedule.length > 0) {
              const nonIncRemaining = toSchedule.filter(c => !incompleteCourseCodes.has(c));
              const remainingSemesterTypes = nonIncRemaining.map(code => {
                const course = courses[code];
                return course ? getSemesterType(course.semester) : null;
              }).filter(t => t !== null);
              
              const allType1 = remainingSemesterTypes.length === 0 || remainingSemesterTypes.every(t => t === 1);
              const allType2 = remainingSemesterTypes.length === 0 || remainingSemesterTypes.every(t => t === 2);
              
              if (allType1 || allType2) {
                console.log(`   ⭐ Special 21-hour case: all courses same type, ${finalRemainingHoursExclInc}h (excl. incomplete)`);
                
                const finalCourses = toSchedule.filter(code => {
                  const course = courses[code];
                  if (!course || code === 'TR') return false;
                  
                  const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                  if (!prereqsMet) return false;
                  
                  if (code === 'PC401' && currentHours < 85) return false;
                  
                  return true;
                });
                
                if (finalCourses.length > 0) {
                  const finalHours = calculateHours(finalCourses);
                  const hasIncInFinal = finalCourses.some(c => incompleteCourseCodes.has(c));
                  const nextTermNumber = currentTermNumber + 1;
                  const nextTermType = (nextTermNumber % 2 === 1) ? 1 : 2;
                  const nextTermYearIndex = Math.floor((nextTermNumber - 1) / 2);
                  const nextYear = term1BaseYear + nextTermYearIndex;
                  const nextTermName = nextTermType === 1 ? 'First' : 'Second';
                  
                  newSemesters.push({
                    name: `${nextTermName} Term ${nextYear}-${nextYear + 1}`,
                    courses: finalCourses,
                    hours: finalHours,
                    isSummer: false,
                    isSpecialCase: true,
                    hasIncomplete: hasIncInFinal
                  });
                  
                  completed.push(...finalCourses);
                  toSchedule = toSchedule.filter(code => !finalCourses.includes(code));
                  currentHours = calculateHours(completed);
                  
                  console.log(`   ✅ Added special 21-hour semester: ${finalCourses.length} courses`);
                }
              }
            }
            
            // Recalculate one more time
            const veryFinalRemainingHours = calculateHours(toSchedule);
            const veryFinalRemainingHoursExclInc = calculateHours(toSchedule.filter(c => !incompleteCourseCodes.has(c)));
            
            // CHECK 4: FINAL SUMMER TERM (≤12h after First Term - allows incomplete courses)
            // If we just finished a First (odd) semester and have ≤12h remaining,
            // create a summer term instead of requiring a full Second Term.
            // This is especially useful for incomplete courses in the final semester.
            // CRITICAL: Don't trigger if the last semester added is already summer (prevents consecutive summers)
            const lastAddedSemesterR = newSemesters.length > 0 ? newSemesters[newSemesters.length - 1] : null;
            const lastIsNotSummerR = !lastAddedSemesterR || !lastAddedSemesterR.isSummer;
            
            if (lastIsNotSummerR && termType === 1 && veryFinalRemainingHours > 0 && veryFinalRemainingHoursExclInc <= 12 && toSchedule.length > 0) {
              console.log(`   🌞 CHECK 4: Final summer term - ${veryFinalRemainingHoursExclInc}h (excl. incomplete) after First Term`);
              
              // Filter courses - allow ANY course type, including incomplete courses
              const finalSummerCourses = toSchedule.filter(code => {
                const course = courses[code];
                if (!course) return false;
                
                const prereqsMet = course.prerequisites.every(prereq => completed.includes(prereq));
                if (!prereqsMet) return false;
                
                if (code === 'TR' && currentHours < 60) return false;
                if (code === 'PC401' || code === 'PC402') return false;
                
                return true;
              });
              
              if (finalSummerCourses.length > 0) {
                let finalSummerHours = 0;
                const selectedFinalSummer = [];
                
                const prioritizedFinalSummer = finalSummerCourses.map(code => {
                  const unlocks = Object.keys(courses).filter(c => 
                    courses[c].prerequisites.includes(code) && toSchedule.includes(c)
                  ).length;
                  return { code, unlocks, hours: courses[code].hours };
                }).sort((a, b) => {
                  if (b.unlocks !== a.unlocks) return b.unlocks - a.unlocks;
                  return b.hours - a.hours;
                });
                
                // Select all courses - incomplete courses bypass the cap
                for (const item of prioritizedFinalSummer) {
                  const isInc = incompleteCourseCodes.has(item.code);
                  if (isInc || finalSummerHours + item.hours <= 12) {
                    selectedFinalSummer.push(item.code);
                    finalSummerHours += item.hours;
                  }
                }
                
                if (selectedFinalSummer.length > 0) {
                  const hasIncInFinalSummer = selectedFinalSummer.some(c => incompleteCourseCodes.has(c));
                  const currentYearIndex = Math.floor((currentTermNumber - 1) / 2);
                  const summerYear = term1BaseYear + currentYearIndex;
                  
                  newSemesters.push({
                    name: `Summer Term ${summerYear}-${summerYear + 1} ⭐ Special Case`,
                    courses: selectedFinalSummer,
                    hours: finalSummerHours,
                    isSummer: true,
                    isSpecialCase: true,
                    hasIncomplete: hasIncInFinalSummer
                  });
                  
                  completed.push(...selectedFinalSummer);
                  toSchedule = toSchedule.filter(code => !selectedFinalSummer.includes(code));
                  currentHours = calculateHours(completed);
                  
                  console.log(`   ✅ Added final summer: ${selectedFinalSummer.length} courses, ${finalSummerHours}h`);
                }
              }
            }
            
            currentTermNumber++;
            if (currentTermNumber > 12) {
              console.log('⚠️ Reached maximum term (12)');
              break;
            }
          }
          
          console.log(`\nRe-planning complete: ${newSemesters.length} new semesters`);
          if (toSchedule.length > 0) {
            console.log(`⚠️ ${toSchedule.length} courses not scheduled: ${toSchedule.join(', ')}`);
          }
          
          return newSemesters;
        }

        // Add summer semester after a specific semester
        function addSummerSemesterAfter(afterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          
          // Determine the year based on the semester after which we're adding
          const afterSemester = plan.semesters[afterIndex];
          let year = 2024;
          
          // Extract year from semester name if possible
          const yearMatch = afterSemester.name.match(/(\d{4})/);
          if (yearMatch) {
            year = parseInt(yearMatch[1]);
          }
          
          // Check if remaining hours qualify for special case
          const remainingCourses = Object.keys(courses).filter(code => {
            const selected = [...new Set(window.selected || [])];
            return !selected.includes(code) && code !== 'BMA001';
          });
          const remainingHours = remainingCourses.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
          
          const isSpecialCase = (remainingHours > 0 && remainingHours <= 12);
          
          // Create summer semester
          const summerSemester = {
            name: `Summer Term ${year}-${year + 1}${isSpecialCase ? ' (Special Case)' : ''}`,
            courses: [],
            hours: 0,
            isSummer: true,
            isSpecialCase: isSpecialCase
          };

          // Insert after the specified index
          plan.semesters.splice(afterIndex + 1, 0, summerSemester);
          
          displayStudyPlan(currentPlanIndex);
          
          const maxHours = isSpecialCase ? 12 : 9;
          const message = isSpecialCase 
            ? `⭐ Summer special case added after ${afterSemester.name}! Drag theoretical courses here (max ${maxHours} hours - any semester 1-8).`
            : `Summer semester added after ${afterSemester.name}! Drag courses here (max ${maxHours} hours, theoretical only).`;
          
          TechBot.success(message);
        }

        // Delete semester
        function deleteSemester(semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          const semester = plan.semesters[semesterIndex];
          
          if (!semester.isSummer) {
            TechBot.error('Cannot delete regular semesters, only summer semesters.');
            return;
          }

          const doDelete = function() {
            // Save state for undo
            UndoRedoManager.saveState(`Deleted ${semester.name}`);
            
            plan.semesters.splice(semesterIndex, 1);
            displayStudyPlan(currentPlanIndex);
            TechBot.success('Summer semester deleted.');
          };

          if (semester.courses.length > 0) {
            window.confirmDeleteSemester = doDelete;
            TechBot.confirm(
              '🗑️ Delete Summer Semester',
              `This summer semester has ${semester.courses.length} course(s). Delete anyway? Courses will be unscheduled.`,
              'confirmDeleteSemester'
            );
          } else {
            doDelete();
          }
        }

        // Toggle special case for a semester
        function toggleSpecialCase(semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          if (!plan) return;
          
          const semester = plan.semesters[semesterIndex];
          UndoRedoManager.saveState(`${semester.isSpecialCase ? 'Removed' : 'Added'} special case on ${semester.name}`);
          
          semester.isSpecialCase = !semester.isSpecialCase;
          
          const isSummer = semester.isSummer;
          const maxH = semester.isSpecialCase
            ? (isSummer ? 12 : 21)
            : (isSummer ? 9 : 18);
          const prevMax = semester.isSpecialCase
            ? (isSummer ? 9 : 18)
            : (isSummer ? 12 : 21);
          
          if (semester.isSpecialCase) {
            TechBot.success(`⭐ "${semester.name}" is now a Special Case — max hours raised to ${maxH}h`);
          } else {
            // Check if current hours exceed the new (reduced) limit
            if (semester.hours > maxH) {
              TechBot.warning(`⚠️ Special case removed from "${semester.name}". Max hours is now ${maxH}h, but semester has ${semester.hours}h — please move some courses out.`);
            } else {
              TechBot.notify(`☆ Special case removed from "${semester.name}" — max is ${maxH}h again.`);
            }
          }
          
          displayStudyPlan(currentPlanIndex);
        }

        // Reset plan to original
        function resetPlan() {
          window.confirmResetPlan = function() {
            // Save state for undo
            UndoRedoManager.saveState('Reset plan to original');
            
            generateMultiplePlans();
            TechBot.success('Plan reset to original.');
          };
          
          TechBot.confirm(
            '🔄 Reset Plan',
            'Reset plan to original? All your changes will be lost.',
            'confirmResetPlan'
          );
        }

        // Show toast notification (replaces old inline validationMessage)
        function showValidation(message, type = 'info') {
          // Also update inline message for backward compat
          const msgDiv = document.getElementById('validationMessage');
          if (msgDiv) {
            msgDiv.className = `validation-message ${type}`;
            msgDiv.textContent = message;
            msgDiv.style.display = 'block';
            setTimeout(() => { msgDiv.style.display = 'none'; }, 5000);
          }

          // Toast
          let container = document.getElementById('toastContainer');
          if (!container) {
            container = document.createElement('div');
            container.id = 'toastContainer';
            document.body.appendChild(container);
          }
          const toast = document.createElement('div');
          toast.className = `toast-msg ${type}`;
          toast.textContent = message;
          container.appendChild(toast);
          setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease';
            setTimeout(() => toast.remove(), 350);
          }, 4500);
        }

        // ============================================================
        // REMOVE COURSE FROM PLAN (with cascade deletion of dependents)
        // ============================================================
        function removeCourseFromPlan(courseCode, semesterIndex) {
          const plan = generatedPlans[currentPlanIndex];
          if (!plan) return;

          // Find all courses in later semesters that depend on this one (cascade)
          function findDependents(code, fromSemIdx) {
            const deps = [];
            for (let i = fromSemIdx + 1; i < plan.semesters.length; i++) {
              plan.semesters[i].courses.forEach(c => {
                if (courses[c] && courses[c].prerequisites.includes(code)) {
                  deps.push({ code: c, semIdx: i });
                  // Recurse to find dependents of dependents
                  const nested = findDependents(c, i);
                  nested.forEach(n => {
                    if (!deps.find(d => d.code === n.code)) deps.push(n);
                  });
                }
              });
            }
            return deps;
          }

          const dependents = findDependents(courseCode, semesterIndex);

          // Build confirmation message
          let msg = `Remove <strong>"${courses[courseCode]?.name}"</strong>?`;
          if (dependents.length > 0) {
            const names = dependents.map(d => `<strong>${courses[d.code]?.name || d.code}</strong>`).join(', ');
            msg += `\n\nThis will also remove <strong>${dependents.length}</strong> dependent course(s):\n${names}`;
          }

          // Store the removal function
          window.confirmRemoveCourse = function() {
            // Save state for undo
            UndoRedoManager.saveState(`Removed ${courseCode} from ${plan.semesters[semesterIndex].name}`);
            
            // Remove course from its semester
            const sem = plan.semesters[semesterIndex];
            const idx = sem.courses.indexOf(courseCode);
            if (idx > -1) {
              sem.courses.splice(idx, 1);
              sem.hours -= (courses[courseCode]?.hours || 0);
            }

            // Remove cascaded dependents
            dependents.forEach(({ code: depCode, semIdx }) => {
              const depSem = plan.semesters[semIdx];
              const depIdx = depSem.courses.indexOf(depCode);
              if (depIdx > -1) {
                depSem.courses.splice(depIdx, 1);
                depSem.hours -= (courses[depCode]?.hours || 0);
              }
            });

            // Refresh display
            displayStudyPlan(currentPlanIndex);

            const msg2 = dependents.length > 0
              ? `Removed "${courses[courseCode]?.name}" and ${dependents.length} dependent(s): ${dependents.map(d=>courses[d.code]?.name||d.code).join(', ')}`
              : `Removed "${courses[courseCode]?.name}" from the plan`;
            TechBot.success(msg2);
          };

          // Show TechBot confirmation dialog
          TechBot.confirm(
            '🗑️ Remove Course',
            msg,
            'confirmRemoveCourse'
          );
        }

        // Generate optimized study plan
        function generateMultiplePlans() {
          addDebugLog('\n🎓 Generating optimized study plan...', 'info');
          
          // Try to detect current term from most recent PDF parse
          let detectedStartTerm = null;
          
          // Check if we have stored PDF course data
          if (window.lastParsedPdfCourses && window.lastParsedPdfCourses.length > 0) {
            const currentTerm = detectCurrentTerm(window.lastParsedPdfCourses);
            
            if (currentTerm.isDetected) {
              addDebugLog(`\n🔍 CURRENT TERM DETECTED: Term ${currentTerm.termNumber}`, 'info');
              addDebugLog(`   Currently registered: ${currentTerm.registeredCourses.length} courses`, 'info');
              
              // Validate current registration
              const uniqueSelected = [...new Set(selected)];
              const validation = validateCurrentRegistration(currentTerm, uniqueSelected);
              
              if (!validation.isValid) {
                addDebugLog(`\n⚠️ REGISTRATION VIOLATIONS DETECTED:`, 'warning');
                validation.violations.forEach(v => {
                  addDebugLog(`   ❌ ${v.code}: ${v.reason}`, 'error');
                });
              } else {
                addDebugLog(`   ✅ Current registration is valid`, 'success');
              }
              
              detectedStartTerm = currentTerm.termNumber;
            }
          }
          
          // Use detected term or fallback to term 1
          let finalStartTerm = detectedStartTerm || 1;
          
          // Ensure we start from at least term 1
          if (finalStartTerm < 1) finalStartTerm = 1;
          
          addDebugLog(`\n📅 Starting plan from Term ${finalStartTerm}`, 'info');
          
          generatedPlans = [];
          
          // Generate single OPTIMIZED plan with all requirements:
          // 1. Prioritizes courses that unlock the most other courses
          // 2. Smart dependency management
          // 3. Projects (PC401, PC402) get highest priority when eligible
          // 4. Fills semesters to maximum hours (18 or 21 at special cases)
          // 5. Aims for fastest graduation
          // 6. Automatically adds Summer term with TR when 60 hours gained
          const optimizedPlan = generateStudyPlan('optimized', finalStartTerm);

          // Compute and store term1BaseYear so replanAfterMove can use
          // the correct year offset instead of the hardcoded 2024 fallback.
          const _now = new Date();
          const _curAcYear = (_now.getMonth() + 1 >= 9) ? _now.getFullYear() : _now.getFullYear() - 1;
          const _t1BaseYear = _curAcYear - Math.floor((finalStartTerm - 1) / 2);

          generatedPlans.push({
            name: 'Optimized Study Plan',
            semesters: optimizedPlan,
            strategy: 'optimized',
            term1BaseYear: _t1BaseYear
          });

          addDebugLog(`✅ Generated optimized study plan with ${optimizedPlan.length} semesters`, 'success');

          // Display plan selector (even though there's only one plan)
          const selectorDiv = document.getElementById('planSelectorDiv');
          const selector = document.getElementById('planSelector');
          selector.innerHTML = '';

          generatedPlans.forEach((plan, index) => {
            const btn = document.createElement('button');
            btn.className = `plan-option ${index === 0 ? 'active' : ''}`;
            btn.textContent = plan.name;
            btn.onclick = () => {
              document.querySelectorAll('.plan-option').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              currentPlanIndex = index;
              displayStudyPlan(index);
            };
            selector.appendChild(btn);
          });

          selectorDiv.style.display = 'block';
          window._planJustGenerated = true; // Flag set before display so scroll fires once
          displayStudyPlan(0);
        }

        // Handle generate plan button
        document.getElementById('generatePlanBtn').addEventListener('click', function() {
          if (selected.length === 0) {
            alert('Please upload a student transcript first!');
            return;
          }

          generateMultiplePlans();
          // Note: draggability on .course cells is already set by addCourse().
          // No need to re-register listeners here; that would create duplicates.
        });

        // Handle file upload
        document.getElementById('pdfInput').addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (!file) {
            console.log('No file selected');
            return;
          }

          console.log('File selected:', file.name, file.type, file.size);
          
          // ===== FILE VALIDATION =====
          const maxSize = 10 * 1024 * 1024; // 10MB limit
          if (file.size > maxSize) {
            alert(`File too large! Maximum size is 10MB. Your file is ${(file.size / 1024 / 1024).toFixed(2)}MB`);
            addDebugLog(`❌ File too large: ${(file.size / 1024 / 1024).toFixed(2)}MB (max 10MB)`, 'error');
            return;
          }
          
          debugLog = []; // Clear debug log
          addDebugLog(`🚀 Starting to process: ${file.name} (${(file.size / 1024).toFixed(2)}KB)`, 'info');

          let result;
          
          // Check file type
          if (file.name.endsWith('.pdf') || file.type === 'application/pdf') {
            addDebugLog('📄 Detected PDF file', 'info');
            result = await parsePDF(file);
          } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || 
                     file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                     file.type === 'application/vnd.ms-excel') {
            addDebugLog('📊 Detected Excel file', 'info');
            result = await parseExcel(file);
          } else {
            addDebugLog(`❌ Unsupported file type: ${file.type}. Please upload PDF or Excel file.`, 'error');
            alert('Please upload a PDF or Excel file');
            return;
          }

          if (!result) {
            addDebugLog('❌ Failed to parse file', 'error');
            return;
          }

          const { courses: pdfCourses, studentInfo } = result;

          if (!pdfCourses || pdfCourses.length === 0) {
            addDebugLog('⚠️ No courses found in the file', 'warning');
            alert('No courses found in the uploaded file. Please check the file format.');
            return;
          }

          // Store PDF courses for term detection
          window.lastParsedPdfCourses = pdfCourses;
          addDebugLog(`💾 Stored ${pdfCourses.length} course records for analysis`, 'info');

          // Display student info
          if (studentInfo.name) {
            document.getElementById('studentInfo').style.display = 'block';
            document.getElementById('studentName').textContent = `👤 Name: ${studentInfo.name}`;
            document.getElementById('studentId').textContent = `🆔 ID: ${studentInfo.id || 'N/A'}`;
            document.getElementById('studentLevel').textContent = `📚 Level: ${studentInfo.level || 'N/A'}`;
            
            if (studentInfo.gpa) {
              document.getElementById('gpaValue').textContent = studentInfo.gpa;
              const gpaNum = parseFloat(studentInfo.gpa);
              document.getElementById('gpaGrade').textContent = 
                gpaNum >= 3.7 ? 'Excellent' : 
                gpaNum >= 3.0 ? 'Very Good' : 
                gpaNum >= 2.5 ? 'Good' : 'Pass';
            }
          }

          // Auto-select courses
          const stats = autoSelectCourses(pdfCourses);
          
          // ===== CRITICAL SAFEGUARD: Remove any duplicates from selected array =====
          const beforeDedup = selected.length;
          selected = [...new Set(selected)];  // Convert to Set and back to remove duplicates
          const afterDedup = selected.length;
          
          if (beforeDedup !== afterDedup) {
            addDebugLog(`⚠️ WARNING: Removed ${beforeDedup - afterDedup} duplicate entries from selected courses!`, 'error');
            addDebugLog(`   Before: ${beforeDedup} courses, After: ${afterDedup} courses`, 'warning');
          } else {
            addDebugLog(`✅ No duplicates found in selected courses (${afterDedup} unique courses)`, 'success');
          }
          
          // Sanity check: A typical 4th year student should have ~25-30 courses completed
          if (afterDedup > 40) {
            addDebugLog(`⚠️⚠️ SANITY CHECK FAILED: ${afterDedup} courses seems too high!`, 'error');
            addDebugLog(`   💡 This might indicate duplicate matching or program mismatch`, 'error');
            addDebugLog(`   💡 Check if you selected the correct program (IT vs AI) at the top of the page`, 'warning');
          } else if (afterDedup < 10) {
            addDebugLog(`⚠️ SANITY CHECK: Only ${afterDedup} courses matched`, 'warning');
            addDebugLog(`   💡 This might indicate matching issues - check the debug log for unmatched courses`, 'warning');
          } else {
            addDebugLog(`✅ Sanity check passed: ${afterDedup} courses is reasonable for year 4`, 'success');
          }
          
          // Verify no failing courses were selected
          addDebugLog(`\n🔍 VERIFICATION: Checking selected courses...`, 'info');
          const uniqueSelected = [...new Set(selected)];
          addDebugLog(`   Total selected: ${uniqueSelected.length} unique courses`, 'info');
          
          // Check if IT438 was selected (for debugging)
          if (uniqueSelected.includes('IT438')) {
            addDebugLog(`   ⚠️ WARNING: IT438 (Communication Technology) was selected - this might be an error!`, 'error');
          } else {
            addDebugLog(`   ✅ IT438 (Communication Technology) NOT selected`, 'success');
          }
          
          // Show statistics
          document.getElementById('statsContainer').style.display = 'grid';
          calculateStatistics();

          // Show remaining courses
          document.getElementById('remainingCourses').style.display = 'block';
          showRemainingCourses();

          // Show study plan generator
          document.getElementById('studyPlanContainer').style.display = 'block';

          addDebugLog(`✨ Processing complete!`, 'success');
          
          // Trigger auto-scroll sequence
          autoScrollAfterUpload();
        });

        // Make upload box clickable
        document.getElementById('uploadBox').addEventListener('click', function() {
          document.getElementById('pdfInput').click();
        });

        // Prevent default drag and drop behavior
        document.getElementById('uploadBox').addEventListener('dragover', function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.style.borderColor = '#2563eb';
          this.style.background = '#eff6ff';
        });

        document.getElementById('uploadBox').addEventListener('dragleave', function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.style.borderColor = '#3b82f6';
          this.style.background = 'white';
        });

        document.getElementById('uploadBox').addEventListener('drop', function(e) {
          e.preventDefault();
          e.stopPropagation();
          this.style.borderColor = '#3b82f6';
          this.style.background = 'white';
          
          const files = e.dataTransfer.files;
          if (files.length > 0) {
            document.getElementById('pdfInput').files = files;
            document.getElementById('pdfInput').dispatchEvent(new Event('change'));
          }
        });

        // Parse Excel file
        async function parseExcel(file) {
          try {
            addDebugLog('📊 Loading Excel file...', 'info');
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
            
            // Convert to text format similar to PDF
            let text = '';
            data.forEach(row => {
              text += row.join(' ') + '\n';
            });

            addDebugLog('✅ Excel loaded successfully', 'success');
            return extractCoursesFromText(text);
          } catch (error) {
            addDebugLog(`❌ Error parsing Excel: ${error.message}`, 'error');
            return null;
          }
        }
      });
    </script>
  </head>
  <body>
    <h2>
      New Regulation -( <span id="it" class="program active">IT</span> )- (
      <span id="ai" class="program">AI</span>) Courses
    </h2>

    <div class="courses-section">
      <table id="courses_table"><tr id="semester-1"><td class="header">Semester 1</td><td id="IT111" class="course">Electronics</td><td id="MA111" class="course">Mathematics1</td><td id="HU111" class="course">Technical Report Writing</td><td id="HU413" class="course">Human Rights</td><td id="MA112" class="course">Discrete Math</td><td id="IT110" class="course">Introduction to Computers</td></tr><tr id="semester-2"><td class="header">Semester 2</td><td id="ST121" class="course">Probability and Statistics-1</td><td id="HU112" class="course">Creative and Scientific Thinking</td><td id="MA113" class="course">Mathematics-2</td><td id="HU101" class="course">Micro Economics</td><td id="IT113" class="course">Logic Design</td><td id="CS112" class="course">Programming Language</td></tr><tr id="semester-3"><td class="header">Semester 3</td><td id="CS215" class="course">Object Oriented Programing</td><td id="DS211" class="course">Introduction to Database systems</td><td id="MA214" class="course">Mathematics-3 </td><td id="IT231" class="course">Computer Networks Technology</td><td id="ST222" class="course">Probability and Statistics-2</td><td id="CS240" class="course">Introduction to Software Engineering</td></tr><tr id="semester-4"><td class="header">Semester 4</td><td id="IT217" class="course">Introduction to Operation Research</td><td id="CS216" class="course">Data Structure</td><td id="AI321" class="course">Machine Learning Fundamentals</td><td id="IT230" class="course">Web Technology</td><td id="HU427" class="course">Entrepreneurship</td><td id="LB211" class="course">Networking Fundamentals lab</td></tr><tr id="semester-5"><td class="header">Semester 5</td><td id="LB312" class="course">Network Routing and Switching-Lab</td><td id="AI311" class="course">Artificial intelligence</td><td id="CS319" class="course">Operating Systems</td><td id="IT212" class="course">Digital Signal Processing</td><td id="CS318" class="course">Computer Organization</td><td id="CS341" class="course">Algorithms analysis and Design</td></tr><tr id="semester-6"><td class="header">Semester 6</td><td id="IT322" class="course">Pattern Recognition</td><td id="IT333" class="course">Information Computer Networks Security</td><td id="AI448" class="course">op-Natural Language Processing</td><td id="CS344" class="course">Advanced Software Engineering</td><td id="IT343" class="course">Microcontroller</td><td id="LB313" class="course">Ethical Hacking-lab</td></tr><tr id="semester-7"><td class="header">Semester 7</td><td id="LB421" class="course">Selected labs in Software Engineering</td><td id="IT423" class="course">Embedded Systems</td><td id="IT221" class="course">Computer Graphics</td><td id="IT434" class="course">Advanced Computer Networks</td><td id="PC401" class="course">Project (1)</td><td id="IT438" class="course">Communication Technology</td></tr><tr id="semester-8"><td class="header">Semester 8</td><td id="IT436" class="course">Cloud Computing Networking</td><td id="AI435" class="course">Semantic Web and ontology</td><td id="IT439" class="course">Wireless and Mobile Networks</td><td id="HU402" class="course">Fundamental of Management</td><td id="PC402" class="course">Project (2)</td><td id="LB431" class="course">Selected labs in AI</td></tr><tr id="additional-courses"><td class="header">Additional Courses</td><td id="TR" class="course">Summer Training</td><td id="BMA001" class="course">Mathematics-0</td></tr></table>

      <div class="legend-toggle-container">
        <table id="legend">
          <tbody>
          <tr>
            <td class="selected" style="width: 20px; height: 20px;"></td>
            <td>Selected courses</td>
          </tr>
          <tr>
            <td class="direct" style="width: 20px; height: 20px;"></td>
            <td>Direct prerequisite</td>
          </tr>
          <tr>
            <td class="prev" style="width: 20px; height: 20px;"></td>
            <td>Indirect prerequisite</td>
          </tr>
          <tr>
            <td class="next" style="width: 20px; height: 20px;"></td>
            <td>Next courses</td>
          </tr>
        </tbody></table>
        
        <div class="select-multiple-container">
          <label class="switch">
            <input id="selectMulti" type="checkbox">
            <span class="slider"></span>
          </label>
          Select multiple courses
        </div>
      </div>
      <div id="div_sel"></div>
    </div>

    <!-- PDF Upload Interface -->
    <div class="upload-container">
      <div class="upload-box" id="uploadBox">
        <input type="file" id="pdfInput" accept=".pdf,.xlsx" />
        <div class="upload-label">📄 Upload Student Record (PDF/Excel)</div>
        <p class="upload-hint">Click to upload بيان حالة - PDF or Excel format</p>
      </div>

      <!-- Student Info -->
      <div class="student-info" id="studentInfo" style="display: none;">
        <h4>📋 Student Information</h4>
        <p id="studentName"></p>
        <p id="studentId"></p>
        <p id="studentLevel"></p>
      </div>

      <!-- Statistics -->
      <div class="stats-container" id="statsContainer" style="display: none;">
        <!-- Graduation Progress Ring Card -->
        <div class="stat-card ring-card">
          <svg class="ring-svg" width="90" height="90" viewBox="0 0 90 90">
            <defs>
              <linearGradient id="ringGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#2563eb"/>
                <stop offset="100%" stop-color="#818cf8"/>
              </linearGradient>
            </defs>
            <circle class="ring-bg" cx="45" cy="45" r="36"/>
            <circle class="ring-fill" id="progressRing" cx="45" cy="45" r="36"
              style="stroke-dasharray: 226.19; stroke-dashoffset: 226.19;" stroke="url(#ringGrad)"/>
            <text id="progressRingText" x="45" y="50" text-anchor="middle"
              font-size="14" font-weight="700" fill="#2563eb" font-family="Inter,sans-serif">0%</text>
          </svg>
          <div class="ring-info">
            <h3>Graduation Progress</h3>
            <div class="stat-value" id="creditHours" style="font-size:22px;">0/135</div>
            <div class="progress-bar">
              <div class="progress-fill" id="creditProgress" style="width: 0%"></div>
            </div>
            <div class="stat-label" id="creditPercentage" style="margin-top:6px;">0% Complete</div>
          </div>
        </div>

        <div class="stat-card">
          <h3>GPA</h3>
          <div class="stat-value" id="gpaValue">0.00</div>
          <div class="stat-label" id="gpaGrade">Not Available</div>
        </div>

        <div class="stat-card">
          <h3>Completed Courses</h3>
          <div class="stat-value" id="completedCount">0</div>
          <div class="stat-label" id="remainingCount">0 Remaining</div>
        </div>
      </div>

      <!-- Remaining Courses -->
      <div class="remaining-courses" id="remainingCourses" style="display: none;">
        <h3>📚 Remaining Courses <span style="font-size:12px; font-weight:500; color:var(--text-muted); background:#f1f5f9; padding:3px 10px; border-radius:99px; margin-left:8px;">✋ Drag into study plan</span></h3>
        <div class="course-list" id="courseList"></div>
      </div>

      <!-- Study Plan Generator -->
      <div class="study-plan-container" id="studyPlanContainer" style="display: none;">
        <div class="study-plan-header">
          <h3>🎓 Study Plan Generator</h3>
          <button class="generate-plan-btn" id="generatePlanBtn">Generate Optimized Study Plan</button>
        </div>
        
        <div id="planSelectorDiv" style="display: none;">
          <div class="plan-selector" id="planSelector"></div>
        </div>

        <div id="studyPlanDisplay"></div>
      </div>

    </div>

  


 

  <!-- Floating Action Buttons (PDF moved to study plan actions bar) -->
  <div class="fab-container" id="fabContainer" style="display:none;">
    <button class="fab-btn fab-pdf" id="fabExportPdf" onclick="exportStudyPlanAsPDF()" title="Export study plan as PDF">
      🖨️ Export as PDF
    </button>
  </div>

  <!-- TechBot Toast Notification -->
  <div id="techbot-toast">
    <div class="bot-character">
      🤖
      <div class="robot-mouth-overlay"></div>
    </div>
      <div class="toast-message">
        <div class="toast-message-title">🤖 Assistant Bot</div>
        <div class="toast-message-text" id="toast-text"></div>
      </div>
  </div>

  <!-- TechBot Modal Dialog -->
  <div id="techbot-modal">
    <div class="modal-content">
      <div class="modal-bot">
        <div style="text-align:center; font-size: 72px; position: relative; display: inline-block;">
          🤖
          <div class="robot-mouth-overlay" style="bottom: 22px;"></div>
        </div>
      </div>
      <div class="modal-message">
        <h3 id="modal-title">Assistant Bot Says</h3>
        <p id="modal-text"></p>
      </div>
      <div class="modal-buttons" id="modal-buttons">
        <button class="modal-btn modal-btn-primary" onclick="closeTechBotModal()">Got it!</button>
      </div>
    </div>
  </div>

  <!-- Graduate Earlier Options Modal -->
  <div id="shortcut-modal">
    <div class="shortcut-modal-panel">
      <div class="shortcut-modal-header">
        <div>
          <h2 class="shortcut-modal-title" style="position:static;height:auto;background:none;box-shadow:none;border:none;font-size:20px;">⚡ Graduate Earlier — Choose an Option</h2>
          <p class="shortcut-modal-subtitle" id="shortcut-modal-subtitle"></p>
        </div>
        <button class="shortcut-modal-close" onclick="closeShortcutModal()" title="Close">✕</button>
      </div>
      <div class="shortcut-options-grid" id="shortcut-options-grid"></div>
    </div>
  </div>

  <!-- Summer Bridge Modal -->
  <div id="bridge-modal" style="
        position:fixed; inset:0; background:rgba(0,0,0,0.55);
        backdrop-filter:blur(5px); z-index:10002;
        display:none; align-items:center; justify-content:center;
        padding:20px; animation:fadeIn 0.25s ease;">
    <div class="shortcut-modal-panel">
      <div class="shortcut-modal-header">
        <div>
          <h2 class="shortcut-modal-title" style="position:static;height:auto;background:none;box-shadow:none;border:none;font-size:20px;">🌞 Unlock Courses Earlier — Summer Bridge</h2>
          <p class="shortcut-modal-subtitle" id="bridge-modal-subtitle"></p>
        </div>
        <button class="shortcut-modal-close" onclick="closeBridgeModal()" title="Close">✕</button>
      </div>
      <div class="shortcut-options-grid" id="bridge-options-grid"></div>
    </div>
  </div>

  <script>
    // ============================================================
    // TECHBOT NOTIFICATION SYSTEM
    // ============================================================
    
    const TechBot = {
      prefixes: ['Processing...', 'System update:', 'Optimization complete:', 'Analysis:', 'Computing...', 'Executing...'],
      
      // Show toast notification (bottom right)
      notify(message, duration = 4000) {
        const toast = document.getElementById('techbot-toast');
        const textEl = document.getElementById('toast-text');
        
        // Random prefix
        const prefix = this.prefixes[Math.floor(Math.random() * this.prefixes.length)];
        textEl.innerHTML = `${prefix} ${message}`;
        
        toast.classList.add('show');
        
        setTimeout(() => {
          toast.classList.remove('show');
        }, duration);
      },
      
      // Show modal dialog
      showModal(title, message, buttons = null) {
        const modal = document.getElementById('techbot-modal');
        const titleEl = document.getElementById('modal-title');
        const textEl = document.getElementById('modal-text');
        const buttonsEl = document.getElementById('modal-buttons');
        
        titleEl.textContent = title || '🤖 Assistant Bot Says';
        textEl.innerHTML = message;
        
        // Custom buttons or default
        if (buttons) {
          buttonsEl.innerHTML = buttons;
        } else {
          buttonsEl.innerHTML = '<button class="modal-btn modal-btn-primary" onclick="closeTechBotModal()">Got it!</button>';
        }
        
        modal.classList.add('show');
      },
      
      // Confirm dialog
      confirm(title, message, onConfirm, onCancel) {
        const buttons = `
          <button class="modal-btn modal-btn-secondary" onclick="closeTechBotModal(); ${onCancel ? onCancel + '()' : ''}">Cancel</button>
          <button class="modal-btn modal-btn-primary" onclick="closeTechBotModal(); ${onConfirm}()">Confirm</button>
        `;
        this.showModal(title, message, buttons);
      },
      
      // Success message
      success(message) {
        this.notify(message);
      },
      
      // Error message
      error(message) {
        this.showModal('⚠️ System Alert', message);
      },
      
      // Warning message
      warning(message) {
        this.notify(message, 5000);
      }
    };
    
    function closeTechBotModal() {
      document.getElementById('techbot-modal').classList.remove('show');
    }
    
    // Close modal on outside click
    document.addEventListener('click', (e) => {
      const modal = document.getElementById('techbot-modal');
      if (e.target === modal) {
        closeTechBotModal();
      }
    });

    // ============================================================
    // UNDO/REDO SYSTEM
    // ============================================================
    
    const UndoRedoManager = {
      undoStack: [],
      redoStack: [],
      maxStackSize: 50,
      
      saveState(description) {
        const state = {
          description: description,
          studyPlanHTML: document.getElementById('studyPlanDisplay')?.innerHTML || '',
          courseListHTML: document.getElementById('courseList')?.innerHTML || '',
          timestamp: Date.now()
        };
        
        this.undoStack.push(state);
        if (this.undoStack.length > this.maxStackSize) {
          this.undoStack.shift();
        }
        
        // Clear redo stack on new action
        this.redoStack = [];
        
        console.log('State saved:', description);
      },
      
      undo() {
        if (this.undoStack.length === 0) {
          TechBot.notify('No actions to undo');
          return;
        }
        
        // Save current state to redo stack
        const currentState = {
          studyPlanHTML: document.getElementById('studyPlanDisplay')?.innerHTML || '',
          courseListHTML: document.getElementById('courseList')?.innerHTML || '',
          timestamp: Date.now()
        };
        this.redoStack.push(currentState);
        
        // Restore previous state
        const previousState = this.undoStack.pop();
        document.getElementById('studyPlanDisplay').innerHTML = previousState.studyPlanHTML;
        document.getElementById('courseList').innerHTML = previousState.courseListHTML;
        
        // Reinitialize drag and drop
        if (window.initializeDragAndDrop) {
          window.initializeDragAndDrop();
        }
        
        TechBot.notify(`Undone: ${previousState.description}`);
      },
      
      redo() {
        if (this.redoStack.length === 0) {
          TechBot.notify('No actions to redo');
          return;
        }
        
        // Save current state to undo stack
        const currentState = {
          studyPlanHTML: document.getElementById('studyPlanDisplay')?.innerHTML || '',
          courseListHTML: document.getElementById('courseList')?.innerHTML || '',
          timestamp: Date.now()
        };
        this.undoStack.push(currentState);
        
        // Restore next state
        const nextState = this.redoStack.pop();
        document.getElementById('studyPlanDisplay').innerHTML = nextState.studyPlanHTML;
        document.getElementById('courseList').innerHTML = nextState.courseListHTML;
        
        // Reinitialize drag and drop
        if (window.initializeDragAndDrop) {
          window.initializeDragAndDrop();
        }
        
        TechBot.notify('Action redone');
      }
    };
    
    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', (e) => {
      // Ctrl+Z or Cmd+Z for undo
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        UndoRedoManager.undo();
      }
      
      // Ctrl+Y or Cmd+Y for redo
      if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
        e.preventDefault();
        UndoRedoManager.redo();
      }
      
      // Ctrl+Shift+Z for redo (alternative)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') {
        e.preventDefault();
        UndoRedoManager.redo();
      }
    });

    // ============================================================
    // COURSE CONSTRAINTS VALIDATION
    // ============================================================
    
    const CourseConstraints = {
      // Check if course can be added to a semester
      canAddCourse(courseName, semesterType, semesterNumber, completedCredits, completedCourses) {
        const normalizedName = courseName.trim();
        
        // Summer Training constraints
        if (normalizedName.includes('Summer Training') || normalizedName.includes('التدريب الصيفي')) {
          if (semesterType !== 'Summer') {
            return {
              allowed: false,
              reason: 'Summer Training can only be added to summer semesters.'
            };
          }
          if (completedCredits < 60) {
            return {
              allowed: false,
              reason: `Summer Training requires at least 60 credit hours. You currently have ${completedCredits} hours.`
            };
          }
        }
        
        // Project 1 constraints
        if (normalizedName.includes('Project 1') || normalizedName.includes('مشروع 1')) {
          if (semesterType === 'Even') {
            return {
              allowed: false,
              reason: 'Project 1 can only be taken in odd semesters (Fall).'
            };
          }
          if (semesterType === 'Summer') {
            return {
              allowed: false,
              reason: 'Project 1 cannot be taken in summer semesters.'
            };
          }
          if (completedCredits < 85) {
            return {
              allowed: false,
              reason: `Project 1 requires at least 85 credit hours. You currently have ${completedCredits} hours.`
            };
          }
        }
        
        // Project 2 constraints
        if (normalizedName.includes('Project 2') || normalizedName.includes('مشروع 2')) {
          if (semesterType === 'Odd') {
            return {
              allowed: false,
              reason: 'Project 2 can only be taken in even semesters (Spring).'
            };
          }
          if (semesterType === 'Summer') {
            return {
              allowed: false,
              reason: 'Project 2 cannot be taken in summer semesters.'
            };
          }
          
          // Check if Project 1 is completed
          const hasProject1 = completedCourses.some(course => 
            course.includes('Project 1') || course.includes('مشروع 1')
          );
          
          if (!hasProject1) {
            return {
              allowed: false,
              reason: 'Project 2 requires completion of Project 1 first.'
            };
          }
        }
        
        return { allowed: true };
      },
      
      // Calculate completed credits from semesters before current
      // Also includes transcript (already-passed) course credits passed via the
      // optional `transcriptCodes` array.
      calculateCompletedCredits(allSemesters, currentSemesterIndex, transcriptCodes) {
        let credits = 0;
        // Count transcript (already-passed) hours first
        if (transcriptCodes && Array.isArray(transcriptCodes)) {
          transcriptCodes.forEach(code => {
            if (code !== 'BMA001' && window._currentCourses && window._currentCourses[code]) {
              credits += window._currentCourses[code].hours || 0;
            }
          });
        }
        // Count plan semester hours before the target
        for (let i = 0; i < currentSemesterIndex; i++) {
          const semester = allSemesters[i];
          const courseEls = semester.querySelectorAll('.semester-course-item');
          courseEls.forEach(course => {
            const creditMatch = course.textContent.match(/\((\d+)\s*(?:ساعة|hours?)\)/i);
            if (creditMatch) {
              credits += parseInt(creditMatch[1]);
            }
          });
        }
        return credits;
      },
      
      // Get completed courses from previous semesters
      getCompletedCourses(allSemesters, currentSemesterIndex) {
        const courses = [];
        for (let i = 0; i < currentSemesterIndex; i++) {
          const semester = allSemesters[i];
          const courseElements = semester.querySelectorAll('.semester-course-item');
          courseElements.forEach(el => {
            courses.push(el.textContent.trim());
          });
        }
        return courses;
      }
    };

    // ============================================================
    // EXPORT STUDY PLAN AS PDF (using html2pdf.js)
    // ============================================================
    function exportStudyPlanAsPDF() {
      const planDisplay = document.getElementById('studyPlanDisplay');
      const studentInfoEl = document.getElementById('studentInfo');
      
      if (!planDisplay || planDisplay.innerHTML.trim() === '') {
        TechBot.error('Please generate a study plan first before exporting!');
        return;
      }
      
      TechBot.notify('Initializing PDF export sequence...');
      
      // Gather student information
      const studentName = studentInfo?.name || document.getElementById('studentName')?.textContent?.replace('👤 Name: ', '') || 'Student Name';
      const studentId = studentInfo?.id || document.getElementById('studentId')?.textContent?.replace('🆔 ID: ', '') || 'N/A';
      const studentCenter = studentInfo?.level || 'Computer Science Program';
      const studentGPA = studentInfo?.gpa || '0.00';
      const completedHours = selected.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
      
      // Build print-friendly container
      const printWrapper = document.createElement('div');
      printWrapper.id = 'pdf-export-wrapper';
      printWrapper.style.cssText = 'font-family: Arial, sans-serif; padding: 20px; color: #000; background: white; width: 794px; min-height: 500px;';
      
      // Build HTML content matching Excel structure
      let html = `
        <div style="border-bottom: 3px solid #2563eb; padding-bottom: 12px; margin-bottom: 20px;">
          <h1 style="margin: 0; font-size: 24px; color: #1e3a8a;">🎓 Study Plan</h1>
          <p style="margin: 5px 0 0; font-size: 12px; color: #64748b;">
            Generated on ${new Date().toLocaleDateString('en-US', {year:'numeric', month:'long', day:'numeric'})}
          </p>
        </div>
        
        <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
          <table style="width: 100%; font-size: 13px;">
            <tr>
              <td style="padding: 4px 0; font-weight: 600; width: 150px;">Name:</td>
              <td style="padding: 4px 0;">${studentName}</td>
            </tr>
            <tr>
              <td style="padding: 4px 0; font-weight: 600;">ID:</td>
              <td style="padding: 4px 0;">${studentId}</td>
            </tr>
            <tr>
              <td style="padding: 4px 0; font-weight: 600;">Center:</td>
              <td style="padding: 4px 0;">${studentCenter}</td>
            </tr>
            <tr>
              <td style="padding: 4px 0; font-weight: 600;">Gained Hours:</td>
              <td style="padding: 4px 0;">${completedHours}</td>
            </tr>
            <tr>
              <td style="padding: 4px 0; font-weight: 600;">GPA:</td>
              <td style="padding: 4px 0;">${studentGPA}</td>
            </tr>
          </table>
        </div>
        
        <div style="margin-bottom: 25px;">
          <h3 style="margin: 0 0 10px; font-size: 16px; color: #1e3a8a; border-bottom: 2px solid #e5e7eb; padding-bottom: 6px;">
            All Passed Till Now
          </h3>
          <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
      `;
      
      // Add completed courses
      let completedTotal = 0;
      let hasMath0 = false;
      selected.forEach((code, index) => {
        const course = courses[code];
        if (course) {
          const bg = index % 2 === 0 ? '#f8fafc' : '#ffffff';
          html += `
            <tr style="background: ${bg};">
              <td style="padding: 6px 8px; border-bottom: 1px solid #e5e7eb;">${course.name}</td>
              <td style="padding: 6px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; width: 80px;">${course.hours} hours</td>
            </tr>
          `;
          if (course.name.includes('Mathematics - 0') || course.name.includes('Mathematics-0')) {
            hasMath0 = true;
          } else {
            completedTotal += course.hours;
          }
        }
      });
      
      // If Math-0 wasn't excluded, add all hours
      if (!hasMath0) {
        completedTotal = selected.reduce((sum, code) => sum + (courses[code]?.hours || 0), 0);
      }
      
      html += `
            <tr style="background: #dbeafe; font-weight: 600;">
              <td style="padding: 8px; border-top: 2px solid #3b82f6;">Total Hours</td>
              <td style="padding: 8px; text-align: right; border-top: 2px solid #3b82f6;">${completedTotal} hours</td>
            </tr>
          </table>
        </div>
      `;
      
      // Add planned semesters from the study plan display
      const semesterCards = planDisplay.querySelectorAll('.semester-card');
      let grandTotal = completedTotal;
      
      semesterCards.forEach((card, semIndex) => {
        const titleEl = card.querySelector('.semester-title, h3');
        const semesterTitle = titleEl ? titleEl.textContent.trim() : `Semester ${semIndex + 1}`;
        
        html += `
          <div style="margin-bottom: 25px; page-break-inside: avoid;">
            <h3 style="margin: 0 0 10px; font-size: 16px; color: #1e3a8a; border-bottom: 2px solid #e5e7eb; padding-bottom: 6px;">
              ${semesterTitle}
            </h3>
            <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
        `;
        
        const courseItems = card.querySelectorAll('.semester-course-item');
        let semesterTotal = 0;
        
        courseItems.forEach((item, courseIndex) => {
          const courseText = item.textContent.trim();
          const hoursMatch = courseText.match(/\((\d+)\s*(?:hours?|ساعة|ساعات)\)/i);
          const hours = hoursMatch ? parseInt(hoursMatch[1]) : 3;
          const courseName = courseText.replace(/\(\d+\s*(?:hours?|ساعة|ساعات)\)/gi, '').trim();
          
          const bg = courseIndex % 2 === 0 ? '#f8fafc' : '#ffffff';
          html += `
            <tr style="background: ${bg};">
              <td style="padding: 6px 8px; border-bottom: 1px solid #e5e7eb;">${courseName}</td>
              <td style="padding: 6px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; width: 80px;">${hours} hours</td>
            </tr>
          `;
          semesterTotal += hours;
        });
        
        html += `
              <tr style="background: #dbeafe; font-weight: 600;">
                <td style="padding: 8px; border-top: 2px solid #3b82f6;">Total Hours</td>
                <td style="padding: 8px; text-align: right; border-top: 2px solid #3b82f6;">${semesterTotal} hours</td>
              </tr>
            </table>
          </div>
        `;
        
        grandTotal += semesterTotal;
      });
      
      // Grand total
      html += `
        <div style="background: linear-gradient(135deg, #eff6ff, #dbeafe); border: 2px solid #3b82f6; border-radius: 8px; padding: 15px; margin-top: 20px;">
          <table style="width: 100%; font-size: 15px; font-weight: 700; color: #1e3a8a;">
            <tr>
              <td>Grand Total Hours</td>
              <td style="text-align: right;">${grandTotal} hours</td>
            </tr>
          </table>
        </div>
      `;
      
      printWrapper.innerHTML = html;
      
      // Show loading state
      const fabBtn = document.getElementById('fabExportPdf');
      const origText = fabBtn.innerHTML;
      fabBtn.innerHTML = '⏳ Generating PDF...';
      fabBtn.disabled = true;
      
      // Add to document - positioned off-screen so html2canvas can render it
      document.body.appendChild(printWrapper);
      printWrapper.style.position = 'absolute';
      printWrapper.style.left = '-9999px';
      printWrapper.style.top = '0';
      printWrapper.style.zIndex = '-1';
      printWrapper.style.pointerEvents = 'none';
      
      // PDF options
      const opt = {
        margin: [10, 10, 10, 10],
        filename: `Study_Plan_${studentId}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { 
          scale: 2, 
          useCORS: true, 
          letterRendering: true,
          logging: false,
          backgroundColor: '#ffffff',
          scrollX: 0,
          scrollY: 0,
          windowWidth: 794,
          onclone: function(clonedDoc) {
            const wrapper = clonedDoc.getElementById('pdf-export-wrapper');
            if (wrapper) {
              wrapper.style.position = 'relative';
              wrapper.style.left = '0';
              wrapper.style.top = '0';
              wrapper.style.opacity = '1';
              wrapper.style.visibility = 'visible';
            }
          }
        },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      };
      
      // Generate PDF
      setTimeout(() => {
        html2pdf().set(opt).from(printWrapper).save().then(() => {
          document.body.removeChild(printWrapper);
          fabBtn.innerHTML = '✅ PDF Saved!';
          TechBot.success('PDF exported successfully! Download should start automatically.');
          setTimeout(() => {
            fabBtn.innerHTML = origText;
            fabBtn.disabled = false;
          }, 2500);
        }).catch(err => {
          console.error('PDF error:', err);
          if (document.body.contains(printWrapper)) {
            document.body.removeChild(printWrapper);
          }
          fabBtn.innerHTML = origText;
          fabBtn.disabled = false;
          TechBot.error('PDF generation failed. Please try again or use browser print (Ctrl+P).');
        });
      }, 100);
    }

    // ============================================================
    // GRADUATION PROGRESS RING (updates whenever stats update)
    // ============================================================
    function updateProgressRing(percent) {
      const ring = document.getElementById('progressRing');
      const ringText = document.getElementById('progressRingText');
      if (!ring) return;
      
      const radius = 36;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percent / 100) * circumference;
      ring.style.strokeDasharray = circumference;
      ring.style.strokeDashoffset = offset;
      if (ringText) ringText.textContent = Math.round(percent) + '%';
    }

    // Patch calculateStatistics to also update ring
    const _origCalcStats = window.calculateStatistics;
    // We'll override after DOM is ready via MutationObserver on creditPercentage
    const ringObserver = new MutationObserver(function() {
      const pctEl = document.getElementById('creditPercentage');
      if (pctEl) {
        const match = pctEl.textContent.match(/([\d.]+)%/);
        if (match) updateProgressRing(parseFloat(match[1]));
      }
    });
    document.addEventListener('DOMContentLoaded', function() {
      const pctEl = document.getElementById('creditPercentage');
      if (pctEl) ringObserver.observe(pctEl, { childList: true, characterData: true, subtree: true });
    });
  </script>

</body></html>
